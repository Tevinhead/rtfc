
================================================================================
File: compile.py
================================================================================

import os
import fnmatch
import sys
import os

# Add the backend directory to Python path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))
from app.core.logging import get_logger

logger = get_logger(__name__)

def collect_source_code(root_dir, output_file):
    """
    Collects source code files from a directory tree, excluding specified
    directories and file patterns, and writes the collected code to an
    output file.
    """

    # Directories to exclude - These are not relevant for most context or are too large
    exclude_dirs = {
        'node_modules',
        'dist',
        'build',
        '__pycache__',
        'venv',
        '.git',
        'public',
        'assets',
        'logs', 
    }

    # File patterns to include - Focus on core code files
    include_patterns = [
        '*.py',
        '*.tsx',
        '*.ts',
        '*.js',
        '*.jsx',
        '*.css',
        '*.scss',
        '*.html',
    ]

    # Specific files to exclude - These might contain secrets, configs, or are generally not needed for context
    exclude_files = {
        'package.json',
        'package-lock.json',
        'tsconfig.json',
        'vite.config.ts',
        'requirements.txt',
        '.env',
        '.gitignore',
        'README.md',
        'source_code_collection.txt' # Exclude the output file itself
    }

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            # Remove excluded directories in-place to prevent os.walk from traversing them
            dirs[:] = [d for d in dirs if d not in exclude_dirs]

            for file in files:
                if file in exclude_files:
                    continue

                # Check if file matches include patterns
                if any(fnmatch.fnmatch(file, pattern) for pattern in include_patterns):
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, root_dir)

                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            # Write file header with separators
                            outfile.write(f'\n{"="*80}\n')
                            outfile.write(f'File: {relative_path}\n')
                            outfile.write(f'{"="*80}\n\n')

                            # Write file contents
                            outfile.write(infile.read())
                            outfile.write('\n\n')
                    except Exception as e:
                        error_msg = f'Error reading {relative_path}: {str(e)}'
                        logger.error("File read error", 
                                   error=str(e),
                                   file_path=relative_path)
                        outfile.write(f'{error_msg}\n\n')

if __name__ == '__main__':
    root_directory = '.'  # Parent directory
    output_file = 'source_code_collection.txt'

    logger.info("Starting source code collection",
                root_directory=root_directory,
                output_file=output_file)
    
    try:
        collect_source_code(root_directory, output_file)
        logger.info("Source code collection complete",
                   output_file=output_file)
    except Exception as e:
        logger.exception("Source code collection failed",
                        error=str(e))
        raise



================================================================================
File: backend\alter_version_table.py
================================================================================

import asyncio
from app.database import engine
from sqlalchemy import text

async def alter_table():
    async with engine.connect() as conn:
        await conn.execute(text("ALTER TABLE alembic_version ALTER COLUMN version_num TYPE varchar(128);"))
        await conn.commit()
        print("Successfully altered alembic_version table")

if __name__ == "__main__":
    asyncio.run(alter_table())



================================================================================
File: backend\check_and_fix_alembic_version.py
================================================================================

import asyncio
from app.database import engine
from sqlalchemy import text

async def fix_version():
    async with engine.connect() as conn:
        # First ensure the column type is correct
        await conn.execute(text("ALTER TABLE alembic_version ALTER COLUMN version_num TYPE varchar(128);"))
        
        # Then update to our known good version
        await conn.execute(text("UPDATE alembic_version SET version_num = '20250111_add_avatar_url_to_students'"))
        
        await conn.commit()
        print("Successfully updated alembic_version table")

if __name__ == "__main__":
    asyncio.run(fix_version())



================================================================================
File: backend\check_table.py
================================================================================

from sqlalchemy import create_engine, inspect

# Create engine
engine = create_engine('postgresql://postgres:postgres@localhost:5432/rtfc')

# Create inspector
inspector = inspect(engine)

# Check if achievements table exists
print("Achievements table exists:", inspector.has_table("achievements"))
print("Student achievements table exists:", inspector.has_table("student_achievements"))

# List all tables for reference
print("\nAll tables in database:")
print(inspector.get_table_names())



================================================================================
File: backend\check_version.py
================================================================================

from sqlalchemy import create_engine, text
from os import environ
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get database URL from environment
database_url = environ.get('DATABASE_URL')

try:
    # Create engine
    engine = create_engine(database_url.replace('+asyncpg', ''))  # Use sync driver for this script
    
    # Connect and check current version
    with engine.connect() as connection:
        result = connection.execute(text("SELECT version_num FROM alembic_version")).fetchone()
        print(f"Current version in database: {result[0] if result else 'No version found'}")
        
        # Update to a known good revision (20240110_add_arena_battles)
        if result and result[0] == '3f1bd2862147':
            connection.execute(text("UPDATE alembic_version SET version_num = '20240110_add_arena_battles'"))
            connection.commit()
            print("Updated version to 20240110_add_arena_battles")
    
except Exception as e:
    print(f"Error: {e}")



================================================================================
File: backend\fix_alembic.py
================================================================================

from sqlalchemy import create_engine, text
from os import environ
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get database URL from environment
database_url = environ.get('DATABASE_URL')

try:
    # Create engine
    engine = create_engine(database_url)
    
    # Connect and execute update
    with engine.connect() as connection:
        connection.execute(text("UPDATE alembic_version SET version_num = '20250111_add_avatar_url_to_students'"))
        connection.commit()
    
    print("Successfully updated alembic_version table")
    
except Exception as e:
    print(f"Error: {e}")



================================================================================
File: backend\fix_alembic_version.py
================================================================================

import asyncio
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text

async def fix_alembic_version():
    # Create async engine
    engine = create_async_engine('postgresql+asyncpg://postgres:postgres@localhost:5432/rtfc')

    async with engine.begin() as conn:
        # Clear existing version numbers
        await conn.execute(text('DELETE FROM alembic_version'))
        
        # Insert the latest version
        await conn.execute(text("INSERT INTO alembic_version (version_num) VALUES ('20250201_achievements')"))
    
    await engine.dispose()
    print("Alembic version table fixed.")

if __name__ == "__main__":
    asyncio.run(fix_alembic_version())



================================================================================
File: backend\make_nullable.py
================================================================================

from app.database import engine
import asyncio
from sqlalchemy import text

async def make_arena_id_nullable():
    async with engine.connect() as conn:
        await conn.execute(text('ALTER TABLE matches ALTER COLUMN arena_id DROP NOT NULL'))
        await conn.commit()
        print("Successfully made arena_id nullable")

if __name__ == '__main__':
    asyncio.run(make_arena_id_nullable())



================================================================================
File: backend\alembic\env.py
================================================================================

from logging.config import fileConfig
import os
import asyncio
from dotenv import load_dotenv
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

from alembic import context

# Load environment variables
load_dotenv()

import sys
from pathlib import Path

# Add the parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

# Import all models and Base
from app.database import Base
import app.models.student
import app.models.flashcard
import app.models.match
import app.models.achievement
import app.models.arena_session

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set target metadata
target_metadata = Base.metadata

# Get database URL from environment
db_url = os.getenv("DATABASE_URL")
if not db_url:
    raise ValueError("DATABASE_URL environment variable must be set")

# Replace postgresql:// with postgresql+asyncpg:// for async SQLAlchemy
if db_url.startswith("postgresql://"):
    db_url = db_url.replace("postgresql://", "postgresql+asyncpg://", 1)

# Override sqlalchemy.url in alembic.ini
config.set_main_option("sqlalchemy.url", db_url)

def do_run_migrations(connection: Connection) -> None:
    """Run migrations in sync mode"""
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        compare_type=True,  # Compare column types
        compare_server_default=True,  # Compare server defaults
    )

    with context.begin_transaction():
        context.run_migrations()

async def run_async_migrations() -> None:
    """Run migrations in async mode"""
    try:
        configuration = config.get_section(config.config_ini_section, {})
        configuration["sqlalchemy.url"] = db_url

        # Configure async engine with proper pooling and timeout settings
        connectable = async_engine_from_config(
            configuration,
            prefix="sqlalchemy.",
            poolclass=pool.NullPool,
            connect_args={
                "command_timeout": 60,  # 60 second timeout
                "server_settings": {
                    "application_name": "alembic",  # Identify migrations in pg_stat_activity
                }
            }
        )

        async with connectable.connect() as connection:
            await connection.run_sync(do_run_migrations)

        await connectable.dispose()
    except Exception as e:
        print(f"Error during migration: {str(e)}")
        raise

def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode."""
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        compare_type=True,
        compare_server_default=True,
    )

    with context.begin_transaction():
        context.run_migrations()

def run_migrations() -> None:
    """Run migrations based on context mode"""
    if context.is_offline_mode():
        run_migrations_offline()
    else:
        try:
            asyncio.run(run_async_migrations())
        except Exception as e:
            print(f"Migration failed: {str(e)}")
            raise

# Execute migrations
run_migrations()



================================================================================
File: backend\alembic\versions\0312ea2413c8_remove_email_from_students.py
================================================================================

"""remove_email_from_students

Revision ID: 0312ea2413c8
Revises: 43d5d5646264
Create Date: 2024-12-23 23:21:32.334539

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '0312ea2413c8'
down_revision: Union[str, None] = '43d5d5646264'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    op.drop_column('students', 'email')


def downgrade() -> None:
    op.add_column('students',
        sa.Column('email', sa.String(), nullable=False, unique=True)
    )



================================================================================
File: backend\alembic\versions\20240101_add_match_participants.py
================================================================================

"""add match participants

Revision ID: 20240101_add_match_participants
Revises: 0312ea2413c8
Create Date: 2024-01-01

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240101_add_match_participants'
down_revision = '0312ea2413c8'
branch_labels = None
depends_on = None

def upgrade():
    # Create match_participants table
    op.create_table(
        'match_participants',
        sa.Column('match_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_after', sa.Float(), nullable=True),
        sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('match_id', 'student_id')
    )

    # Create round_participants table
    op.create_table(
        'round_participants',
        sa.Column('round_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_change', sa.Float(), nullable=True),
        sa.Column('answer', sa.String(), nullable=True),
        sa.ForeignKeyConstraint(['round_id'], ['rounds.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('round_id', 'student_id')
    )

def downgrade():
    op.drop_table('round_participants')
    op.drop_table('match_participants')



================================================================================
File: backend\alembic\versions\20240110_add_arena_battles.py
================================================================================

"""add arena battles

Revision ID: 20240110_add_arena_battles
Revises: abcde_add_elo_before_to_matches
Create Date: 2024-01-10

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240110_add_arena_battles'
down_revision = 'abcde_add_elo_before_to_matches'
branch_labels = None
depends_on = None

def upgrade():
    # Create enums if they don't exist
    op.execute("DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'arena_session_status') THEN CREATE TYPE arena_session_status AS ENUM ('pending', 'in_progress', 'completed'); END IF; END $$")
    op.execute("DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'match_status') THEN CREATE TYPE match_status AS ENUM ('pending', 'in_progress', 'completed'); END IF; END $$")
    
    # Create arena_sessions table
    op.create_table(
        'arena_sessions',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('status', postgresql.ENUM('pending', 'in_progress', 'completed', name='arena_session_status', create_type=False), nullable=False),
        sa.Column('num_rounds', sa.Integer(), nullable=False),
        sa.Column('rounds_completed', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'))
    )
    
    # Create arena_participants table
    op.create_table(
        'arena_participants',
        sa.Column('arena_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('fights_played', sa.Integer(), nullable=False, server_default='0'),
        sa.ForeignKeyConstraint(['arena_id'], ['arena_sessions.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('arena_id', 'student_id')
    )
    
    # Drop old tables if they exist
    op.execute("DROP TABLE IF EXISTS round_participants CASCADE")
    op.execute("DROP TABLE IF EXISTS rounds CASCADE")
    op.execute("DROP TABLE IF EXISTS match_participants CASCADE")
    op.execute("DROP TABLE IF EXISTS matches CASCADE")
    
    # Create new matches table for 1v1 battles
    op.create_table(
        'matches',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('arena_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('round_number', sa.Integer(), nullable=False),
        sa.Column('status', postgresql.ENUM('pending', 'in_progress', 'completed', name='match_status', create_type=False), nullable=False),
        sa.Column('player1_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('player2_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('winner_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('player1_elo_before', sa.Float(), nullable=False),
        sa.Column('player2_elo_before', sa.Float(), nullable=False),
        sa.Column('player1_elo_after', sa.Float(), nullable=True),
        sa.Column('player2_elo_after', sa.Float(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.ForeignKeyConstraint(['arena_id'], ['arena_sessions.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['player1_id'], ['students.id']),
        sa.ForeignKeyConstraint(['player2_id'], ['students.id']),
        sa.ForeignKeyConstraint(['winner_id'], ['students.id'])
    )

def downgrade():
    # Drop new tables
    op.drop_table('matches')
    op.drop_table('arena_participants')
    op.drop_table('arena_sessions')
    
    # Drop enums if they exist
    op.execute("DROP TYPE IF EXISTS arena_session_status")
    op.execute("DROP TYPE IF EXISTS match_status")
    
    # Recreate old tables (not implemented for brevity)
    pass



================================================================================
File: backend\alembic\versions\20240127_update_matches.py
================================================================================

"""update matches for multiplayer

Revision ID: 20240127_update_matches
Revises: 20240110_add_arena_battles
Create Date: 2024-01-27

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240127_update_matches'
down_revision = '20240110_add_arena_battles'
branch_labels = None
depends_on = None

def upgrade():
    # Drop old tables and constraints
    op.drop_constraint('matches_player1_id_fkey', 'matches', type_='foreignkey')
    op.drop_constraint('matches_player2_id_fkey', 'matches', type_='foreignkey')
    op.drop_constraint('matches_winner_id_fkey', 'matches', type_='foreignkey')
    
    # Drop old columns from matches
    op.drop_column('matches', 'player1_id')
    op.drop_column('matches', 'player2_id')
    op.drop_column('matches', 'winner_id')
    op.drop_column('matches', 'player1_elo_before')
    op.drop_column('matches', 'player2_elo_before')
    op.drop_column('matches', 'player1_elo_after')
    op.drop_column('matches', 'player2_elo_after')
    op.drop_column('matches', 'round_number')
    
    # Add new columns to matches
    op.add_column('matches', sa.Column('num_rounds', sa.Integer(), nullable=False, server_default='1'))
    op.add_column('matches', sa.Column('rounds_completed', sa.Integer(), nullable=False, server_default='0'))
    
    # Create match_participants table
    op.create_table(
        'match_participants',
        sa.Column('match_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_after', sa.Float(), nullable=True),
        sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('match_id', 'student_id')
    )
    
    # Create rounds table
    op.create_table(
        'rounds',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('match_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('flashcard_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('round_number', sa.Integer(), nullable=False),
        sa.Column('winner_ids', postgresql.ARRAY(postgresql.UUID(as_uuid=True)), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['flashcard_id'], ['flashcards.id'])
    )
    
    # Create round_participants table
    op.create_table(
        'round_participants',
        sa.Column('round_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_change', sa.Float(), nullable=True),
        sa.Column('answer', sa.String(), nullable=True),
        sa.ForeignKeyConstraint(['round_id'], ['rounds.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('round_id', 'student_id')
    )

def downgrade():
    # Drop new tables
    op.drop_table('round_participants')
    op.drop_table('rounds')
    op.drop_table('match_participants')
    
    # Drop new columns from matches
    op.drop_column('matches', 'num_rounds')
    op.drop_column('matches', 'rounds_completed')
    
    # Add back old columns to matches
    op.add_column('matches', sa.Column('player1_id', postgresql.UUID(as_uuid=True), nullable=False))
    op.add_column('matches', sa.Column('player2_id', postgresql.UUID(as_uuid=True), nullable=False))
    op.add_column('matches', sa.Column('winner_id', postgresql.UUID(as_uuid=True), nullable=True))
    op.add_column('matches', sa.Column('player1_elo_before', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player2_elo_before', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player1_elo_after', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player2_elo_after', sa.Float(), nullable=True))
    
    # Add back foreign key constraints
    op.create_foreign_key('matches_player1_id_fkey', 'matches', 'students', ['player1_id'], ['id'])
    op.create_foreign_key('matches_player2_id_fkey', 'matches', 'students', ['player2_id'], ['id'])
    op.create_foreign_key('matches_winner_id_fkey', 'matches', 'students', ['winner_id'], ['id'])



================================================================================
File: backend\alembic\versions\20240130_make_arena_id_nullable.py
================================================================================

"""make arena id nullable

Revision ID: 20240130_make_arena_id_nullable
Revises: 20240127_update_matches
Create Date: 2024-01-30

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240130_make_arena_id_nullable'
down_revision = '20240127_update_matches'
branch_labels = None
depends_on = None

def upgrade():
    # Make arena_id nullable
    op.alter_column('matches', 'arena_id',
               existing_type=postgresql.UUID(),
               nullable=True)

def downgrade():
    # Make arena_id non-nullable again
    op.alter_column('matches', 'arena_id',
               existing_type=postgresql.UUID(),
               nullable=False)



================================================================================
File: backend\alembic\versions\20250110_add_match_winner_ids.py
================================================================================

"""add winner_ids array to matches

Revision ID: 20250110_add_match_winner_ids
Revises: abcde_add_elo_before_to_matches
Create Date: 2025-01-10

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20250110_add_match_winner_ids'
down_revision = 'abcde_add_elo_before_to_matches'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column(
        'matches',
        sa.Column('winner_ids', postgresql.ARRAY(postgresql.UUID(as_uuid=True)), nullable=True)
    )

def downgrade():
    op.drop_column('matches', 'winner_ids')



================================================================================
File: backend\alembic\versions\20250111_add_avatar_url_to_students.py
================================================================================

"""
Add avatar_url to students

Revision ID: 20250111_add_avatar_url_to_students
Revises: 20250110_add_match_winner_ids
Create Date: 2025-01-11
"""

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '20250111_add_avatar_url_to_students'
down_revision = '20250110_add_match_winner_ids'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column('students', sa.Column('avatar_url', sa.String(), nullable=True))

def downgrade():
    op.drop_column('students', 'avatar_url')



================================================================================
File: backend\alembic\versions\20250116_fix_unknown_results.py
================================================================================

"""fix unknown results

Revision ID: 20250116_fix_unknown
Revises: 20250113_add_images_to_flashcards
Create Date: 2025-01-16 12:16:26.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = '20250116_fix_unknown'
down_revision = '20250116_merge_heads'
branch_labels = None
depends_on = None

def upgrade():
    # Delete round_participants for matches with no winners
    op.execute("""
    DELETE FROM round_participants
    WHERE round_id IN (
        SELECT r.id
        FROM rounds r
        JOIN matches m ON r.match_id = m.id
        WHERE m.status = 'completed' AND (
            m.winner_ids IS NULL
            OR array_length(m.winner_ids, 1) IS NULL
            OR array_length(m.winner_ids, 1) = 0
        )
    );
    """)

    # Delete rounds for matches with no winners
    op.execute("""
    DELETE FROM rounds
    WHERE match_id IN (
        SELECT id FROM matches
        WHERE status = 'completed' AND (
            winner_ids IS NULL
            OR array_length(winner_ids, 1) IS NULL
            OR array_length(winner_ids, 1) = 0
        )
    );
    """)

    # Delete match_participants for matches with no winners
    op.execute("""
    DELETE FROM match_participants
    WHERE match_id IN (
        SELECT id FROM matches
        WHERE status = 'completed' AND (
            winner_ids IS NULL
            OR array_length(winner_ids, 1) IS NULL
            OR array_length(winner_ids, 1) = 0
        )
    );
    """)

    # Delete matches with no winners
    op.execute("""
    DELETE FROM matches
    WHERE status = 'completed' AND (
        winner_ids IS NULL
        OR array_length(winner_ids, 1) IS NULL
        OR array_length(winner_ids, 1) = 0
    );
    """)

    # Recalculate student stats directly with a single query
    op.execute("""
    WITH match_stats AS (
        SELECT
            mp.student_id,
            COUNT(*) FILTER (WHERE m.status = 'completed' AND array_length(m.winner_ids, 1) > 0 AND mp.student_id = ANY(m.winner_ids)) as wins,
            COUNT(*) FILTER (WHERE m.status = 'completed' AND array_length(m.winner_ids, 1) > 0 AND mp.student_id != ALL(m.winner_ids)) as losses
        FROM match_participants mp
        JOIN matches m ON mp.match_id = m.id
        GROUP BY mp.student_id
    )
    UPDATE students s
    SET
        wins = COALESCE(ms.wins, 0),
        losses = COALESCE(ms.losses, 0),
        total_matches = COALESCE(ms.wins + ms.losses, 0)
    FROM match_stats ms
    WHERE s.id = ms.student_id;
    """)

def downgrade():
    # No downgrade path needed as this is a data fix
    pass


================================================================================
File: backend\alembic\versions\20250116_merge_heads.py
================================================================================

"""merge heads

Revision ID: 20250116_merge_heads
Revises: 20250111_add_avatar_url_to_students, abcde_add_elo_before_to_matches
Create Date: 2025-01-16 12:17:23.000000

"""
from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '20250116_merge_heads'
down_revision = None
branch_labels = None
depends_on = None

# Specify all parents
parents = ['20250111_add_avatar_url_to_students', 'abcde_add_elo_before_to_matches']

def upgrade():
    pass

def downgrade():
    pass


================================================================================
File: backend\alembic\versions\20250201_achievements.py
================================================================================

"""create achievements tables

Revision ID: 20250201_achievements
Revises: 20250116_merge_heads
Create Date: 2025-02-01 12:44:00.000000

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
import uuid

# revision identifiers, used by Alembic.
revision = '20250201_achievements'
down_revision = '20250116_merge_heads'  # Point to the latest merged head
branch_labels = None
depends_on = None

def upgrade():
    op.create_table(
        'achievements',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),
        sa.Column('code', sa.String(), nullable=False, unique=True),
        sa.Column('title', sa.String(), nullable=False),
        sa.Column('description', sa.String(), nullable=True),
        sa.Column('criteria', sa.JSON(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=True),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.func.now(), onupdate=sa.func.now(), nullable=True),
    )

    op.create_table(
        'student_achievements',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True, default=uuid.uuid4),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), sa.ForeignKey('students.id', ondelete='CASCADE'), nullable=False),
        sa.Column('achievement_id', postgresql.UUID(as_uuid=True), sa.ForeignKey('achievements.id', ondelete='CASCADE'), nullable=False),
        sa.Column('achieved_at', sa.DateTime(timezone=True), server_default=sa.func.now(), nullable=True),
    )

    # Add some initial achievements
    op.execute("""
        INSERT INTO achievements (id, code, title, description)
        VALUES 
        (uuid_generate_v4(), 'elo-1000', 'ELO Master', 'Reach an ELO rating of 1000'),
        (uuid_generate_v4(), 'elo-1100', 'ELO Champion', 'Reach an ELO rating of 1100'),
        (uuid_generate_v4(), 'streak-3-win', 'Triple Threat', 'Win 3 matches in a row'),
        (uuid_generate_v4(), 'streak-4-win', 'Ultra Kill', 'Win 4 matches in a row')
    """)

def downgrade():
    op.drop_table('student_achievements')
    op.drop_table('achievements')



================================================================================
File: backend\alembic\versions\43d5d5646264_initial_schema.py
================================================================================

"""Initial schema

Revision ID: 43d5d5646264
Revises: 
Create Date: 2024-12-22 14:43:11.278303

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '43d5d5646264'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('flashcard_packs',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('students',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('elo_rating', sa.Float(), nullable=True),
    sa.Column('wins', sa.Integer(), nullable=True),
    sa.Column('losses', sa.Integer(), nullable=True),
    sa.Column('total_matches', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.create_table('flashcards',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('question', sa.String(), nullable=False),
    sa.Column('answer', sa.String(), nullable=False),
    sa.Column('pack_id', sa.UUID(), nullable=False),
    sa.Column('difficulty', sa.Enum('EASY', 'MEDIUM', 'HARD', name='difficultylevel'), nullable=True),
    sa.Column('times_used', sa.Integer(), nullable=True),
    sa.Column('times_correct', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['pack_id'], ['flashcard_packs.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('matches',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('player1_id', sa.UUID(), nullable=False),
    sa.Column('player2_id', sa.UUID(), nullable=False),
    sa.Column('winner_id', sa.UUID(), nullable=True),
    sa.Column('status', sa.Enum('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', name='matchstatus'), nullable=True),
    sa.Column('player1_elo_change', sa.Float(), nullable=True),
    sa.Column('player2_elo_change', sa.Float(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['player1_id'], ['students.id'], ),
    sa.ForeignKeyConstraint(['player2_id'], ['students.id'], ),
    sa.ForeignKeyConstraint(['winner_id'], ['students.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('rounds',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('match_id', sa.UUID(), nullable=False),
    sa.Column('flashcard_id', sa.UUID(), nullable=False),
    sa.Column('winner_id', sa.UUID(), nullable=True),
    sa.Column('player1_answer', sa.String(), nullable=True),
    sa.Column('player2_answer', sa.String(), nullable=True),
    sa.Column('round_number', sa.String(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['flashcard_id'], ['flashcards.id'], ),
    sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ),
    sa.ForeignKeyConstraint(['winner_id'], ['students.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('rounds')
    op.drop_table('matches')
    op.drop_table('flashcards')
    op.drop_table('students')
    op.drop_table('flashcard_packs')
    # ### end Alembic commands ###



================================================================================
File: backend\alembic\versions\623fcaf9bd91_merge_multiple_heads.py
================================================================================

"""merge multiple heads

Revision ID: 623fcaf9bd91
Revises: 20240130_make_arena_id_nullable, 20250111_add_avatar_url_to_students
Create Date: 2025-01-10 17:39:17.697032

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '623fcaf9bd91'
down_revision: Union[str, None] = ('20240130_make_arena_id_nullable', '20250111_add_avatar_url_to_students')
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    pass


def downgrade() -> None:
    pass



================================================================================
File: backend\alembic\versions\abcde_add_elo_before_to_matches.py
================================================================================

"""add elo before to matches

Revision ID: abcde_add_elo_before_to_matches
Revises: 20240101_add_match_participants
Create Date: 2024-01-05

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = 'abcde_add_elo_before_to_matches'
down_revision = '20240101_add_match_participants'
branch_labels = None
depends_on = None

def upgrade():
    # Add ELO tracking columns to matches
    op.add_column('matches', sa.Column('player1_elo_before', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player2_elo_before', sa.Float(), nullable=True))

def downgrade():
    # Remove ELO tracking columns
    op.drop_column('matches', 'player1_elo_before')
    op.drop_column('matches', 'player2_elo_before')



================================================================================
File: backend\app\database.py
================================================================================

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from dotenv import load_dotenv
import os

# Load environment variables
load_dotenv()

# Get database URL from environment variable and convert it to async format
DATABASE_URL = os.getenv("DATABASE_URL")
if DATABASE_URL and DATABASE_URL.startswith("postgresql://"):
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

# Create async engine
engine = create_async_engine(DATABASE_URL, echo=True)

# Create async session factory
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

# Create declarative base
Base = declarative_base()

# Dependency to get database session
async def get_db():
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()



================================================================================
File: backend\app\__init__.py
================================================================================

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(
    title="Flashcard Arena API",
    redirect_slashes=True
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Frontend development server
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allow_headers=["Content-Type", "Authorization", "Accept"],
    expose_headers=["Content-Type"],
)

# Import routers
from .routers import flashcards, students, matches, arena, flashcard_stats, achievements

# Include routers
app.include_router(flashcards.router, prefix="/api/flashcards", tags=["flashcards"])
app.include_router(students.router, prefix="/api/students", tags=["students"])
app.include_router(matches.router, prefix="/api/matches", tags=["matches"])
app.include_router(arena.router, prefix="/api/arena", tags=["arena"])
app.include_router(flashcard_stats.router, prefix="/api/stats", tags=["statistics"])
app.include_router(achievements.router, prefix="/api/achievements", tags=["achievements"])



================================================================================
File: backend\app\core\logging.py
================================================================================

import logging

def get_logger(name: str) -> logging.Logger:
    """
    Creates and returns a logger with the specified name and basic configuration.
    """
    logger = logging.getLogger(name)
    
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    
    return logger



================================================================================
File: backend\app\models\achievement.py
================================================================================

from sqlalchemy import Column, String, DateTime, ForeignKey, func, JSON
from sqlalchemy.dialects.postgresql import UUID
import uuid
from app.database import Base

class Achievement(Base):
    __tablename__ = "achievements"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    code = Column(String, unique=True, nullable=False)  # e.g. "elo-1000", "streak-3-win"
    title = Column(String, nullable=False)
    description = Column(String, nullable=True)
    criteria = Column(JSON, nullable=True)  # Optional JSON to store criteria parameters if needed
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=True)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now(), nullable=True)


class StudentAchievement(Base):
    __tablename__ = "student_achievements"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    student_id = Column(UUID(as_uuid=True), ForeignKey("students.id", ondelete="CASCADE"), nullable=False)
    achievement_id = Column(UUID(as_uuid=True), ForeignKey("achievements.id", ondelete="CASCADE"), nullable=False)
    achieved_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=True)



================================================================================
File: backend\app\models\arena_schemas.py
================================================================================

from pydantic import BaseModel, conlist
from typing import List, Optional
from uuid import UUID
from .arena_session import ArenaSessionStatus
from .match import MatchStatus

class CreateArenaRequest(BaseModel):
    student_ids: conlist(UUID, min_length=2)  # At least 2 players required
    num_rounds: int

class StudentStatsResponse(BaseModel):
    student_id: UUID
    name: str
    elo_rating: float
    wins: int
    losses: int
    fights_played: int
    elo_change: float  # Total ELO change in this arena session

    class Config:
        from_attributes = True

class ArenaSessionResponse(BaseModel):
    id: UUID
    status: ArenaSessionStatus
    num_rounds: int
    rounds_completed: int
    participants: List[StudentStatsResponse]

    class Config:
        from_attributes = True

class MatchParticipantResponse(BaseModel):
    student_id: UUID
    elo_before: float
    elo_after: Optional[float]

    class Config:
        from_attributes = True

class MatchResponse(BaseModel):
    id: UUID
    status: MatchStatus
    num_rounds: int
    rounds_completed: int
    participants: List[MatchParticipantResponse]

    class Config:
        from_attributes = True

class SetMatchWinnerRequest(BaseModel):
    winner_ids: List[UUID]

class MatchWinnerResponse(BaseModel):
    match: MatchResponse
    arena_session: ArenaSessionResponse

    class Config:
        from_attributes = True



================================================================================
File: backend\app\models\arena_session.py
================================================================================

from sqlalchemy import Column, DateTime, String, Integer, Enum, func, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
import enum
from ..database import Base

class ArenaSessionStatus(enum.Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

class ArenaParticipant(Base):
    __tablename__ = 'arena_participants'
    
    arena_id = Column(UUID(as_uuid=True), ForeignKey('arena_sessions.id'), primary_key=True)
    student_id = Column(UUID(as_uuid=True), ForeignKey('students.id'), primary_key=True)
    fights_played = Column(Integer, default=0)
    
    # relationships
    arena = relationship("ArenaSession", back_populates="participants")
    student = relationship("Student", lazy="selectin")

class ArenaSession(Base):
    __tablename__ = "arena_sessions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    status = Column(
        Enum(ArenaSessionStatus, name="arena_session_status", create_type=False,
             values_callable=lambda x: [e.value for e in x]),
        default=ArenaSessionStatus.PENDING
    )
    num_rounds = Column(Integer, nullable=False)  # Total number of 1v1 fights to complete
    rounds_completed = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    # relationships
    participants = relationship("ArenaParticipant", back_populates="arena", cascade="all, delete-orphan", lazy="selectin")
    matches = relationship("Match", back_populates="arena_session", cascade="all, delete-orphan", lazy="selectin")



================================================================================
File: backend\app\models\flashcard.py
================================================================================

from sqlalchemy import Column, String, Integer, DateTime, ForeignKey, func, Enum
from sqlalchemy.dialects.postgresql import UUID
import uuid
import enum
from ..database import Base

class DifficultyLevel(enum.Enum):
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"

class Flashcard(Base):
    __tablename__ = "flashcards"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    question = Column(String, nullable=False)
    answer = Column(String, nullable=False)
    pack_id = Column(UUID(as_uuid=True), ForeignKey("flashcard_packs.id"), nullable=False)
    difficulty = Column(Enum(DifficultyLevel), default=DifficultyLevel.MEDIUM)
    times_used = Column(Integer, default=0)
    times_correct = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    @property
    def success_rate(self):
        if self.times_used == 0:
            return 0.0
        return (self.times_correct / self.times_used) * 100

    def update_stats(self, correct: bool):
        """Update flashcard statistics after use"""
        self.times_used += 1
        if correct:
            self.times_correct += 1

class FlashcardPack(Base):
    __tablename__ = "flashcard_packs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    description = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())



================================================================================
File: backend\app\models\match.py
================================================================================

from sqlalchemy import Column, ForeignKey, DateTime, String, Float, Enum, Integer, func
from sqlalchemy.dialects.postgresql import UUID, ARRAY
from sqlalchemy.orm import relationship
import uuid
import enum
from ..database import Base

class MatchStatus(str, enum.Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

class MatchParticipant(Base):
    __tablename__ = "match_participants"

    match_id = Column(UUID(as_uuid=True), ForeignKey('matches.id'), primary_key=True)
    student_id = Column(UUID(as_uuid=True), ForeignKey('students.id'), primary_key=True)
    elo_before = Column(Float)
    elo_after = Column(Float)

    # relationships
    match = relationship("Match", back_populates="participants")
    student = relationship("Student")

class RoundParticipant(Base):
    __tablename__ = "round_participants"

    round_id = Column(UUID(as_uuid=True), ForeignKey('rounds.id'), primary_key=True)
    student_id = Column(UUID(as_uuid=True), ForeignKey('students.id'), primary_key=True)
    elo_before = Column(Float)
    elo_change = Column(Float)
    answer = Column(String)

    # relationships
    round = relationship("Round", back_populates="participants")
    student = relationship("Student")

class Match(Base):
    __tablename__ = "matches"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    arena_id = Column(
        UUID(as_uuid=True),
        ForeignKey("arena_sessions.id", ondelete="CASCADE"),
        nullable=True
    )
    status = Column(
        Enum(MatchStatus, name="match_status", create_type=False, values_callable=lambda x: [e.value for e in x]),
        default=MatchStatus.PENDING
    )  # Must match DB type name exactly
    num_rounds = Column(Integer, nullable=False)
    rounds_completed = Column(Integer, default=0)
    
    # Array of winner IDs (supports multiple winners)
    winner_ids = Column(ARRAY(UUID(as_uuid=True)), nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    # relationships
    participants = relationship("MatchParticipant", back_populates="match", cascade="all, delete-orphan", lazy="selectin")
    rounds = relationship("Round", back_populates="match", cascade="all, delete-orphan")
    arena_session = relationship("ArenaSession", back_populates="matches")

class Round(Base):
    __tablename__ = "rounds"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    match_id = Column(UUID(as_uuid=True), ForeignKey("matches.id"), nullable=False)
    flashcard_id = Column(UUID(as_uuid=True), ForeignKey("flashcards.id"), nullable=False)
    round_number = Column(Integer, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Array of winner IDs (supports multiple winners)
    winner_ids = Column(ARRAY(UUID(as_uuid=True)), nullable=True)

    # relationships
    match = relationship("Match", back_populates="rounds")
    flashcard = relationship("Flashcard")
    participants = relationship("RoundParticipant", back_populates="round", cascade="all, delete-orphan")



================================================================================
File: backend\app\models\student.py
================================================================================

from sqlalchemy import Column, Integer, String, Float, DateTime, func
from sqlalchemy.dialects.postgresql import UUID
import uuid
from ..database import Base

class Student(Base):
    __tablename__ = "students"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    avatar_url = Column(String, nullable=True)  # NEW COLUMN for profile pictures
    elo_rating = Column(Float, default=1000.0)  # Starting ELO rating
    wins = Column(Integer, default=0)
    losses = Column(Integer, default=0)
    total_matches = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    @property
    def win_rate(self):
        if self.total_matches == 0:
            return 0.0
        return (self.wins / self.total_matches) * 100

    def update_stats(self, won: bool, new_elo: float):
        """Update player statistics after a match"""
        self.elo_rating = new_elo
        self.total_matches += 1
        if won:
            self.wins += 1
        else:
            self.losses += 1



================================================================================
File: backend\app\models\__init__.py
================================================================================

# This file makes the models directory a Python package
from .student import Student
from .flashcard import Flashcard
from .match import Match



================================================================================
File: backend\app\routers\achievements.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db
from app.models.achievement import Achievement, StudentAchievement
from app.schemas.achievement import AchievementResponse, StudentAchievementResponse
from app.services import achievement_service
from sqlalchemy.future import select
from typing import List
from uuid import UUID

router = APIRouter(prefix="/achievements", tags=["achievements"])

@router.get("/", response_model=List[AchievementResponse])
async def get_achievements(db: AsyncSession = Depends(get_db)):
    """Get all available achievements."""
    achievements = await achievement_service.get_all_achievements(db)
    return achievements

@router.get("/students/{student_id}", response_model=List[StudentAchievementResponse])
async def get_student_achievements(student_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get all achievements earned by a specific student."""
    # Verify student exists
    student_achievements = await achievement_service.get_student_achievements(student_id, db)
    
    # Load the full achievement data for each student achievement
    result = []
    for sa in student_achievements:
        achievement = await db.get(Achievement, sa.achievement_id)
        if achievement:
            result.append({
                "id": sa.id,
                "student_id": sa.student_id,
                "achievement": achievement,
                "achieved_at": sa.achieved_at
            })
    
    return result



================================================================================
File: backend\app\routers\arena.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from typing import List
from uuid import UUID
from ..database import get_db
from ..models.arena_session import ArenaSession, ArenaSessionStatus, ArenaParticipant
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.student import Student
from ..models.arena_schemas import (
    CreateArenaRequest,
    StudentStatsResponse,
    ArenaSessionResponse,
    MatchResponse,
    SetMatchWinnerRequest,
    MatchWinnerResponse
)
from ..services.arena_stats_service import ArenaStatsService
from ..services.arena_match_service import ArenaMatchService

# Services
arena_stats_service = ArenaStatsService()
arena_match_service = ArenaMatchService()

router = APIRouter()

@router.post("", response_model=dict[str, ArenaSessionResponse])
async def create_arena_session(
    request: CreateArenaRequest,
    db: AsyncSession = Depends(get_db)
):
    """Create a new arena session with the specified students"""
    # Verify all students exist
    result = await db.execute(
        select(Student).where(Student.id.in_(request.student_ids))
    )
    students = result.scalars().all()
    if len(students) != len(request.student_ids):
        raise HTTPException(status_code=400, detail="One or more students not found")

    # Create arena session
    arena = ArenaSession(
        status=ArenaSessionStatus.IN_PROGRESS,
        num_rounds=request.num_rounds,
        rounds_completed=0
    )
    db.add(arena)
    await db.flush()  # Get arena.id

    # Add participants
    for student_id in request.student_ids:
        participant = ArenaParticipant(
            arena_id=arena.id,
            student_id=student_id,
            fights_played=0
        )
        db.add(participant)

    await db.commit()
    await db.refresh(arena)

    # Initialize match schedule
    await arena_match_service.initialize_arena_matches(
        db,
        arena.id,
        arena.num_rounds,
        arena.participants
    )

    # Construct proper response with student stats
    participants_list = []
    for participant in arena.participants:
        student = participant.student  # Already loaded due to lazy="selectin"
        participants_list.append(
            StudentStatsResponse(
                student_id=student.id,
                name=student.name,
                elo_rating=student.elo_rating,
                wins=0,  # New arena, no wins yet
                losses=0,  # New arena, no losses yet
                fights_played=0,  # New arena, no fights yet
                elo_change=0.0  # New arena, no ELO changes yet
            )
        )

    response = ArenaSessionResponse(
        id=arena.id,
        status=arena.status,
        num_rounds=arena.num_rounds,
        rounds_completed=arena.rounds_completed,
        participants=participants_list
    )
    
    return {"data": response}

@router.get("/{arena_id}/next-match", response_model=dict[str, MatchResponse])
async def get_next_match(
    arena_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get or create the next match in the arena session"""
    # Get arena session
    arena = await db.get(ArenaSession, arena_id)
    if not arena:
        raise HTTPException(status_code=404, detail="Arena session not found")
    if arena.status != ArenaSessionStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Arena session is not in progress")
    if arena.rounds_completed >= arena.num_rounds:
        raise HTTPException(status_code=400, detail="All rounds completed")

    # Get all arena participants
    result = await db.execute(
        select(ArenaParticipant, Student)
        .join(Student)
        .where(ArenaParticipant.arena_id == arena_id)
    )
    participant_students = result.all()
    if len(participant_students) < 2:
        raise HTTPException(status_code=400, detail="Not enough participants")

    try:
        match = await arena_match_service.create_next_match(
            db, arena_id, participant_students
        )
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    await db.commit()
    # Refresh match with eager loading
    result = await db.execute(
        select(Match)
        .options(selectinload(Match.participants))
        .where(Match.id == match.id)
    )
    match = result.scalar_one()
    match_response = MatchResponse.from_orm(match)
    return {"data": match_response}

@router.patch("/matches/{match_id}/winner", response_model=dict[str, MatchWinnerResponse])
async def set_match_winner(
    match_id: UUID,
    request: SetMatchWinnerRequest,
    db: AsyncSession = Depends(get_db)
):
    """Set the winner of a match and update ELO ratings"""
    # Get match with participants eager loaded
    result = await db.execute(
        select(Match)
        .options(selectinload(Match.participants))
        .where(Match.id == match_id)
    )
    match = result.scalar_one_or_none()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")

    # Get match participants
    result = await db.execute(
        select(MatchParticipant, Student)
        .join(Student, MatchParticipant.student_id == Student.id)
        .where(MatchParticipant.match_id == match_id)
    )
    participants_with_students = result.all()
    if len(participants_with_students) != 2:
        raise HTTPException(status_code=400, detail="Match must have exactly 2 participants")

    # Validate winners
    participant_dict = {p.student_id: (p, s) for p, s in participants_with_students}
    for winner_id in request.winner_ids:
        if winner_id not in participant_dict:
            raise HTTPException(status_code=400, detail="Winner must be a player in this match")

    # Get arena session
    arena = await db.get(ArenaSession, match.arena_id)
    if not arena:
        raise HTTPException(status_code=404, detail="Arena session not found")

    # Update match and participants
    await arena_match_service.set_match_winner(
        db, match, request.winner_ids, participants_with_students
    )

    # Update arena session
    arena.rounds_completed += 1
    if arena.rounds_completed >= arena.num_rounds:
        arena.status = ArenaSessionStatus.COMPLETED

    await db.commit()
    # Ensure participants are loaded before returning
    await db.refresh(match, ['participants'])
    await db.refresh(arena)

    # Get all arena participants for stats
    result = await db.execute(
        select(ArenaParticipant, Student)
        .join(Student)
        .where(ArenaParticipant.arena_id == arena.id)
    )
    arena_participant_students = result.all()

    # Calculate stats using service
    participants_list = await arena_stats_service.calculate_arena_stats(
        db, arena.id, arena_participant_students
    )

    arena_response = ArenaSessionResponse(
        id=arena.id,
        status=arena.status,
        num_rounds=arena.num_rounds,
        rounds_completed=arena.rounds_completed,
        participants=participants_list
    )

    # Convert match to MatchResponse
    match_response = MatchResponse.from_orm(match)

    return {
        "data": MatchWinnerResponse(
            match=match_response,
            arena_session=arena_response
        )
    }

@router.get("/{arena_id}/results", response_model=dict[str, dict[str, List[StudentStatsResponse]]])
async def get_arena_results(
    arena_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get final results and statistics for an arena session"""
    # Get arena session
    arena = await db.get(ArenaSession, arena_id)
    if not arena:
        raise HTTPException(status_code=404, detail="Arena session not found")

    # Get all participants with their students
    result = await db.execute(
        select(ArenaParticipant, Student)
        .join(Student, ArenaParticipant.student_id == Student.id)
        .where(ArenaParticipant.arena_id == arena_id)
    )
    participant_students = result.all()

    # Calculate stats using service
    stats = await arena_stats_service.calculate_arena_stats(
        db, arena_id, participant_students
    )
    return {"data": {"rankings": stats}}



================================================================================
File: backend\app\routers\flashcards.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import delete
from typing import List, Optional, Generic, TypeVar

T = TypeVar('T')
from pydantic import BaseModel, constr, validator
import csv
import io
from datetime import datetime
from uuid import UUID

from ..database import get_db
from ..models.flashcard import Flashcard, FlashcardPack, DifficultyLevel

router = APIRouter(tags=["flashcards"])

# Response schemas
class ApiResponse(BaseModel, Generic[T]):
    data: T

# Pack schemas
class FlashcardPackBase(BaseModel):
    name: constr(min_length=1, max_length=100)

    @validator('name')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class FlashcardPackCreate(FlashcardPackBase):
    pass

class FlashcardPackUpdate(FlashcardPackBase):
    pass

class FlashcardPackResponse(FlashcardPackBase):
    id: UUID
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class FlashcardBase(BaseModel):
    question: constr(min_length=1, max_length=1000)
    answer: constr(min_length=1, max_length=1000)
    difficulty: DifficultyLevel = DifficultyLevel.MEDIUM
    pack_id: UUID

    @validator('question', 'answer')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class FlashcardCreate(FlashcardBase):
    pass

class FlashcardUpdate(FlashcardBase):
    pass

class FlashcardResponse(FlashcardBase):
    id: UUID
    times_used: int
    times_correct: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class FlashcardBulkCreate(BaseModel):
    question: constr(min_length=1, max_length=1000)
    answer: constr(min_length=1, max_length=1000)
    difficulty: Optional[DifficultyLevel] = DifficultyLevel.MEDIUM
    pack_id: UUID

    @validator('question', 'answer')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class BulkImportResponse(BaseModel):
    total: int
    successful: int
    failed: int
    errors: List[str]

class TemplateResponse(BaseModel):
    content: str
    filename: str
    media_type: str

# Pack endpoints
@router.get("/packs", response_model=ApiResponse[List[FlashcardPackResponse]])
async def get_packs(
    db: AsyncSession = Depends(get_db)
):
    """Get all flashcard packs"""
    result = await db.execute(select(FlashcardPack))
    return {"data": result.scalars().all()}

@router.post("/packs", response_model=ApiResponse[FlashcardPackResponse], status_code=status.HTTP_201_CREATED)
async def create_pack(
    pack: FlashcardPackCreate,
    db: AsyncSession = Depends(get_db)
):
    """Create a new flashcard pack"""
    db_pack = FlashcardPack(**pack.dict())
    db.add(db_pack)
    await db.commit()
    await db.refresh(db_pack)
    return {"data": db_pack}

@router.put("/packs/{pack_id}", response_model=ApiResponse[FlashcardPackResponse])
async def update_pack(
    pack_id: UUID,
    pack_update: FlashcardPackUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update a flashcard pack"""
    result = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == pack_id)
    )
    db_pack = result.scalar_one_or_none()
    if not db_pack:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Pack not found"
        )
    
    # Update fields
    for field, value in pack_update.dict().items():
        setattr(db_pack, field, value)
    
    await db.commit()
    await db.refresh(db_pack)
    return {"data": db_pack}

@router.delete("/packs/{pack_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_pack(
    pack_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete a flashcard pack and all its flashcards"""
    result = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == pack_id)
    )
    pack = result.scalar_one_or_none()
    if not pack:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Pack not found"
        )
    
    # Delete all flashcards in the pack
    await db.execute(
        delete(Flashcard).where(Flashcard.pack_id == pack_id)
    )
    
    # Delete the pack
    await db.delete(pack)
    await db.commit()

# Template and export endpoints
@router.post("/template", response_model=ApiResponse[TemplateResponse])
async def get_csv_template():
    """Get a CSV template for bulk flashcard import"""
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(['question', 'answer', 'difficulty', 'pack_id'])
    writer.writerow(['What is 2+2?', '4', 'EASY', 'pack-uuid-here'])
    
    return {"data": {
        "content": output.getvalue(),
        "filename": "flashcard_template.csv",
        "media_type": "text/csv"
    }}

@router.get("/export/{pack_id}", response_model=ApiResponse[TemplateResponse])
async def export_flashcards(
    pack_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Export all flashcards from a pack as CSV"""
    # Verify pack exists
    pack = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == pack_id)
    )
    if not pack.scalar_one_or_none():
        raise HTTPException(status_code=404, detail="Pack not found")
    
    # Get all flashcards in pack
    result = await db.execute(
        select(Flashcard).where(Flashcard.pack_id == pack_id)
    )
    flashcards = result.scalars().all()
    
    # Create CSV
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(['question', 'answer', 'difficulty', 'pack_id', 'times_used', 'times_correct'])
    
    for card in flashcards:
        writer.writerow([
            card.question,
            card.answer,
            card.difficulty.name,
            str(card.pack_id),
            card.times_used,
            card.times_correct
        ])
    
    return {"data": {
        "content": output.getvalue(),
        "filename": f"flashcards_pack_{pack_id}.csv",
        "media_type": "text/csv"
    }}

@router.post("/bulk-import", response_model=BulkImportResponse)
async def bulk_import_flashcards(
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db)
):
    """Import multiple flashcards from a CSV file"""
    if not file.filename.endswith('.csv'):
        raise HTTPException(status_code=400, detail="File must be a CSV")
    
    content = await file.read()
    text_content = content.decode('utf-8-sig')
    csv_reader = csv.DictReader(io.StringIO(text_content))
    
    total = 0
    successful = 0
    failed = 0
    errors = []
    flashcards_to_add = []

    try:
        for row in csv_reader:
            total += 1
            try:
                # Validate row data
                flashcard_data = FlashcardBulkCreate(
                    question=row['question'],
                    answer=row['answer'],
                    difficulty=DifficultyLevel[row.get('difficulty', 'MEDIUM').upper()],
                    pack_id=UUID(row['pack_id'])
                )
                
                # Verify pack exists
                pack = await db.execute(
                    select(FlashcardPack).where(FlashcardPack.id == flashcard_data.pack_id)
                )
                if not pack.scalar_one_or_none():
                    raise ValueError(f"Pack with ID {flashcard_data.pack_id} not found")
                
                # Create flashcard model instance
                flashcard = Flashcard(
                    question=flashcard_data.question,
                    answer=flashcard_data.answer,
                    difficulty=flashcard_data.difficulty,
                    pack_id=flashcard_data.pack_id
                )
                flashcards_to_add.append(flashcard)
                successful += 1
                
            except Exception as e:
                failed += 1
                errors.append(f"Row {total}: {str(e)}")
                
        # Bulk insert valid flashcards
        if flashcards_to_add:
            db.add_all(flashcards_to_add)
            await db.commit()
            
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
        
    return {
        "total": total,
        "successful": successful,
        "failed": failed,
        "errors": errors
    }

# Basic CRUD endpoints
@router.get("/pack/{pack_id}", response_model=ApiResponse[List[FlashcardResponse]])
async def get_flashcards_by_pack(
    pack_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get all flashcards in a pack"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.pack_id == pack_id)
    )
    return {"data": result.scalars().all()}

@router.get("/all", response_model=ApiResponse[List[FlashcardResponse]])
async def get_flashcards(
    db: AsyncSession = Depends(get_db)
):
    """Get all flashcards"""
    result = await db.execute(select(Flashcard))
    return {"data": result.scalars().all()}

@router.post("/", response_model=ApiResponse[FlashcardResponse], status_code=status.HTTP_201_CREATED)
async def create_flashcard(
    flashcard: FlashcardCreate,
    db: AsyncSession = Depends(get_db)
):
    """Create a new flashcard"""
    # Verify pack exists
    pack = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == flashcard.pack_id)
    )
    if not pack.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Pack with ID {flashcard.pack_id} not found"
        )
    
    db_flashcard = Flashcard(**flashcard.dict())
    db.add(db_flashcard)
    await db.commit()
    await db.refresh(db_flashcard)
    return {"data": db_flashcard}

@router.get("/{flashcard_id}", response_model=ApiResponse[FlashcardResponse])
async def get_flashcard(
    flashcard_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get a specific flashcard by ID"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.id == flashcard_id)
    )
    flashcard = result.scalar_one_or_none()
    if not flashcard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flashcard not found"
        )
    return {"data": flashcard}

@router.put("/{flashcard_id}", response_model=ApiResponse[FlashcardResponse])
async def update_flashcard(
    flashcard_id: UUID,
    flashcard_update: FlashcardUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update a flashcard"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.id == flashcard_id)
    )
    db_flashcard = result.scalar_one_or_none()
    if not db_flashcard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flashcard not found"
        )
    
    # Update fields
    for field, value in flashcard_update.dict().items():
        setattr(db_flashcard, field, value)
    
    await db.commit()
    await db.refresh(db_flashcard)
    return {"data": db_flashcard}

@router.delete("/{flashcard_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_flashcard(
    flashcard_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete a flashcard"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.id == flashcard_id)
    )
    flashcard = result.scalar_one_or_none()
    if not flashcard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flashcard not found"
        )
    
    await db.delete(flashcard)
    await db.commit()



================================================================================
File: backend\app\routers\flashcard_stats.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Dict, Any
from uuid import UUID
from ..database import get_db
from ..services.statistics_service import StatisticsService

router = APIRouter()

@router.get("/flashcards/{flashcard_id}/stats")
async def get_flashcard_stats(
    flashcard_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> Dict[str, Any]:
    """Get comprehensive statistics for a specific flashcard"""
    try:
        stats = await StatisticsService.get_flashcard_stats(str(flashcard_id), db)
        return {"data": stats}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

@router.get("/flashcards/most-used")
async def get_most_used_flashcards(
    limit: int = 10,
    db: AsyncSession = Depends(get_db)
) -> Dict[str, List[Dict[str, Any]]]:
    """Get flashcards sorted by usage frequency"""
    stats = await StatisticsService.get_most_used_flashcards(db, limit)
    return {"data": stats}

@router.get("/arena/{arena_id}/flashcard-stats")
async def get_arena_flashcard_stats(
    arena_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> Dict[str, List[Dict[str, Any]]]:
    """Get statistics for all flashcards used in a specific arena session"""
    try:
        stats = await StatisticsService.get_arena_flashcard_stats(str(arena_id), db)
        return {"data": stats}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))



================================================================================
File: backend\app\routers\matches.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import List, Optional, Dict
from uuid import UUID
from pydantic import BaseModel, conlist
from ..models.match import Match, Round, MatchStatus, MatchParticipant, RoundParticipant

# Response models
class ParticipantResponse(BaseModel):
    student_id: UUID
    elo_before: Optional[float]
    elo_after: Optional[float]

    class Config:
        from_attributes = True

class MatchResponse(BaseModel):
    id: UUID
    status: MatchStatus
    num_rounds: int
    rounds_completed: int
    winner_id: Optional[UUID]
    participants: List[ParticipantResponse]

    class Config:
        from_attributes = True

class RoundParticipantResponse(BaseModel):
    student_id: UUID
    elo_before: Optional[float]
    elo_change: Optional[float]
    answer: Optional[str]

    class Config:
        from_attributes = True

class RoundResponse(BaseModel):
    id: UUID
    match_id: UUID
    flashcard_id: UUID
    winner_id: Optional[UUID]
    round_number: int
    participants: List[RoundParticipantResponse]

    class Config:
        from_attributes = True

from ..database import get_db
from ..models.student import Student
from ..services.matchmaking_service import MatchmakingService
from ..services.elo_service import EloService
from ..services import achievement_service

class CreateMultiplayerMatchRequest(BaseModel):
    player_ids: conlist(UUID, min_length=2)  # At least 2 players required
    num_rounds: int

class AutoMatchRequest(BaseModel):
    num_players: int
    num_rounds: int
    student_id: UUID  # The requesting player

class CreateRoundRequest(BaseModel):
    match_id: UUID
    flashcard_id: UUID

class SubmitAnswerRequest(BaseModel):
    player_id: UUID
    answer: str

class SetRoundWinnerRequest(BaseModel):
    winner_ids: List[UUID]  # Support multiple winners

class UpdateStatusRequest(BaseModel):
    status: str  # Use str instead of MatchStatus enum for request validation
    winner_id: Optional[UUID] = None

    def get_status(self) -> MatchStatus:
        """Convert string status to MatchStatus enum"""
        try:
            return MatchStatus[self.status.upper()]
        except KeyError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid status. Must be one of: {', '.join(s.value for s in MatchStatus)}"
            )

router = APIRouter()
matchmaking_service = MatchmakingService()
elo_service = EloService()

@router.get("")
async def get_matches(db: AsyncSession = Depends(get_db)):
    """Get all matches"""
    result = await db.execute(select(Match))
    matches = result.scalars().all()
    return {"data": matches}

@router.get("/{match_id}", response_model=dict[str, MatchResponse])
async def get_match(match_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get match by ID"""
    match = await db.get(Match, match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    return {"data": match}

@router.post("/multiplayer")
async def create_multiplayer_match(
    request: CreateMultiplayerMatchRequest,
    db: AsyncSession = Depends(get_db)
):
    """Create a new match with multiple players"""
    try:
        match = await matchmaking_service.create_multiplayer_match(
            [str(pid) for pid in request.player_ids],
            request.num_rounds,
            db
        )
        return {"data": match}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/auto-match")
async def auto_create_match(
    request: AutoMatchRequest,
    db: AsyncSession = Depends(get_db)
):
    """Automatically create a match with similarly rated players"""
    try:
        match = await matchmaking_service.auto_find_players_and_create_match(
            request.num_players,
            request.num_rounds,
            str(request.student_id),
            db
        )
        return {"data": match}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/find")
async def find_or_create_match(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Find an existing match or create a new one with a suitable opponent"""
    try:
        match, created = await matchmaking_service.find_or_create_match(str(student_id), db)
        return {
            "data": match,
            "created": created
        }
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.patch("/{match_id}/status")
async def update_match_status(
    match_id: UUID,
    request: UpdateStatusRequest,
    db: AsyncSession = Depends(get_db)
):
    """Update match status and handle ELO updates if completed"""
    match = await db.get(Match, match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    new_status = request.get_status()
    
    # Handle transition to IN_PROGRESS
    if new_status == MatchStatus.IN_PROGRESS:
        if match.status == MatchStatus.COMPLETED:
            raise HTTPException(status_code=400, detail="Cannot restart a completed match")
        match.status = MatchStatus.IN_PROGRESS
    
    # Handle transition to COMPLETED
    elif new_status == MatchStatus.COMPLETED:
        if not request.winner_id:
            raise HTTPException(status_code=400, detail="Winner ID required to complete match")
        
        # Validate winner is part of the match
        if request.winner_id not in [match.player1_id, match.player2_id]:
            raise HTTPException(status_code=400, detail="Winner must be a player in this match")
        
        # Get players to update their stats
        player1 = await db.get(Student, match.player1_id)
        player2 = await db.get(Student, match.player2_id)
        
        # Determine winner and loser
        winner = player1 if request.winner_id == player1.id else player2
        loser = player2 if request.winner_id == player1.id else player1
        
        # Update match status and winner
        match.status = MatchStatus.COMPLETED
        match.winner_id = request.winner_id
        
        # Calculate total ELO changes from rounds
        result = await db.execute(
            select(Round).where(Round.match_id == match_id)
        )
        rounds = result.scalars().all()
        
        total_p1_change = sum(round.player1_elo_change or 0 for round in rounds)
        total_p2_change = sum(round.player2_elo_change or 0 for round in rounds)
        
        # Store total changes in match
        match.player1_elo_change = total_p1_change
        match.player2_elo_change = total_p2_change
        
        # Update match stats
        winner.wins += 1
        winner.total_matches += 1
        loser.losses += 1
        loser.total_matches += 1

        # Get all matches for achievement evaluation
        result = await db.execute(
            select(Match).where(
                (Match.player1_id == winner.id) | (Match.player2_id == winner.id)
            )
        )
        winner_matches = result.scalars().all()
        
        result = await db.execute(
            select(Match).where(
                (Match.player1_id == loser.id) | (Match.player2_id == loser.id)
            )
        )
        loser_matches = result.scalars().all()

        print(f"[Match Debug] Evaluating achievements for winner {winner.id} (ELO: {winner.elo_rating})")
        winner_achievements = await achievement_service.evaluate_student_achievements(winner, winner_matches, db)
        if winner_achievements:
            print(f"[Match Debug] Winner earned {len(winner_achievements)} new achievements")
        
        print(f"[Match Debug] Evaluating achievements for loser {loser.id} (ELO: {loser.elo_rating})")
        loser_achievements = await achievement_service.evaluate_student_achievements(loser, loser_matches, db)
        if loser_achievements:
            print(f"[Match Debug] Loser earned {len(loser_achievements)} new achievements")
    
    # Handle other status changes
    else:
        match.status = new_status
    
    await db.commit()
    await db.refresh(match)
    return {"data": match}

@router.get("/{match_id}/rounds", response_model=dict[str, List[RoundResponse]])
async def get_match_rounds(match_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get all rounds for a match"""
    result = await db.execute(
        select(Round).where(Round.match_id == match_id)
    )
    rounds = result.scalars().all()
    return {"data": rounds}

@router.post("/rounds")
async def create_round(
    request: CreateRoundRequest,
    db: AsyncSession = Depends(get_db)
):
    """Create a new round for a match"""
    # Verify match exists and is in progress
    match = await db.get(Match, request.match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")
    
    # Get the current round number
    result = await db.execute(
        select(Round).where(Round.match_id == request.match_id).order_by(Round.round_number.desc())
    )
    existing_rounds = result.scalars().all()
    round_number = str(len(existing_rounds) + 1) if existing_rounds else "1"
    
    # Create round
    round = Round(
        match_id=request.match_id,
        flashcard_id=request.flashcard_id,
        round_number=round_number,
        winner_id=None,
        player1_answer=None,
        player2_answer=None
    )
    
    db.add(round)
    await db.commit()
    await db.refresh(round)
    
    return {"data": round}

@router.get("/rounds/{round_id}")
async def get_round(round_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get round by ID"""
    round = await db.get(Round, round_id)
    if not round:
        raise HTTPException(status_code=404, detail="Round not found")
    return {"data": round}

@router.post("/rounds/{round_id}/answer")
async def submit_round_answer(
    round_id: UUID,
    request: SubmitAnswerRequest,
    db: AsyncSession = Depends(get_db)
):
    """Submit an answer for a round"""
    round = await db.get(Round, round_id)
    if not round:
        raise HTTPException(status_code=404, detail="Round not found")
    
    match = await db.get(Match, round.match_id)
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")
    
    # Update player's answer
    if request.player_id == match.player1_id:
        round.player1_answer = request.answer
    elif request.player_id == match.player2_id:
        round.player2_answer = request.answer
    else:
        raise HTTPException(status_code=400, detail="Player is not part of this match")
    
    await db.commit()
    await db.refresh(round)
    
    return {"data": round}

@router.post("/rounds/{round_id}/winner")
async def set_round_winner(
    round_id: UUID,
    request: SetRoundWinnerRequest,
    db: AsyncSession = Depends(get_db)
):
    """Set winners for a round and update ELO ratings"""
    round = await db.get(Round, round_id)
    if not round:
        raise HTTPException(status_code=404, detail="Round not found")
    
    match = await db.get(Match, round.match_id)
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")
    
    # Get all participants
    result = await db.execute(
        select(RoundParticipant).where(RoundParticipant.round_id == round_id)
    )
    participants = result.scalars().all()
    participant_dict = {p.student_id: p for p in participants}
    
    # Validate winners are part of the round
    for winner_id in request.winner_ids:
        if winner_id not in participant_dict:
            raise HTTPException(status_code=400, detail=f"Winner {winner_id} is not part of this round")
    
    # Get all students
    student_ids = [p.student_id for p in participants]
    result = await db.execute(
        select(Student).where(Student.id.in_(student_ids))
    )
    students = {s.id: s for s in result.scalars().all()}
    
    # For each winner, calculate ELO changes against each non-winner
    winners = [participant_dict[wid] for wid in request.winner_ids]
    losers = [p for p in participants if p.student_id not in request.winner_ids]
    
    # Calculate and apply ELO changes
    for winner in winners:
        winner.elo_change = 0
        winner_student = students[winner.student_id]
        
        for loser in losers:
            loser_student = students[loser.student_id]
            winner_change, loser_change = elo_service.calculate_rating_changes(
                winner_student.elo_rating,
                loser_student.elo_rating
            )
            
            # Accumulate changes
            winner.elo_change += winner_change
            loser.elo_change = (loser.elo_change or 0) + loser_change
    
    # Apply changes to student ratings
    for p in participants:
        if p.elo_change:  # Only update if there was a change
            students[p.student_id].elo_rating += p.elo_change
    
    # Update round
    if len(request.winner_ids) == 1:
        round.winner_id = request.winner_ids[0]
    
    # Update match rounds completed
    match.rounds_completed += 1
    if match.rounds_completed >= match.num_rounds:
        match.status = MatchStatus.COMPLETED
        # Optionally set match winner based on most rounds won
        winner_counts = {}
        for r in match.rounds:
            if r.winner_id:
                winner_counts[r.winner_id] = winner_counts.get(r.winner_id, 0) + 1
        if winner_counts:
            match.winner_id = max(winner_counts.items(), key=lambda x: x[1])[0]
            
            # Get players to evaluate achievements
            winner = await db.get(Student, match.winner_id)
            loser_id = next(id for id in students.keys() if id != match.winner_id)
            loser = students[loser_id]
            
            # Remove duplicate achievement evaluation since we already do it in update_match_status
    
    await db.commit()
    await db.refresh(round)
    
    return {"data": round}



================================================================================
File: backend\app\routers\students.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from typing import List, Generic, TypeVar, Literal
from pydantic import BaseModel, constr, validator, ConfigDict
from datetime import datetime
from uuid import UUID

from ..database import get_db
from ..models.student import Student
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.flashcard import Flashcard
from ..models.achievement import Achievement
from ..services import achievement_service
from ..schemas.achievement import StudentAchievementResponse

T = TypeVar('T')

class DataResponse(BaseModel, Generic[T]):
    data: T
    model_config = ConfigDict(from_attributes=True)

class MatchHistoryItem(BaseModel):
    match_id: UUID
    date: datetime
    opponent_name: str
    old_elo: float
    new_elo: float
    elo_change: float
    result: Literal["win", "loss"]

    model_config = ConfigDict(from_attributes=True)

router = APIRouter(tags=["students"])

class StudentBase(BaseModel):
    name: constr(min_length=1, max_length=100)

    @validator('name')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class StudentCreate(StudentBase):
    avatar_url: str | None = None  # NEW FIELD

class StudentUpdate(StudentBase):
    avatar_url: str | None = None  # NEW FIELD

class StudentResponse(StudentBase):
    id: UUID
    avatar_url: str | None = None
    elo_rating: float
    total_matches: int
    wins: int
    losses: int
    created_at: datetime
    updated_at: datetime
    win_rate: float

    class Config:
        from_attributes = True

    @validator('win_rate', pre=True, always=True)
    def calculate_win_rate(cls, v, values):
        """
        If your Student model calculates win_rate as a fraction (e.g. 0.75),
        you might want to convert to a percentage. Adjust as needed.
        """
        if hasattr(v, '__call__'):
            return 0.0
        # Or if your model already stores it as a percentage, just return v.
        # In some code, the Student model uses `win_rate = (wins / total_matches) * 100`.
        return v / 100 if v is not None else 0.0

@router.post("", response_model=DataResponse[StudentResponse], status_code=status.HTTP_201_CREATED)
async def create_student(
    student: StudentCreate,
    db: AsyncSession = Depends(get_db)
):
    """Create a new student"""
    db_student = Student(**student.dict())
    db.add(db_student)
    await db.commit()

    result = await db.execute(
        select(Student).where(Student.id == db_student.id)
    )
    created_student = result.scalar_one()
    return {"data": created_student}

@router.get("", response_model=DataResponse[List[StudentResponse]])
async def get_students(
    db: AsyncSession = Depends(get_db)
):
    """Get all students"""
    result = await db.execute(select(Student))
    return {"data": result.scalars().all()}

@router.get("/{student_id}", response_model=DataResponse[StudentResponse])
async def get_student(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get a specific student by ID"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    return {"data": student}

@router.put("/{student_id}", response_model=DataResponse[StudentResponse])
async def update_student(
    student_id: UUID,
    student_update: StudentUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update a student"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    db_student = result.scalar_one_or_none()
    if not db_student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )

    for field, value in student_update.dict().items():
        setattr(db_student, field, value)

    await db.commit()
    await db.refresh(db_student)
    return {"data": db_student}

@router.delete("/{student_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_student(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete a student"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )

    await db.delete(student)
    await db.commit()

@router.get("/{student_id}/achievements", response_model=List[StudentAchievementResponse])
async def get_student_achievements(student_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get all achievements earned by a specific student."""
    # Verify student exists
    student = await db.get(Student, student_id)
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    
    # Get student achievements
    student_achievements = await achievement_service.get_student_achievements(student_id, db)
    
    # Load the full achievement data for each student achievement
    result = []
    for sa in student_achievements:
        achievement = await db.get(Achievement, sa.achievement_id)
        if achievement:
            result.append({
                "id": sa.id,
                "student_id": sa.student_id,
                "achievement": achievement,
                "achieved_at": sa.achieved_at
            })
    
    return result

@router.post("/{student_id}/evaluate-achievements")
async def evaluate_student_achievements(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Evaluate achievements for a student based on their match history"""
    # Get student
    student = await db.get(Student, student_id)
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )

    # Get all matches for this student
    result = await db.execute(
        select(Match).where(
            (Match.player1_id == student_id) | (Match.player2_id == student_id)
        )
    )
    matches = result.scalars().all()

    print(f"[Achievement Debug] Evaluating achievements for existing student {student_id}")
    print(f"[Achievement Debug] Found {len(matches)} matches to evaluate")
    
    # Evaluate achievements
    newly_earned = await achievement_service.evaluate_student_achievements(student, matches, db)
    
    return {
        "data": {
            "evaluated_matches": len(matches),
            "new_achievements": len(newly_earned),
            "achievement_codes": [a.code for a in newly_earned]
        }
    }

@router.get("/{student_id}/stats", response_model=DataResponse[StudentResponse])
async def get_student_stats(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get a student's updated stats"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    return {"data": student}

@router.post("/{student_id}/reset", response_model=DataResponse[StudentResponse])
async def reset_student_stats(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Reset the specified student's statistics to default values,
    and remove all match history (match_participants, round_participants).
    """
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )

    # 1) Remove match history
    #    Remove all RoundParticipants and MatchParticipants rows for this student
    from sqlalchemy import text
    await db.execute(
        text("DELETE FROM round_participants WHERE student_id = :sid"),
        {"sid": str(student_id)}
    )
    await db.execute(
        text("DELETE FROM match_participants WHERE student_id = :sid"),
        {"sid": str(student_id)}
    )

    # 2) Reset fields to default values
    student.elo_rating = 1000.0
    student.wins = 0
    student.losses = 0
    student.total_matches = 0

    await db.commit()
    await db.refresh(student)

    return {"data": student}

@router.get("/{student_id}/history", response_model=DataResponse[List[MatchHistoryItem]])
async def get_student_history(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Return match history for a student, including ELO changes and results,
    adapting to the new participant-based match schema.
    """
    # 1) Verify student exists
    student = await db.get(Student, student_id)
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")

    # 2) Query all matches in which this student participated
    stmt = (
        select(Match)
        .join(MatchParticipant, Match.id == MatchParticipant.match_id)
        .options(
            # preload the participants -> student relationship
            selectinload(Match.participants).selectinload(MatchParticipant.student)
        )
        .where(MatchParticipant.student_id == student_id)
        .order_by(Match.created_at.desc())
    )
    results = await db.execute(stmt)
    matches = results.scalars().all()

    history_items: List[MatchHistoryItem] = []

    for match in matches:
        # find the participant object for this student
        user_participant = None
        # for a 1v1 match, there's typically exactly 1 "opponent", but for multi-player, there may be multiple
        opponents = []
        for p in match.participants:
            if p.student_id == student_id:
                user_participant = p
            else:
                opponents.append(p)

        if not user_participant:
            # Should not happen if query is correct, but skip if something's off
            continue

        old_elo = user_participant.elo_before or 0.0
        new_elo = user_participant.elo_after or old_elo
        elo_change = new_elo - old_elo

        # Only show completed matches with winners
        if match.status != MatchStatus.COMPLETED or not match.winner_ids or len(match.winner_ids) == 0:
            continue
            
        # Determine win/loss
        result_str = "win" if user_participant.student_id in match.winner_ids else "loss"

        # For "opponent_name", pick the first opponent if any
        opponent_name = "Unknown"
        if len(opponents) > 0 and opponents[0].student:
            opponent_name = opponents[0].student.name

        history_items.append(
            MatchHistoryItem(
                match_id=match.id,
                date=match.created_at,
                opponent_name=opponent_name,
                old_elo=old_elo,
                new_elo=new_elo,
                elo_change=elo_change,
                result=result_str
            )
        )

    return {"data": history_items}



================================================================================
File: backend\app\schemas\achievement.py
================================================================================

from pydantic import BaseModel
from uuid import UUID
from datetime import datetime

class AchievementBase(BaseModel):
    code: str
    title: str
    description: str | None = None
    criteria: dict | None = None

class AchievementResponse(AchievementBase):
    id: UUID
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True


class StudentAchievementResponse(BaseModel):
    id: UUID
    student_id: UUID
    achievement: AchievementResponse
    achieved_at: datetime

    class Config:
        orm_mode = True



================================================================================
File: backend\app\services\achievement_service.py
================================================================================

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from app.models.achievement import Achievement, StudentAchievement
from app.models.student import Student
from app.models.match import Match
from datetime import datetime
from typing import Callable, Dict, List, Any
from sqlalchemy import desc

# Type alias for evaluator functions
AchievementEvaluator = Callable[[Student, List[Match]], bool]

# Example evaluator functions:
def evaluator_elo_1000(student: Student, matches: List[Match]) -> bool:
    print(f"[Achievement Debug] Evaluating elo-1000 for student {student.id}")
    print(f"[Achievement Debug] Current ELO: {student.elo_rating}")
    result = student.elo_rating >= 1000
    print(f"[Achievement Debug] Result: {result}")
    return result

def evaluator_elo_1100(student: Student, matches: List[Match]) -> bool:
    print(f"[Achievement Debug] Evaluating elo-1100 for student {student.id}")
    print(f"[Achievement Debug] Current ELO: {student.elo_rating}")
    result = student.elo_rating >= 1100
    print(f"[Achievement Debug] Result: {result}")
    return result

def evaluator_streak_3_win(student: Student, matches: List[Match]) -> bool:
    print(f"[Achievement Debug] Evaluating streak-3-win for student {student.id}")
    streak = 0
    # Sort matches by date descending to check recent matches
    sorted_matches = sorted(matches, key=lambda m: m.created_at, reverse=True)
    
    for match in sorted_matches:
        # Check if student is the winner (using winner_id)
        if match.winner_id == student.id:
            streak += 1
            print(f"[Achievement Debug] Win found, current streak: {streak}")
            if streak >= 3:
                print("[Achievement Debug] 3-win streak achieved!")
                return True
        else:
            print(f"[Achievement Debug] Streak broken at {streak}")
            streak = 0
    print(f"[Achievement Debug] Final streak: {streak}, achievement not earned")
    return False

def evaluator_streak_4_win(student: Student, matches: List[Match]) -> bool:
    print(f"[Achievement Debug] Evaluating streak-4-win for student {student.id}")
    streak = 0
    sorted_matches = sorted(matches, key=lambda m: m.created_at, reverse=True)
    
    for match in sorted_matches:
        # Check if student is the winner (using winner_id)
        if match.winner_id == student.id:
            streak += 1
            print(f"[Achievement Debug] Win found, current streak: {streak}")
            if streak >= 4:
                print("[Achievement Debug] 4-win streak achieved!")
                return True
        else:
            print(f"[Achievement Debug] Streak broken at {streak}")
            streak = 0
    print(f"[Achievement Debug] Final streak: {streak}, achievement not earned")
    return False

# Map achievement codes to evaluator functions
achievement_evaluators: Dict[str, AchievementEvaluator] = {
    "elo-1000": evaluator_elo_1000,
    "elo-1100": evaluator_elo_1100,
    "streak-3-win": evaluator_streak_3_win,
    "streak-4-win": evaluator_streak_4_win,
}

async def evaluate_student_achievements(student: Student, matches: List[Match], db: AsyncSession) -> List[Achievement]:
    """
    For a given student and their match history, evaluate all achievements.
    If the student qualifies for an achievement that they have not yet earned,
    record it in the student_achievements table.
    """
    print(f"[Achievement Debug] Starting achievement evaluation for student {student.id}")
    print(f"[Achievement Debug] Current ELO: {student.elo_rating}")
    print(f"[Achievement Debug] Number of matches to evaluate: {len(matches)}")
    
    # Load all achievements from the database
    result = await db.execute(select(Achievement))
    achievements = result.scalars().all()
    
    newly_earned = []

    for achievement in achievements:
        print(f"[Achievement Debug] Checking achievement: {achievement.code}")
        
        # Check if the student already has this achievement
        exists_result = await db.execute(
            select(StudentAchievement).where(
                StudentAchievement.student_id == student.id,
                StudentAchievement.achievement_id == achievement.id
            )
        )
        already_earned = exists_result.scalars().first() is not None
        if already_earned:
            print(f"[Achievement Debug] Achievement {achievement.code} already earned")
            continue

        # If there is an evaluator for this achievement code, run it
        evaluator = achievement_evaluators.get(achievement.code)
        if evaluator:
            print(f"[Achievement Debug] Running evaluator for {achievement.code}")
            if evaluator(student, matches):
                print(f"[Achievement Debug] Achievement {achievement.code} earned!")
                new_record = StudentAchievement(
                    student_id=student.id,
                    achievement_id=achievement.id,
                    achieved_at=datetime.utcnow()
                )
                db.add(new_record)
                newly_earned.append(achievement)
        else:
            print(f"[Achievement Debug] No evaluator found for {achievement.code}")
    
    if newly_earned:
        print(f"[Achievement Debug] Committing {len(newly_earned)} new achievements")
        await db.commit()
    else:
        print("[Achievement Debug] No new achievements earned")
    
    return newly_earned

async def get_student_achievements(student_id: str, db: AsyncSession) -> List[StudentAchievement]:
    """Get all achievements earned by a student."""
    result = await db.execute(
        select(StudentAchievement)
        .where(StudentAchievement.student_id == student_id)
        .order_by(desc(StudentAchievement.achieved_at))
    )
    return result.scalars().all()

async def get_all_achievements(db: AsyncSession) -> List[Achievement]:
    """Get all available achievements."""
    result = await db.execute(select(Achievement))
    return result.scalars().all()



================================================================================
File: backend\app\services\arena_match_service.py
================================================================================

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from typing import List, Optional, Tuple
from uuid import UUID
import uuid

from ..models.arena_session import ArenaSession, ArenaSessionStatus, ArenaParticipant
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.student import Student
from ..models.arena_schemas import MatchResponse
from .elo_service import EloService
from .matchmaking_service import MatchmakingService

class ArenaMatchService:
    def __init__(self):
        self.elo_service = EloService()
        self.matchmaking_service = MatchmakingService(
            k_factor=32,
            elo_tolerance=300
        )

    async def initialize_arena_matches(
        self,
        db: AsyncSession,
        arena_id: UUID,
        num_rounds: int,
        participants: List[ArenaParticipant]
    ) -> None:
        """
        Initialize all matches for an arena session upfront.
        This ensures fair distribution of matches and better ELO-based pairing.
        """
        total_matches = (len(participants) // 2) * num_rounds
        await self.matchmaking_service.find_or_create_match_schedule(
            db,
            str(arena_id),
            participants,
            total_matches
        )

    async def create_next_match(
        self,
        db: AsyncSession,
        arena_id: UUID,
        participant_students: List[Tuple[ArenaParticipant, Student]]
    ) -> Match:
        """Get the next pending match from the pre-generated schedule"""
        # Find next pending match for this arena
        query = (
            select(Match)
            .options(selectinload(Match.participants))
            .where(
                Match.arena_id == str(arena_id),
                Match.status == MatchStatus.PENDING
            )
            .order_by(Match.created_at)
            .limit(1)
        )
        result = await db.execute(query)
        match = result.scalar_one_or_none()

        if not match:
            # If no pre-generated matches exist, fall back to on-demand matching
            # This maintains backwards compatibility and handles edge cases
            if len(participant_students) < 2:
                raise ValueError("Not enough participants")

            # Find the participant with least fights to be the initiator
            participant_students.sort(key=lambda ps: ps[0].fights_played)
            initiator_participant, initiator_student = participant_students[0]
            
            # Get potential opponents
            potential_opponents = []
            for participant, student in participant_students[1:]:
                potential_opponents.append(student)
            
            # Use matchmaking service to find best opponent
            opponents = await self.matchmaking_service.find_opponents(
                initiator_student, 2, db, potential_opponents
            )
            if not opponents:
                raise ValueError("No suitable opponents found")
                
            # Find the opponent's participant record
            opponent_student = opponents[0]
            opponent_participant = next(
                participant for participant, student in participant_students[1:]
                if str(student.id) == str(opponent_student.id)
            )

            # Create match
            match = Match(
                arena_id=str(arena_id),
                status=MatchStatus.IN_PROGRESS,
                num_rounds=1
            )
            db.add(match)
            await db.flush()

            # Create participants
            mp1 = MatchParticipant(
                match_id=match.id,
                student_id=initiator_student.id,
                elo_before=initiator_student.elo_rating
            )
            mp2 = MatchParticipant(
                match_id=match.id,
                student_id=opponent_student.id,
                elo_before=opponent_student.elo_rating
            )
            db.add_all([mp1, mp2])

            # Increment fights_played
            initiator_participant.fights_played += 1
            opponent_participant.fights_played += 1
        else:
            # Found a pre-generated match, mark it as in progress
            match.status = MatchStatus.IN_PROGRESS
            
            # Update fights_played for the participants
            for mp in match.participants:
                participant = next(
                    p for p, _ in participant_students 
                    if str(p.student_id) == str(mp.student_id)
                )
                participant.fights_played += 1

        return match

    async def set_match_winner(
        self,
        db: AsyncSession,
        match: Match,
        winner_ids: List[UUID],
        participants_with_students: List[Tuple[MatchParticipant, Student]]
    ) -> None:
        """Set the winner of a match and update ELO ratings"""
        # If no winners (UNKNOWN result), just mark as completed without affecting stats
        if not winner_ids:
            match.status = MatchStatus.COMPLETED
            match.winner_ids = []
            return

        # Convert winner IDs to UUID objects and store on match
        match.winner_ids = [uuid.UUID(str(winner_id)) for winner_id in winner_ids]

        # Update all participants
        for participant, student in participants_with_students:
            is_winner = student.id in winner_ids
            elo_change = 0
            
            # Calculate ELO changes against each opponent
            for other_participant, other_student in participants_with_students:
                if other_participant.student_id != participant.student_id:
                    if is_winner:
                        winner_change, _ = self.elo_service.calculate_rating_changes(
                            student.elo_rating,
                            other_student.elo_rating
                        )
                        elo_change += winner_change
                    else:
                        _, loser_change = self.elo_service.calculate_rating_changes(
                            other_student.elo_rating,
                            student.elo_rating
                        )
                        elo_change += loser_change

            # Update participant and student stats
            participant.elo_after = participant.elo_before + elo_change
            student.update_stats(
                won=is_winner,
                new_elo=student.elo_rating + elo_change
            )

        # Update match status
        match.status = MatchStatus.COMPLETED



================================================================================
File: backend\app\services\arena_stats_service.py
================================================================================

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.arena_session import ArenaParticipant
from ..models.student import Student
from ..models.arena_schemas import StudentStatsResponse
from typing import List, Tuple
from uuid import UUID

class ArenaStatsService:
    @staticmethod
    async def calculate_participant_stats(
        db: AsyncSession,
        arena_id: UUID,
        participant: ArenaParticipant,
        student: Student
    ) -> StudentStatsResponse:
        """Calculate stats for a single participant in an arena session"""
        # Get matches where student participated
        result = await db.execute(
            select(Match, MatchParticipant)
            .join(MatchParticipant)
            .where(
                (Match.arena_id == arena_id) &
                (MatchParticipant.student_id == student.id) &
                (Match.status == MatchStatus.COMPLETED)
            )
        )
        matches = result.all()
        
        # Calculate wins, losses and elo change
        wins = 0
        losses = 0
        elo_change = 0
        for match, match_participant in matches:
            if match.status == MatchStatus.COMPLETED:
                elo_change += (match_participant.elo_after or 0) - match_participant.elo_before
                # Count match-level wins/losses
                # Only count wins/losses if there was a winner (not UNKNOWN)
                if match.winner_ids:
                    if match_participant.student_id in match.winner_ids:
                        wins += 1
                    else:
                        losses += 1

        return StudentStatsResponse(
            student_id=student.id,
            name=student.name,
            elo_rating=student.elo_rating,
            wins=wins,
            losses=losses,
            fights_played=participant.fights_played,
            elo_change=elo_change
        )

    @staticmethod
    async def calculate_arena_stats(
        db: AsyncSession,
        arena_id: UUID,
        participant_students: List[Tuple[ArenaParticipant, Student]]
    ) -> List[StudentStatsResponse]:
        """Calculate stats for all participants in an arena session"""
        stats = []
        for participant, student in participant_students:
            stat = await ArenaStatsService.calculate_participant_stats(
                db, arena_id, participant, student
            )
            stats.append(stat)
        
        # Sort by ELO rating descending
        stats.sort(key=lambda x: x.elo_rating, reverse=True)
        return stats



================================================================================
File: backend\app\services\elo_service.py
================================================================================

from typing import Tuple

class EloService:
    def __init__(self, k_factor: int = 32):
        """
        Initialize ELO service with a k-factor.
        This k_factor (default=32) is typical in standard chess ELO for players
        under a certain rating threshold, though some leagues use a dynamic K.
        """
        self.k_factor = k_factor

    def calculate_expected_score(self, rating_a: float, rating_b: float) -> float:
        """
        Standard ELO expected score formula:
          E(A) = 1 / (1 + 10^((rating_B - rating_A) / 400))
        """
        return 1 / (1 + 10 ** ((rating_b - rating_a) / 400))

    def calculate_new_ratings(
        self, rating_winner: float, rating_loser: float
    ) -> Tuple[int, int]:
        """
        Given the winner's and loser's current ratings, return their new ratings
        after a single game, rounded to the nearest whole number.
        """
        # Calculate expected scores
        expected_winner = self.calculate_expected_score(rating_winner, rating_loser)
        expected_loser = 1.0 - expected_winner  # same as calculate_expected_score(rating_loser, rating_winner)

        # Update ratings
        new_winner_rating = rating_winner + self.k_factor * (1 - expected_winner)
        new_loser_rating = rating_loser + self.k_factor * (0 - expected_loser)

        # Round to nearest integer
        new_winner_rating = round(new_winner_rating)
        new_loser_rating = round(new_loser_rating)

        # Optional minimum rating clamp
        new_winner_rating = max(100, new_winner_rating)
        new_loser_rating = max(100, new_loser_rating)

        return new_winner_rating, new_loser_rating

    def calculate_rating_changes(
        self, rating_winner: float, rating_loser: float
    ) -> Tuple[int, int]:
        """
        Returns (winner_change, loser_change) as integers.
        """
        new_winner_rating, new_loser_rating = self.calculate_new_ratings(
            rating_winner, rating_loser
        )
        winner_change = new_winner_rating - rating_winner
        loser_change = new_loser_rating - rating_loser
        return int(winner_change), int(loser_change)



================================================================================
File: backend\app\services\matchmaking_service.py
================================================================================

# backend/app/services/matchmaking_service.py

from typing import List, Optional, Tuple, Dict
from sqlalchemy import select, and_, or_, func
from sqlalchemy.ext.asyncio import AsyncSession
import random
import math
from datetime import datetime, timedelta, timezone

from ..models.student import Student
from ..models.match import Match, MatchParticipant, MatchStatus
from ..models.arena_session import ArenaParticipant
from .elo_service import EloService


class MatchmakingService:
    """
    A robust matchmaking service that:
      1) Ensures each participant gets a roughly equal number of matches
      2) Prefers matching players with similar ELO ratings (plus some randomness)
      3) Avoids re-matching the same pair unless absolutely necessary
      4) Supports a round-based approach so that everyone is assigned consistently
    """

    def __init__(
        self,
        k_factor: int = 32,
        elo_tolerance: int = 300,
        random_seed: Optional[int] = None
    ):
        """
        Initialize matchmaking service
        :param k_factor: ELO k-factor used in rating calculations
        :param elo_tolerance: ELO difference in which we treat players as "close"
        :param random_seed: Optional seed for reproducible results in testing
        """
        self.elo_service = EloService(k_factor)
        self.elo_tolerance = elo_tolerance
        if random_seed is not None:
            random.seed(random_seed)

    async def find_or_create_match_schedule(
        self,
        db: AsyncSession,
        arena_id: str,
        participants: List[ArenaParticipant],
        total_matches: int,
    ) -> None:
        """
        Generate and store a complete match schedule for the arena.
        total_matches = (len(participants)//2) * num_rounds, typically.
        """
        # Step 1: Generate matchups round-by-round
        matchups = await self.generate_match_schedule(db, arena_id, participants, total_matches)

        # Step 2: Store them in the DB
        await self.store_generated_matches(db, arena_id, matchups)

    async def generate_match_schedule(
        self,
        db: AsyncSession,
        arena_id: str,
        participants: List[ArenaParticipant],
        total_matches: int,
    ) -> List[Tuple[str, str]]:
        """
        Generates a schedule of matchups using a **round-based** approach, ensuring:
          - Each participant gets ~the same number of matches
          - We prefer pairing players with similar ELO
          - We avoid reusing pairs if possible
        """

        # Gather participant info including ELO ratings
        p_info = []
        for ap in participants:
            student = ap.student
            p_info.append({
                "student_id": str(student.id),
                "elo": student.elo_rating,
                "fights_played": ap.fights_played,  # how many they've already done
                "remaining": 0,  # we'll fill this in below
            })

        n = len(p_info)
        if n < 2:
            return []  # can't form matches

        # Calculate how many "slots" total we have for matches (2 participants per match)
        total_slots = total_matches * 2
        # Distribute matches as evenly as possible among participants
        base_needed = total_slots // n  # e.g. if total_slots=60, n=14 => base_needed=4
        remainder = total_slots % n     # leftover

        for idx in range(n):
            p_info[idx]["remaining"] = base_needed + (1 if idx < remainder else 0)

        # We aim to build up to total_matches in a round-based manner
        # Each round we form at most floor(n/2) new matches
        # We'll keep track of used pairs to avoid repeats
        matched_pairs = set()
        schedule = []

        # We'll keep forming matches round-by-round until:
        #   - we've formed all total_matches, OR
        #   - no one can be paired further
        formed_matches = 0
        round_number = 0
        max_rounds = 4 * total_matches  # safety cap so we don't get stuck forever

        while formed_matches < total_matches and round_number < max_rounds:
            round_number += 1

            # 1) Filter only those who still can fight
            candidates = [p for p in p_info if p["remaining"] > 0]
            # If not enough to form at least 1 match, break
            if len(candidates) < 2:
                break

            # 2) Sort by (#remaining desc, ELO proximity) or random factor
            #    to pair up players who are close in ELO but also balancing usage
            #    We'll do: sort by remaining desc => try to ensure those who have a lot
            #    of matches left go first. Then sub-sort by ELO. Then random perturb.
            def sorting_key(p):
                return (-p["remaining"], p["elo"])

            # Slight random shuffle, but stable with main key
            candidates.sort(key=sorting_key)
            # We'll do a small random shuffle "inside" the sorted list to avoid monotony
            # e.g. shuffle 3 or 4 neighbors:
            for i in range(0, len(candidates), 3):
                slice_end = min(i+3, len(candidates))
                sub = candidates[i:slice_end]
                random.shuffle(sub)
                candidates[i:slice_end] = sub

            used_in_this_round = set()
            i = 0
            round_pairs = []

            # 3) Greedily form pairs from front to back
            while i < len(candidates) - 1:
                p1 = candidates[i]
                if p1["remaining"] <= 0:
                    i += 1
                    continue

                # Find a partner j
                # We'll do a small linear search from i+1 forward
                pair_index = -1
                for j in range(i+1, len(candidates)):
                    p2 = candidates[j]
                    if p2["remaining"] > 0:
                        # check if pair is already used
                        pair_tuple = tuple(sorted([p1["student_id"], p2["student_id"]]))
                        if pair_tuple not in matched_pairs:
                            pair_index = j
                            break
                # If we found no new pair, try again but allow repeated pairs if needed
                if pair_index < 0:
                    for j in range(i+1, len(candidates)):
                        p2 = candidates[j]
                        if p2["remaining"] > 0:
                            pair_index = j
                            break

                if pair_index < 0:
                    # can't pair p1, move on
                    i += 1
                    continue

                # form the pair
                p2 = candidates[pair_index]
                pair_tuple = tuple(sorted([p1["student_id"], p2["student_id"]]))

                # reduce their remaining slots
                p1["remaining"] -= 1
                p2["remaining"] -= 1
                # store the pair
                round_pairs.append(pair_tuple)
                matched_pairs.add(pair_tuple)
                formed_matches += 1

                # We remove p2 from the list so we don't attempt to re-pair them
                # but keep p1 in case there's a next round
                candidates.pop(pair_index)
                # move i forward
                i += 1

                # If we've formed enough total matches, break early
                if formed_matches >= total_matches:
                    break

            # commit these pairs to the schedule
            for pr in round_pairs:
                schedule.append(pr)

            if len(round_pairs) == 0:
                # no pairs formed => break to avoid infinite loop
                break

        # Done forming matches
        return schedule

    async def store_generated_matches(
        self,
        db: AsyncSession,
        arena_id: str,
        matchups: List[Tuple[str, str]],
    ) -> None:
        """Store generated match schedule in database, each matchup => 1 match with 2 participants."""
        for (p1, p2) in matchups:
            new_match = Match(
                arena_id=arena_id,
                status=MatchStatus.PENDING,
                num_rounds=1,
                rounds_completed=0,
            )
            db.add(new_match)
            await db.flush()

            # Grab current ELO
            s1 = await db.get(Student, p1)
            s2 = await db.get(Student, p2)
            e1 = s1.elo_rating if s1 else 1000
            e2 = s2.elo_rating if s2 else 1000

            mp1 = MatchParticipant(
                match_id=new_match.id,
                student_id=p1,
                elo_before=e1
            )
            mp2 = MatchParticipant(
                match_id=new_match.id,
                student_id=p2,
                elo_before=e2
            )
            db.add_all([mp1, mp2])

        await db.commit()

    async def get_recent_opponents(
        self,
        student_id: str,
        db: AsyncSession,
    ) -> Dict[str, datetime]:
        """
        Returns a map of {opponent_id: last_time_they_played_with_student_id} for recently played matches.
        You can keep or remove this if not used.
        """
        cutoff_time = datetime.now(timezone.utc) - timedelta(hours=3)
        query = (
            select(Match, MatchParticipant)
            .join(MatchParticipant)
            .where(
                and_(
                    Match.created_at >= cutoff_time,
                    MatchParticipant.student_id != student_id,
                    Match.id.in_(
                        select(MatchParticipant.match_id)
                        .where(MatchParticipant.student_id == student_id)
                    )
                )
            )
        )
        result = await db.execute(query)
        recent_opponents = {}
        for match, participant in result:
            opp_id = str(participant.student_id)
            match_time = match.created_at
            if opp_id not in recent_opponents or match_time > recent_opponents[opp_id]:
                recent_opponents[opp_id] = match_time
        return recent_opponents

    async def find_match(
        self,
        student_id: str,
        db: AsyncSession
    ) -> Optional[Match]:
        """
        Finds an existing pending match for the student.
        You can keep or remove this if not used.
        """
        query = (
            select(Match)
            .join(MatchParticipant)
            .where(
                and_(
                    MatchParticipant.student_id == student_id,
                    Match.status == MatchStatus.PENDING
                )
            )
        )
        result = await db.execute(query)
        return result.scalar_one_or_none()

    async def find_opponents(
        self,
        student: Student,
        num_opponents: int,
        db: AsyncSession,
        potential_opponents: Optional[List[Student]] = None
    ) -> List[Student]:
        """
        Find suitable opponents for a single match, based on ELO range.
        This is an older method you can keep for one-off usage or remove if not needed.
        """
        if potential_opponents is None:
            # Find potential opponents within ELO range
            query = select(Student).where(
                and_(
                    Student.id != student.id,
                    Student.elo_rating >= student.elo_rating - self.elo_tolerance,
                    Student.elo_rating <= student.elo_rating + self.elo_tolerance
                )
            )
            result = await db.execute(query)
            potential_opponents = result.scalars().all()

        if len(potential_opponents) < num_opponents:
            return []

        # Sort by ELO proximity and add some randomness
        potential_opponents.sort(
            key=lambda o: abs(o.elo_rating - student.elo_rating) + (random.random() * 50)
        )
        return potential_opponents[:num_opponents]

    async def auto_find_players_and_create_match(
        self,
        num_players: int,
        num_rounds: int,
        student_id: str,
        db: AsyncSession
    ) -> Match:
        """
        Legacy method. Creates a single match on-demand with similar ELO players.
        If you rely on this, keep it. Otherwise, remove it. 
        """
        student = await db.get(Student, student_id)
        if not student:
            raise ValueError("Student not found")

        query = select(Student).where(
            and_(
                Student.id != student.id,
                Student.elo_rating >= student.elo_rating - self.elo_tolerance,
                Student.elo_rating <= student.elo_rating + self.elo_tolerance
            )
        )
        result = await db.execute(query)
        opponents = result.scalars().all()
        if len(opponents) < num_players - 1:
            raise ValueError(f"Could not find {num_players - 1} suitable opponents")

        opponents.sort(
            key=lambda o: abs(o.elo_rating - student.elo_rating) + (random.random() * 50)
        )
        selected_opponents = opponents[:num_players-1]
        
        # Create the match
        match = Match(
            status=MatchStatus.PENDING,
            num_rounds=num_rounds,
            arena_id=None  # standalone
        )
        db.add(match)
        await db.flush()

        # Add participants
        player_ids = [str(student.id)] + [str(o.id) for o in selected_opponents]
        for pid in player_ids:
            s = await db.get(Student, pid)
            mp = MatchParticipant(
                match_id=match.id,
                student_id=pid,
                elo_before=s.elo_rating if s else 1000
            )
            db.add(mp)
        await db.commit()
        await db.refresh(match)
        return match



================================================================================
File: backend\app\services\statistics_service.py
================================================================================

from typing import List, Dict, Any
from sqlalchemy import select, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from ..models.student import Student
from ..models.match import Match, MatchStatus, Round, RoundParticipant
from ..models.flashcard import Flashcard
from ..models.arena_session import ArenaSession

class StatisticsService:
    @staticmethod
    async def get_flashcard_stats(flashcard_id: str, db: AsyncSession) -> Dict[str, Any]:
        """Get comprehensive statistics for a flashcard"""
        # Get the flashcard
        flashcard = await db.get(Flashcard, flashcard_id)
        if not flashcard:
            raise ValueError("Flashcard not found")

        # Get rounds where this flashcard was used
        rounds_query = select(Round).where(Round.flashcard_id == flashcard_id)
        result = await db.execute(rounds_query)
        rounds = result.scalars().all()

        total_uses = len(rounds)
        if total_uses == 0:
            return {
                "total_uses": 0,
                "success_rate": 0,
                "average_winners": 0,
                "used_in_arenas": 0
            }

        # Calculate statistics
        total_winners = sum(len(round.winner_ids or []) for round in rounds)
        total_participants = await db.scalar(
            select(func.count(RoundParticipant.student_id))
            .where(RoundParticipant.round_id.in_([r.id for r in rounds]))
        )

        # Get unique arena sessions this flashcard was used in
        unique_arenas = await db.scalar(
            select(func.count(func.distinct(Match.arena_id)))
            .join(Round, Round.match_id == Match.id)
            .where(Round.flashcard_id == flashcard_id)
        )

        return {
            "total_uses": total_uses,
            "success_rate": round((total_winners / total_participants * 100), 1) if total_participants > 0 else 0,
            "average_winners": round(total_winners / total_uses, 2),
            "used_in_arenas": unique_arenas
        }

    @staticmethod
    async def get_most_used_flashcards(db: AsyncSession, limit: int = 10) -> List[Dict[str, Any]]:
        """Get flashcards sorted by usage frequency"""
        query = (
            select(
                Flashcard,
                func.count(Round.id).label('usage_count')
            )
            .join(Round, Round.flashcard_id == Flashcard.id)
            .group_by(Flashcard.id)
            .order_by(desc('usage_count'))
            .limit(limit)
        )
        
        result = await db.execute(query)
        flashcards_with_count = result.all()

        stats = []
        for flashcard, usage_count in flashcards_with_count:
            flashcard_stats = await StatisticsService.get_flashcard_stats(flashcard.id, db)
            stats.append({
                "id": flashcard.id,
                "question": flashcard.question,
                "usage_count": usage_count,
                "success_rate": flashcard_stats["success_rate"],
                "used_in_arenas": flashcard_stats["used_in_arenas"]
            })

        return stats

    @staticmethod
    async def get_arena_flashcard_stats(arena_id: str, db: AsyncSession) -> List[Dict[str, Any]]:
        """Get statistics for all flashcards used in a specific arena session"""
        # Verify arena exists
        arena = await db.get(ArenaSession, arena_id)
        if not arena:
            raise ValueError("Arena session not found")

        # Get all rounds in this arena's matches
        rounds_query = (
            select(Round, Flashcard)
            .join(Match, Match.id == Round.match_id)
            .join(Flashcard, Flashcard.id == Round.flashcard_id)
            .where(Match.arena_id == arena_id)
        )
        
        result = await db.execute(rounds_query)
        rounds_with_flashcards = result.all()

        stats = {}
        for round, flashcard in rounds_with_flashcards:
            if flashcard.id not in stats:
                stats[flashcard.id] = {
                    "id": flashcard.id,
                    "question": flashcard.question,
                    "times_used": 0,
                    "total_winners": 0,
                    "total_participants": 0
                }
            
            stats[flashcard.id]["times_used"] += 1
            stats[flashcard.id]["total_winners"] += len(round.winner_ids or [])
            
            # Count participants
            participant_count = await db.scalar(
                select(func.count(RoundParticipant.student_id))
                .where(RoundParticipant.round_id == round.id)
            )
            stats[flashcard.id]["total_participants"] += participant_count

        # Calculate success rates and format response
        formatted_stats = []
        for flashcard_stats in stats.values():
            success_rate = (
                round(flashcard_stats["total_winners"] / flashcard_stats["total_participants"] * 100, 1)
                if flashcard_stats["total_participants"] > 0
                else 0
            )
            formatted_stats.append({
                "id": flashcard_stats["id"],
                "question": flashcard_stats["question"],
                "times_used": flashcard_stats["times_used"],
                "success_rate": success_rate
            })

        return sorted(formatted_stats, key=lambda x: x["times_used"], reverse=True)

    @staticmethod
    async def get_student_stats(student_id: str, db: AsyncSession) -> Dict[str, Any]:
        """Get comprehensive statistics for a student"""
        # Get the student
        student = await db.get(Student, student_id)
        if not student:
            raise ValueError("Student not found")

        # Get total matches
        matches_query = select(func.count(Match.id)).where(
            ((Match.player1_id == student_id) | (Match.player2_id == student_id)) &
            (Match.status == MatchStatus.COMPLETED)
        )
        total_matches = await db.scalar(matches_query)

        # Get win rate
        wins_query = select(func.count(Match.id)).where(
            (Match.winner_id == student_id) &
            (Match.status == MatchStatus.COMPLETED)
        )
        wins = await db.scalar(wins_query)
        win_rate = (wins / total_matches * 100) if total_matches > 0 else 0

        # Get average ELO change
        elo_changes = []
        matches = await db.execute(
            select(Match).where(
                ((Match.player1_id == student_id) | (Match.player2_id == student_id)) &
                (Match.status == MatchStatus.COMPLETED)
            )
        )
        for match in matches.scalars():
            if match.player1_id == student_id:
                elo_changes.append(match.player1_elo_change or 0)
            else:
                elo_changes.append(match.player2_elo_change or 0)

        avg_elo_change = sum(elo_changes) / len(elo_changes) if elo_changes else 0

        return {
            "total_matches": total_matches,
            "wins": wins,
            "losses": total_matches - wins,
            "win_rate": round(win_rate, 1),
            "current_elo": student.elo_rating,
            "avg_elo_change": round(avg_elo_change, 1)
        }

    @staticmethod
    async def get_leaderboard(db: AsyncSession, limit: int = 10) -> List[Dict[str, Any]]:
        """Get top students by ELO rating"""
        query = select(Student).order_by(desc(Student.elo_rating)).limit(limit)
        result = await db.execute(query)
        students = result.scalars().all()

        leaderboard = []
        for student in students:
            stats = await StatisticsService.get_student_stats(student.id, db)
            leaderboard.append({
                "id": student.id,
                "name": student.name,
                "elo_rating": student.elo_rating,
                "win_rate": stats["win_rate"],
                "total_matches": stats["total_matches"]
            })

        return leaderboard

    @staticmethod
    async def get_match_history(
        student_id: str, db: AsyncSession, limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get recent match history for a student"""
        query = select(Match).where(
            ((Match.player1_id == student_id) | (Match.player2_id == student_id)) &
            (Match.status == MatchStatus.COMPLETED)
        ).order_by(desc(Match.created_at)).limit(limit)

        result = await db.execute(query)
        matches = result.scalars().all()

        history = []
        for match in matches:
            opponent_id = match.player2_id if match.player1_id == student_id else match.player1_id
            opponent = await db.get(Student, opponent_id)
            
            elo_change = match.player1_elo_change if match.player1_id == student_id else match.player2_elo_change
            
            history.append({
                "match_id": match.id,
                "opponent_name": opponent.name,
                "opponent_rating": opponent.elo_rating,
                "won": match.winner_id == student_id,
                "elo_change": elo_change,
                "date": match.created_at
            })

        return history



================================================================================
File: frontend\src\App.tsx
================================================================================

import React from 'react';
import { MantineProvider } from '@mantine/core';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { theme } from './theme';
import { Layout } from './components/shared/Layout';
import { LeaderboardPage, StudentsPage, FlashcardsPage, ArenaPage } from './pages';

function App() {
  return (
    <MantineProvider theme={theme} defaultColorScheme="dark">
      <BrowserRouter>
        <Layout>
          <Routes>
            <Route path="/students" element={<StudentsPage />} />
            <Route path="/flashcards" element={<FlashcardsPage />} />
            <Route path="/arena" element={<ArenaPage />} />
            <Route path="/leaderboard" element={<LeaderboardPage />} />
            <Route path="/" element={<Navigate to="/arena" replace />} />
          </Routes>
        </Layout>
      </BrowserRouter>
    </MantineProvider>
  );
}

export default App;



================================================================================
File: frontend\src\index.tsx
================================================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import '@mantine/core/styles.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(<App />);



================================================================================
File: frontend\src\achievements\getStudentAchievements.ts
================================================================================

import { achievementApi } from '../services/achievementApi';
import type { StudentAchievementResponse } from '../types';

/**
 * Fetch the unlocked achievements for a given student ID.
 */
export async function getStudentAchievements(studentId: string): Promise<StudentAchievementResponse[]> {
  try {
    const response = await achievementApi.getStudentAchievements(studentId);
    return response.data.data;
  } catch (error) {
    console.error('Error fetching student achievements:', error);
    return [];
  }
}



================================================================================
File: frontend\src\components\arena\ArenaBattle.tsx
================================================================================

import React, { useCallback } from 'react';
import { Box } from '@mantine/core';
import { ArenaStep, ArenaMatch } from '../../types/arena';
import type { Student, Flashcard } from '../../types';
import { useArenaBattleSounds } from '../../hooks/useArenaBattleSounds';
import { VersusScreenWrapper } from './screens/VersusScreenWrapper';
import { BattleScreen } from './screens/BattleScreen';
import { FinalResultScreen } from './screens/FinalResultScreen';
import { RoundResultScreen } from './screens/RoundResultScreen';

interface ArenaBattleProps {
  step: ArenaStep;
  currentFlashcard: Flashcard | null;
  currentMatch: ArenaMatch | null;
  arenaSession: {
    rounds_completed: number;
    num_rounds: number;
    participants: any[];
  } | null;
  students: Student[];
  onVersusReady: () => void;
  onSelectWinner: (winnerIds: string[]) => void;
  onNextRound: () => void;
  onReset: () => void;
  isLoading: boolean;
}

export const ArenaBattle: React.FC<ArenaBattleProps> = ({
  step,
  currentFlashcard,
  currentMatch,
  arenaSession,
  students,
  onVersusReady,
  onSelectWinner,
  onNextRound,
  onReset,
  isLoading,
}) => {
  // Handle sound effects based on arena step
  useArenaBattleSounds(step);

  const canPickWinner = step !== ArenaStep.VERSUS && !isLoading;

  const handleVersusAnimationDone = useCallback(() => {
    onVersusReady();
  }, [onVersusReady]);

  return (
    <Box
      data-testid="arena-battle"
      style={{
        width: '100%',
        height: '100%',
        position: 'relative',
        display: 'flex',
        flexDirection: 'column'
      }}
    >
      {step === ArenaStep.VERSUS && (
        <VersusScreenWrapper
          currentMatch={currentMatch}
          students={students}
          onAnimationComplete={handleVersusAnimationDone}
          onReset={onReset}
        />
      )}
      
      {step === ArenaStep.BATTLE && (
        <BattleScreen
          currentMatch={currentMatch}
          currentFlashcard={currentFlashcard}
          students={students}
          arenaSession={arenaSession}
          onSelectWinner={onSelectWinner}
          onReset={onReset}
          isLoading={isLoading}
          canPickWinner={canPickWinner}
        />
      )}
      
      {step === ArenaStep.ROUND_RESULT && currentMatch && (
        <RoundResultScreen
          currentMatch={currentMatch}
          students={students}
          onNextRound={onNextRound}
          onReset={onReset}
        />
      )}

      {step === ArenaStep.FINAL_RESULT && (
        <FinalResultScreen
          arenaSession={arenaSession}
          students={students}
          onReset={onReset}
        />
      )}
    </Box>
  );
};



================================================================================
File: frontend\src\components\arena\ArenaBattleCard.tsx
================================================================================

import React from 'react';
import { Stack, Group } from '@mantine/core';
import { Student, Flashcard } from '../../types';
import {
  BattleProgress,
  FlashcardDisplay,
  PlayerProfile,
  WinnerSelection,
} from './battle-card';

interface ArenaBattleCardProps {
  flashcard: Flashcard;
  player1: Student;
  player2: Student;
  roundsCompleted: number;
  totalRounds: number;
  onSelectWinner: (winnerIds: string[]) => void;
  player1ELO: number;
  player2ELO: number;
  isLoading?: boolean;
  canPickWinner: boolean;
}

export const ArenaBattleCard: React.FC<ArenaBattleCardProps> = ({
  flashcard,
  player1,
  player2,
  roundsCompleted,
  totalRounds,
  onSelectWinner,
  player1ELO,
  player2ELO,
  isLoading = false,
  canPickWinner,
}) => {
  return (
    <Stack
      style={{
        width: '100%',
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        justifyContent: 'space-between',
        overflow: 'hidden',
        padding: 0
      }}
      gap="xs"
    >
      <BattleProgress
        roundsCompleted={roundsCompleted}
        totalRounds={totalRounds}
      />

      <div style={{
        flex: 1,
        minHeight: 0,
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        overflow: 'hidden',
        width: '100%',
        padding: '1rem'
      }}>
        <FlashcardDisplay flashcard={flashcard} />
      </div>

      <Group justify="apart" mb="xs">
        <PlayerProfile
          player={player1}
          elo={player1ELO}
          colorGradient={{ from: '#4dabf7', to: '#228be6' }}
        />
        <PlayerProfile
          player={player2}
          elo={player2ELO}
          colorGradient={{ from: '#ff6b6b', to: '#fa5252' }}
        />
      </Group>

      <WinnerSelection
        player1={player1}
        player2={player2}
        onSelectWinner={onSelectWinner}
        isLoading={isLoading}
        canPickWinner={canPickWinner}
      />
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\ArenaResultScreen.tsx
================================================================================

import React from 'react';
import { motion } from 'framer-motion';
import { Card, Text, Stack, Button, Group, Badge, Grid, Table, Avatar } from '@mantine/core';
import { IconTrophy, IconArrowUp, IconArrowDown, IconConfetti } from '@tabler/icons-react';

interface StudentStats {
  student_id: string;
  name: string;
  elo_rating: number;
  wins: number;
  losses: number;
  fights_played: number;
  elo_change: number;
  avatar_url?: string;
}

interface ArenaResultScreenProps {
  results: StudentStats[];
  onFinish: () => void;
}

const RankBadge: React.FC<{ rank: number }> = ({ rank }) => {
  const color = rank === 1 ? 'yellow' : rank === 2 ? 'gray' : rank === 3 ? 'orange' : 'blue';
  const icon = rank <= 3 ? <IconTrophy size={16} /> : null;

  return (
    <Badge
      size="lg"
      color={color}
      variant={rank <= 3 ? 'filled' : 'light'}
      leftSection={icon}
    >
      #{rank}
    </Badge>
  );
};

export const ArenaResultScreen: React.FC<ArenaResultScreenProps> = ({
  results,
  onFinish
}) => {
  // Sort results by ELO rating descending
  const sortedResults = React.useMemo(() => {
    return [...results].sort((a, b) => b.elo_rating - a.elo_rating);
  }, [results]);

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.85 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.85 }}
      transition={{
        type: 'spring',
        stiffness: 100,
        damping: 15,
      }}
      style={{
        width: '100%',
        height: '100%',
        margin: '0 auto',
        padding: 'min(2vh, 2rem)',
        display: 'flex',
        flexDirection: 'column'
      }}
    >
      <Card
        shadow="lg"
        p="xl"
        radius="md"
        withBorder
        style={{
          background: 'linear-gradient(45deg, #F8FFAE, #43C6AC)',
          position: 'relative',
          overflow: 'hidden',
        }}
      >
        {/* Confetti Icon in BG */}
        <motion.div
          initial={{ rotate: 0 }}
          animate={{ rotate: 360 }}
          transition={{
            duration: 20,
            repeat: Infinity,
            ease: 'linear',
          }}
          style={{
            position: 'absolute',
            top: '-50px',
            right: '-50px',
            opacity: 0.2,
          }}
        >
          <IconConfetti size={200} />
        </motion.div>

        <Stack align="center" gap="xl">
          {/* Title */}
          <motion.div
            initial={{ y: -40, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{
              type: 'spring',
              stiffness: 300,
              damping: 15,
            }}
          >
            <Text
              size="xl"
              fw={900}
              style={{
                fontSize: '3rem',
                textAlign: 'center',
                color: '#fff',
                textShadow: '0 0 20px rgba(0,0,0,0.4)',
              }}
            >
              Arena Complete!
            </Text>
          </motion.div>

          {/* Top 3 Podium */}
          <Grid gutter="xl" style={{ width: '100%' }}>
            {sortedResults.slice(0, 3).map((student, index) => (
              <Grid.Col key={student.student_id} span={4}>
                <Card
                  shadow="md"
                  p="lg"
                  radius="md"
                  withBorder
                  style={{
                    background: 'rgba(255,255,255,0.8)',
                    backdropFilter: 'blur(4px)',
                  }}
                >
                  <Stack align="center" gap="md">
                    <RankBadge rank={index + 1} />
                    <Avatar
                      src={student.avatar_url}
                      alt={student.name}
                      size={100}
                      radius="xl"
                      style={{
                        border: '3px solid var(--mantine-color-blue-5)',
                        boxShadow: '0 0 15px rgba(0,0,0,0.2)'
                      }}
                    >
                      {!student.avatar_url && student.name ? student.name.charAt(0) : ''}
                    </Avatar>
                    <Text size="xl" fw={700} c="dark" style={{ fontSize: '1.8rem' }}>
                      {student.name}
                    </Text>
                    <Badge size="xl" variant="filled" color="blue" style={{ fontSize: '1.2rem' }}>
                      {student.elo_rating} ELO
                    </Badge>
                    <Group>
                      <Badge size="lg" color="green" style={{ fontSize: '1.1rem' }}>Wins: {student.wins}</Badge>
                      <Badge size="lg" color="red" style={{ fontSize: '1.1rem' }}>Losses: {student.losses}</Badge>
                    </Group>
                    <Text
                      size="xl"
                      c={student.elo_change >= 0 ? 'dark' : 'dark'}
                      fw={700}
                      style={{ fontSize: '1.4rem' }}
                    >
                      {student.elo_change > 0 ? '+' : ''}
                      {Math.round(student.elo_change)} ELO
                    </Text>
                  </Stack>
                </Card>
              </Grid.Col>
            ))}
          </Grid>

          {/* Full Results Table */}
          <Card
            shadow="sm"
            p="lg"
            radius="md"
            withBorder
            style={{ width: '100%', background: 'rgba(255,255,255,0.9)' }}
          >
            <Text size="xl" fw={800} mb="md" c="dark" style={{ fontSize: '1.8rem' }}>
              Final Rankings
            </Text>
            <Table striped highlightOnHover>
              <thead>
                <tr>
                  <th><Text size="lg" fw={700} c="dark">Rank</Text></th>
                  <th><Text size="lg" fw={700} c="dark">Name</Text></th>
                  <th><Text size="lg" fw={700} c="dark">W/L</Text></th>
                  <th><Text size="lg" fw={700} c="dark">Fights</Text></th>
                  <th><Text size="lg" fw={700} c="dark">Final ELO</Text></th>
                  <th><Text size="lg" fw={700} c="dark">ELO Change</Text></th>
                </tr>
              </thead>
              <tbody>
                {sortedResults.map((student, index) => {
                  const isPositive = student.elo_change >= 0;
                  return (
                    <tr key={student.student_id}>
                      <td>
                        <RankBadge rank={index + 1} />
                      </td>
                      <td>
                        <Group gap="sm">
                          <Avatar
                            src={student.avatar_url}
                            alt={student.name}
                            size="md"
                            radius="xl"
                          >
                            {!student.avatar_url && student.name ? student.name.charAt(0) : ''}
                          </Avatar>
                          <Text size="lg" fw={500} c="dark">{student.name}</Text>
                        </Group>
                      </td>
                      <td>
                        <Group gap="xs">
                          <Text size="lg" fw={600} c="dark">{student.wins}</Text>
                          <Text size="lg" fw={500} c="dark">/</Text>
                          <Text size="lg" fw={600} c="dark">{student.losses}</Text>
                        </Group>
                      </td>
                      <td><Text size="lg" fw={500} c="dark">{student.fights_played}</Text></td>
                      <td><Text size="lg" fw={500} c="dark">{student.elo_rating}</Text></td>
                      <td>
                        <Group gap="xs">
                          {isPositive ? (
                            <IconArrowUp size={16} color="green" />
                          ) : (
                            <IconArrowDown size={16} color="red" />
                          )}
                          <Text c={isPositive ? 'green' : 'red'} fw={500}>
                            {isPositive ? '+' : ''}
                            {Math.round(student.elo_change)}
                          </Text>
                        </Group>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </Table>
          </Card>

          {/* Finish Button */}
          <motion.div
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1 }}
          >
            <Button
              size="lg"
              variant="gradient"
              gradient={{ from: 'blue', to: 'cyan' }}
              onClick={onFinish}
            >
              Return to Arena
            </Button>
          </motion.div>
        </Stack>
      </Card>
    </motion.div>
  );
};



================================================================================
File: frontend\src\components\arena\ArenaSetup.tsx
================================================================================

import React, { useCallback, useState, useEffect } from 'react';
import { Stack, Box, Paper, MantineTheme } from '@mantine/core';
import { useArenaSetup } from '../../hooks/useArenaSetup';
import { useStudentStore } from '../../stores';
import { containerStyles, paperStyles } from './setup/styles';
import {
  ArenaHeader,
  ArenaPackSelect,
  ArenaRoundsInput,
  ArenaPlayerSelect,
  ArenaStartButton
} from './setup';

interface ArenaSetupProps {
  onStart: (packId: string, playerIds: string[], rounds: number) => void;
  isLoading?: boolean;
}

export const ArenaSetup: React.FC<ArenaSetupProps> = ({ onStart, isLoading = false }) => {
  const {
    selectedPackId,
    numRounds,
    validationErrors,
    packSelectData,
    handlePackChange,
    handleRoundsChange,
    getSetupData,
  } = useArenaSetup();

  const { students, fetchStudents } = useStudentStore();
  const [selectedPlayerIds, setSelectedPlayerIds] = useState<string[]>([]);

  useEffect(() => {
    fetchStudents();
  }, [fetchStudents]);

  const toggleStudent = useCallback(
    (id: string) => {
      setSelectedPlayerIds((prev) =>
        prev.includes(id) ? prev.filter((sid) => sid !== id) : [...prev, id]
      );
    },
    [setSelectedPlayerIds]
  );

  const handleStartClick = () => {
    const data = getSetupData();
    if (!data.selectedPackId) {
      return;
    }
    if (selectedPlayerIds.length < 2) {
      window.alert('Please select at least 2 players for the Arena.');
      return;
    }
    if (numRounds < 1 || numRounds > 20) {
      window.alert('Rounds must be between 1 and 20');
      return;
    }

    onStart(data.selectedPackId, selectedPlayerIds, numRounds);
  };

  return (
    <Stack
      gap="xl"
      data-testid="arena-setup"
      p={{ base: 'md', sm: 'xl' }}
      maw="100%"
      w="100%"
      mx="auto"
      styles={(theme: MantineTheme) => ({
        root: {
          ...containerStyles(theme).root,
          maxWidth: '1400px',
          width: '100%',
          margin: '0 auto',
          padding: theme.spacing.xl
        }
      })}
    >
      <Box
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'radial-gradient(circle at top left, rgba(95, 75, 255, 0.15), transparent 70%)',
          pointerEvents: 'none'
        }}
      />

      <Stack align="center" mb="xl">
        <ArenaHeader />
      </Stack>

      <Paper
        p={{ base: 'md', sm: 'xl' }}
        radius="md"
        styles={(theme: MantineTheme) => ({
          root: {
            ...paperStyles(theme).root,
            width: '100%',
            maxWidth: '100%'
          }
        })}
      >
        <Stack gap="xl">
          <ArenaPackSelect
            packSelectData={packSelectData}
            selectedPackId={selectedPackId}
            onPackChange={handlePackChange}
            error={validationErrors.pack}
          />

          <ArenaRoundsInput
            numRounds={numRounds}
            onRoundsChange={handleRoundsChange}
            error={validationErrors.rounds}
          />

          <ArenaPlayerSelect
            students={students}
            selectedPlayerIds={selectedPlayerIds}
            onTogglePlayer={toggleStudent}
          />
        </Stack>
      </Paper>

      <ArenaStartButton
        onClick={handleStartClick}
        isLoading={isLoading}
      />
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\BattleCard.tsx
================================================================================

import React from 'react';
import DOMPurify from 'dompurify';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Card,
  Text,
  Stack,
  Button,
  Group,
  Progress,
  Badge,
  useMantineTheme,
  Box,
  Checkbox,
  TextInput,
} from '@mantine/core';
import { IconBolt } from '@tabler/icons-react';
import { Flashcard, RoundParticipant } from '../../types';
import { useSound } from '../../hooks/useSound';

interface BattleCardProps {
  flashcard: Flashcard;
  participants: RoundParticipant[];
  currentRound: number;
  totalRounds: number;
  onSubmitAnswer: (playerId: string, answer: string) => void;
  onSelectWinners: (winnerIds: string[]) => void;
}

export const BattleCard: React.FC<BattleCardProps> = ({
  flashcard,
  participants,
  currentRound,
  totalRounds,
  onSubmitAnswer,
  onSelectWinners,
}) => {
  const theme = useMantineTheme();
  const { playSound } = useSound();

  // Card flip states
  const [isFlipped, setIsFlipped] = React.useState(false);
  const [selectedWinners, setSelectedWinners] = React.useState<string[]>([]);
  const [answers, setAnswers] = React.useState<Record<string, string>>({});

  // Reset states when flashcard changes
  React.useEffect(() => {
    setIsFlipped(false);
    setSelectedWinners([]);
    setAnswers({});
  }, [flashcard]);

  // Force re-render of card content when flashcard changes
  const cardKey = React.useMemo(() => 
    `card-${flashcard.id}-${isFlipped ? 'back' : 'front'}`, 
    [flashcard.id, isFlipped]
  );

  // Handle answer submission for a participant
  const handleAnswerSubmit = (playerId: string, answer: string) => {
    setAnswers(prev => ({ ...prev, [playerId]: answer }));
    onSubmitAnswer(playerId, answer);
  };

  // Handle winner selection
  const handleWinnerToggle = (playerId: string) => {
    setSelectedWinners(prev => {
      const isSelected = prev.includes(playerId);
      if (isSelected) {
        return prev.filter(id => id !== playerId);
      } else {
        return [...prev, playerId];
      }
    });
  };

  // Submit winners
  const handleSubmitWinners = React.useCallback(() => {
    if (selectedWinners.length > 0) {
      playSound('correct');
      onSelectWinners(selectedWinners);
    }
  }, [selectedWinners, playSound, onSelectWinners]);

  // Flip the card to show/hide answer
  const handleFlip = React.useCallback(() => {
    playSound('flip');
    setIsFlipped((prev) => !prev);
  }, [playSound]);

  // Sanitize HTML content
  const sanitizedQuestion = React.useMemo(() => {
    try {
      const sanitized = DOMPurify.sanitize(flashcard.question || '');
      return sanitized || '<p>No question available</p>';
    } catch (error) {
      console.error('Error sanitizing question:', error);
      return '<p>Error displaying question</p>';
    }
  }, [flashcard.question]);

  const sanitizedAnswer = React.useMemo(() => {
    try {
      const sanitized = DOMPurify.sanitize(flashcard.answer || '');
      return sanitized || '<p>No answer available</p>';
    } catch (error) {
      console.error('Error sanitizing answer:', error);
      return '<p>Error displaying answer</p>';
    }
  }, [flashcard.answer]);

  // Difficulty color
  const difficultyColor =
    flashcard.difficulty === 'easy'
      ? 'green'
      : flashcard.difficulty === 'medium'
      ? 'yellow'
      : 'red';

  // Enhanced framer-motion variants for flipping
  const cardVariants = {
    hidden: {
      opacity: 0,
      rotateY: -180,
      scale: 0.95,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 20,
      },
    },
    visible: {
      opacity: 1,
      rotateY: 0,
      scale: 1,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
        mass: 1,
        delay: 0.1,
      },
    },
    exit: {
      opacity: 0,
      rotateY: 180,
      scale: 0.95,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 20,
      },
    },
  };

  // Variants for staggered answer section reveal
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
        delayChildren: 0.2,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
      },
    },
  };

  // Progress bar animation variants
  const progressVariants = {
    initial: { scaleX: 0, originX: 0 },
    animate: { 
      scaleX: 1,
      transition: {
        type: "spring",
        stiffness: 60,
        damping: 15
      }
    }
  };

  return (
    <Stack style={{ width: '100%', maxWidth: '800px', margin: '0 auto' }} gap="md">
      {/* Match/round overview */}
      <Card shadow="sm" p="md" radius="md" withBorder>
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{
            type: "spring",
            stiffness: 100,
            damping: 15,
          }}
        >
          <Group justify="space-between" mb="xs">
            {participants.map((participant, index) => (
              <motion.div
                key={participant.student_id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{
                  type: "spring",
                  stiffness: 100,
                  damping: 15,
                  delay: index * 0.1,
                }}
              >
                <Group>
                  <Text fw={500}>{participant.student?.name}</Text>
                  <Badge color="blue">{participant.elo_before} ELO</Badge>
                </Group>
              </motion.div>
            ))}
          </Group>
          <Group justify="space-between" mb="xs">
            <Text size="sm" fw={500}>
              Round {currentRound}/{totalRounds}
            </Text>
            <Badge
              color={difficultyColor}
              variant="light"
              leftSection={<IconBolt size={14} />}
            >
              {flashcard.difficulty.toUpperCase()}
            </Badge>
          </Group>
          <motion.div
            initial="initial"
            animate="animate"
            variants={progressVariants}
          >
            <Progress
              value={(currentRound / totalRounds) * 100}
              size="xl"
              radius="xl"
            />
          </motion.div>
        </motion.div>
      </Card>

      {/* The flipping card itself */}
      <Box style={{
        perspective: 1000,
        position: 'relative',
        width: '100%',
        height: '300px',
      }}>
        <AnimatePresence mode="sync" initial={false}>
          {/* FRONT SIDE (the question) */}
          {!isFlipped && (
            <motion.div
              key={`${cardKey}-front`}
              initial="hidden"
              animate="visible"
              exit="exit"
              variants={cardVariants}
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                backgroundColor: theme.white,
                border: `1px solid ${theme.colors.gray[3]}`,
                borderRadius: theme.radius.md,
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                padding: theme.spacing.xl,
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
              }}
            >
              <Text
                ta="center"
                fw={700}
                size="xl"
                mb="md"
                dangerouslySetInnerHTML={{ __html: sanitizedQuestion }}
                style={{ overflowY: 'auto', maxHeight: '180px' }}
              />
              <Button
                mt="auto"
                variant="gradient"
                gradient={{ from: 'blue', to: 'cyan' }}
                onClick={handleFlip}
                style={{ transform: 'translateZ(50px)' }}
              >
                Flip to See Answer
              </Button>
            </motion.div>
          )}

          {/* BACK SIDE (the answer) */}
          {isFlipped && (
            <motion.div
              key={`${cardKey}-back`}
              initial="hidden"
              animate="visible"
              exit="exit"
              variants={cardVariants}
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)',
                backgroundColor: theme.white,
                border: `1px solid ${theme.colors.gray[3]}`,
                borderRadius: theme.radius.md,
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                padding: theme.spacing.xl,
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
              }}
            >
              <Text
                ta="center"
                fw={700}
                size="xl"
                mb="md"
                dangerouslySetInnerHTML={{ __html: sanitizedAnswer }}
                style={{ overflowY: 'auto', maxHeight: '180px' }}
              />
              <Button
                mt="auto"
                variant="gradient"
                gradient={{ from: 'orange', to: 'red' }}
                onClick={handleFlip}
                style={{ transform: 'translateZ(50px)' }}
              >
                Flip Back to Question
              </Button>
            </motion.div>
          )}
        </AnimatePresence>
      </Box>

      {/* Answer submission */}
      <motion.div
        initial="hidden"
        animate="visible"
        variants={containerVariants}
      >
        <Card shadow="sm" p="md" radius="md" withBorder>
          <Stack gap="md">
            <Text fw={500}>Submit Answers</Text>
            {participants.map((participant) => (
              <motion.div key={participant.student_id} variants={itemVariants}>
                <Group grow>
                  <TextInput
                    label={participant.student?.name}
                    placeholder="Enter answer..."
                    value={answers[participant.student_id] || ''}
                    onChange={(e) => handleAnswerSubmit(participant.student_id, e.target.value)}
                    disabled={!!participant.answer}
                  />
                  <Checkbox
                    label="Winner"
                    checked={selectedWinners.includes(participant.student_id)}
                    onChange={() => handleWinnerToggle(participant.student_id)}
                    disabled={!participant.answer}
                  />
                </Group>
              </motion.div>
            ))}
            <motion.div variants={itemVariants}>
              <Button
                color="blue"
                onClick={handleSubmitWinners}
                disabled={selectedWinners.length === 0}
              >
                Submit Winners
              </Button>
            </motion.div>
          </Stack>
        </Card>
      </motion.div>
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\ResultScreen.tsx
================================================================================

import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Card, Text, Stack, Button, Group, Badge, Grid } from '@mantine/core';
import { Match, MatchParticipant } from '../../types';

interface ResultScreenProps {
  match: Match;
  onContinue: () => void;
}

interface ParticipantStatsProps {
  participant: MatchParticipant;
  roundWins: number;
  isWinner: boolean;
}

const ParticipantStats: React.FC<ParticipantStatsProps> = ({
  participant,
  roundWins,
  isWinner,
}) => {
  const eloChange = (participant.elo_after || 0) - (participant.elo_before || 0);

  return (
    <motion.div
      initial={{ opacity: 0, y: 50 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{
        type: "spring",
        stiffness: 100,
        damping: 15,
      }}
    >
      <motion.div
        whileHover={{ 
          scale: 1.02,
          rotateY: 5,
          transition: { type: "spring", stiffness: 400, damping: 10 }
        }}
      >
        <Card 
          shadow="sm" 
          p="lg" 
          radius="md" 
          withBorder 
          style={{ 
            height: '100%',
            transform: "perspective(1000px)",
            transformStyle: "preserve-3d",
            background: isWinner ? 
              'linear-gradient(45deg, rgba(255,215,0,0.1), rgba(255,255,255,0.1))' : 
              undefined
          }}
        >
          <Stack align="center" gap="md">
            <motion.div
              animate={isWinner ? {
                y: [0, -10, 0],
                scale: [1, 1.1, 1],
              } : {}}
              transition={{
                duration: 2,
                repeat: Infinity,
                repeatType: 'reverse',
                ease: "easeInOut"
              }}
            >
              <Text 
                size="xl" 
                fw={700}
                style={{
                  textShadow: isWinner ? '0 0 10px rgba(255,215,0,0.5)' : undefined
                }}
              >
                {participant.student?.name}
              </Text>
            </motion.div>

            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{
                type: "spring",
                stiffness: 200,
                damping: 15,
                delay: 0.2
              }}
            >
              <Badge 
                size="xl" 
                color={isWinner ? 'green' : 'red'}
                style={{
                  transform: "translateZ(20px)",
                  boxShadow: isWinner ? '0 0 20px rgba(0,255,0,0.3)' : undefined
                }}
              >
                {isWinner ? 'Winner!' : 'Defeated'}
              </Badge>
            </motion.div>
            
            {/* ELO Change */}
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{
                type: "spring",
                stiffness: 200,
                damping: 15,
                delay: 0.4
              }}
            >
              <motion.div
                animate={isWinner ? {
                  scale: [1, 1.2, 1],
                  rotate: [0, 5, 0, -5, 0]
                } : {}}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  repeatType: 'reverse'
                }}
              >
                <Text 
                  size="lg" 
                  c={eloChange >= 0 ? 'green' : 'red'}
                  fw={700}
                  style={{
                    textShadow: `0 0 10px ${eloChange >= 0 ? 'rgba(0,255,0,0.3)' : 'rgba(255,0,0,0.3)'}`
                  }}
                >
                  {eloChange > 0 ? '+' : ''}{Math.round(eloChange * 10) / 10} ELO
                </Text>
              </motion.div>
            </motion.div>

            {/* Rating Change */}
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{
                type: "spring",
                stiffness: 100,
                damping: 15,
                delay: 0.6
              }}
            >
              <Group>
                <Text size="md" c="dimmed">
                  {participant.elo_before} →
                </Text>
                <Text 
                  size="md" 
                  fw={700}
                  style={{
                    color: isWinner ? '#FFD700' : undefined,
                    textShadow: isWinner ? '0 0 10px rgba(255,215,0,0.5)' : undefined
                  }}
                >
                  {participant.elo_after}
                </Text>
              </Group>
            </motion.div>

            {/* Round Wins */}
            <motion.div
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{
                type: "spring",
                stiffness: 100,
                damping: 15,
                delay: 0.8
              }}
            >
              <Text size="md">
                Rounds Won: {roundWins}
              </Text>
            </motion.div>

            {/* Winner Effects */}
            {isWinner && (
              <motion.div
                initial={{ scale: 0 }}
                animate={{ scale: [0, 1.2, 1] }}
                transition={{
                  type: "spring",
                  stiffness: 200,
                  damping: 10,
                  delay: 1
                }}
                style={{
                  position: 'absolute',
                  top: -20,
                  right: -20,
                  width: 40,
                  height: 40,
                  background: 'linear-gradient(45deg, #FFD700, #FFA500)',
                  borderRadius: '50%',
                  boxShadow: '0 0 20px rgba(255,215,0,0.5)',
                  zIndex: -1
                }}
              />
            )}
          </Stack>
        </Card>
      </motion.div>
    </motion.div>
  );
};

export const ResultScreen: React.FC<ResultScreenProps> = ({
  match,
  onContinue
}) => {
  // Calculate round wins for each participant
  const roundWins = React.useMemo(() => {
    const wins: Record<string, number> = {};
    match.rounds?.forEach(round => {
      if (round.winner_ids && round.winner_ids.length > 0) {
        round.winner_ids.forEach(winnerId => {
          wins[winnerId] = (wins[winnerId] || 0) + 1;
        });
      }
    });
    return wins;
  }, [match.rounds]);

  // Sort participants by round wins (descending)
  const sortedParticipants = React.useMemo(() => {
    return [...match.participants].sort((a, b) => {
      const aWins = roundWins[a.student_id] || 0;
      const bWins = roundWins[b.student_id] || 0;
      return bWins - aWins;
    });
  }, [match.participants, roundWins]);

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{
        type: "spring",
        stiffness: 100,
        damping: 15
      }}
      style={{
        width: '100%',
        maxWidth: '1200px',
        margin: '0 auto',
        padding: '2rem'
      }}
    >
      <Card 
        shadow="lg" 
        p="xl" 
        radius="md" 
        withBorder
        style={{
          transform: "perspective(1000px)",
          transformStyle: "preserve-3d",
          background: 'linear-gradient(45deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05))'
        }}
      >
        <Stack align="center" gap="xl">
          {/* Title */}
          <motion.div
            initial={{ y: -50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{
              type: 'spring',
              stiffness: 200,
              damping: 15
            }}
          >
            <motion.div
              animate={{
                scale: [1, 1.1, 1],
                rotate: [0, 2, 0, -2, 0]
              }}
              transition={{
                duration: 4,
                repeat: Infinity,
                repeatType: 'reverse',
                ease: "easeInOut"
              }}
            >
              <Text
                size="xl"
                fw={900}
                variant="gradient"
                gradient={{ from: 'gold', to: 'yellow', deg: 45 }}
                ta="center"
                style={{ 
                  fontSize: '3rem',
                  textShadow: '0 0 20px rgba(255,215,0,0.5)',
                  letterSpacing: '0.1em'
                }}
              >
                Match Complete!
              </Text>
            </motion.div>
          </motion.div>

          {/* Match Stats */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{
              type: "spring",
              stiffness: 100,
              damping: 15,
              delay: 0.2
            }}
          >
            <Group justify="center" gap="md">
              <Text size="lg" fw={500}>
                Rounds: {match.rounds_completed}/{match.num_rounds}
              </Text>
            </Group>
          </motion.div>

          {/* Participants Grid */}
          <Grid gutter="xl" style={{ width: '100%' }}>
            {sortedParticipants.map((participant, index) => (
              <Grid.Col 
                key={participant.student_id} 
                span={12 / Math.min(sortedParticipants.length, 3)}
              >
                <ParticipantStats
                  participant={participant}
                  roundWins={roundWins[participant.student_id] || 0}
                  isWinner={match.winner_ids?.includes(participant.student_id) ?? false}
                />
              </Grid.Col>
            ))}
          </Grid>

          {/* Continue Button */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{
              type: "spring",
              stiffness: 100,
              damping: 15,
              delay: 1
            }}
          >
            <motion.div
              whileHover={{ 
                scale: 1.05,
                transition: { type: "spring", stiffness: 400, damping: 10 }
              }}
              whileTap={{ scale: 0.95 }}
            >
              <Button
                size="lg"
                variant="gradient"
                gradient={{ from: 'blue', to: 'cyan' }}
                onClick={onContinue}
                style={{
                  transform: "translateZ(20px)",
                  boxShadow: '0 4px 15px rgba(0,0,0,0.2)'
                }}
              >
                Continue
              </Button>
            </motion.div>
          </motion.div>
        </Stack>
      </Card>
    </motion.div>
  );
};



================================================================================
File: frontend\src\components\arena\VersusScreen.tsx
================================================================================

import React, { useEffect } from 'react';
import { motion } from 'framer-motion';
import { Text, Avatar, Grid, Box, Paper, MantineTheme } from '@mantine/core';
import { MatchParticipant } from '../../types';
import { FullScreenWrapper } from './screens/FullScreenWrapper';

interface VersusScreenProps {
  participants?: MatchParticipant[];
  onAnimationComplete: () => void;
}

export const VersusScreen: React.FC<VersusScreenProps> = ({
  participants,
  onAnimationComplete,
}) => {
  useEffect(() => {
    const timer = setTimeout(() => {
      onAnimationComplete();
    }, 3000);
    return () => {
      clearTimeout(timer);
    };
  }, [onAnimationComplete]);

  if (!participants || participants.length === 0) {
    return <Box>No participants available</Box>;
  }

  const vsVariants = {
    initial: { scale: 3, opacity: 0, rotate: -45 },
    animate: {
      scale: 1,
      opacity: 1,
      rotate: 0,
      transition: {
        duration: 0.8,
        ease: [0.6, -0.05, 0.01, 0.99],
        scale: { type: "spring", stiffness: 300, damping: 15 }
      },
    },
  };

  const starVariants = {
    animate: {
      opacity: [0, 1, 0],
      scale: [0.8, 1.5, 0.8],
      rotate: [0, 180, 360],
      transition: {
        duration: 2,
        repeat: Infinity,
        ease: 'easeInOut',
        times: [0, 0.5, 1],
      },
    },
  };

  const renderPlayerCard = (participant: MatchParticipant, isLeft: boolean) => {
    if (!participant.student) return null;
    const xStart = isLeft ? -300 : 300;

    return (
      <motion.div
        initial={{ x: xStart, opacity: 0 }}
        animate={{ x: 0, opacity: 1 }}
        transition={{
          type: 'spring',
          stiffness: 60,
          damping: 12,
          delay: isLeft ? 0.3 : 0.7,
        }}
        style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          width: '100%',
          maxWidth: '400px',
        }}
      >
        <Paper
          p="xl"
          radius="lg"
          style={{
            background: 'rgba(255, 255, 255, 0.07)',
            backdropFilter: 'blur(12px)',
            textAlign: 'center',
            width: '100%',
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '1rem',
            border: '2px solid rgba(255, 255, 255, 0.15)',
            transition: 'all 0.3s ease',
            transform: 'translateY(0)',
            ':hover': {
              transform: 'translateY(-8px)',
              boxShadow: '0 20px 60px rgba(0, 0, 0, 0.6)',
            }
          }}
        >
          <Avatar
            src={participant.student.avatar_url || undefined}
            alt={participant.student.name}
            size={160}
            radius={80}
            style={{
              margin: '0 auto',
              border: '4px solid rgba(255, 255, 255, 0.9)',
              boxShadow: '0 0 40px rgba(0,0,0,0.5), 0 0 80px rgba(255,255,255,0.1)',
            }}
          >
            {(!participant.student.avatar_url && participant.student.name)
              ? participant.student.name.charAt(0)
              : ''}
          </Avatar>

          <Text
            fw={700}
            style={{
              color: 'white',
              textShadow: '0 2px 4px rgba(0,0,0,0.4)',
              textAlign: 'center',
              width: '100%',
              fontSize: 'clamp(1.5rem, 4vw, 2.25rem)',
              letterSpacing: '0.5px',
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              whiteSpace: 'nowrap',
            }}
          >
            {participant.student.name}
          </Text>

          <Text
            style={{
              fontSize: 'clamp(1.25rem, 3vw, 2rem)',
              fontWeight: 700,
              color: '#FFD700',
              textShadow: '0 2px 4px rgba(0,0,0,0.5), 0 0 30px rgba(255,215,0,0.4)',
              letterSpacing: '2px',
            }}
          >
            {participant.elo_before || 1000} ELO
          </Text>
        </Paper>
      </motion.div>
    );
  };

  return (
    <FullScreenWrapper>
      <Paper
        data-testid="versus-screen"
        style={{
          position: 'relative',
          width: '100%',
          height: '100%',
          background: `
            linear-gradient(135deg, #1a237e 0%, #311b92 40%, #4a148c 100%),
            radial-gradient(circle at 50% 50%, rgba(103, 58, 183, 0.3) 0%, transparent 60%)
          `,
          borderRadius: '16px',
          padding: '2rem',
          overflow: 'hidden',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)',
        }}
      >
        {/* Background stars */}
        {[...Array(6)].map((_, i) => (
          <motion.div
            key={i}
            variants={starVariants}
            animate="animate"
            style={{
              position: 'absolute',
              top: `${Math.random() * 100}%`,
              left: `${Math.random() * 100}%`,
              width: '120px',
              height: '120px',
              background: `
                radial-gradient(circle at center,
                  rgba(255,215,0,0.3) 0%,
                  rgba(255,215,0,0.1) 30%,
                  transparent 70%
                ),
                radial-gradient(circle at center,
                  rgba(255,255,255,0.2) 0%,
                  transparent 60%
                )
              `,
              filter: 'blur(4px)',
              transform: `rotate(${Math.random() * 360}deg)`,
              transformOrigin: 'center',
              pointerEvents: 'none',
              zIndex: 0,
              clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)',
            }}
          />
        ))}

        {/* Main content grid */}
        <Grid
          style={{
            width: '100%',
            maxWidth: '1400px',
            margin: '0 auto',
            position: 'relative',
            zIndex: 1,
          }}
        >
          {/* Left player */}
          <Grid.Col span={5} style={{ display: 'flex', justifyContent: 'flex-end' }}>
            {renderPlayerCard(participants[0], true)}
          </Grid.Col>

          {/* VS text */}
          <Grid.Col span={2} style={{ display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
            <motion.div
              variants={vsVariants}
              initial="initial"
              animate="animate"
              style={{
                display: 'flex',
                justifyContent: 'center',
                alignItems: 'center',
              }}
            >
              <Text
                fw={900}
                style={{
                  fontSize: 'clamp(3rem, 8vw, 6rem)',
                  color: '#FFD700',
                  textShadow:
                    '0 0 40px rgba(255,215,0,0.6), 0 0 80px rgba(255,215,0,0.4), 0 0 120px rgba(255,215,0,0.2)',
                  letterSpacing: '8px',
                  lineHeight: 1,
                }}
              >
                VS
              </Text>
            </motion.div>
          </Grid.Col>

          {/* Right player */}
          <Grid.Col span={5} style={{ display: 'flex', justifyContent: 'flex-start' }}>
            {renderPlayerCard(participants[1], false)}
          </Grid.Col>
        </Grid>
      </Paper>
    </FullScreenWrapper>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\BattleProgress.tsx
================================================================================

import React from 'react';
import { Card, Text, Progress } from '@mantine/core';

interface BattleProgressProps {
  roundsCompleted: number;
  totalRounds: number;
}

export const BattleProgress: React.FC<BattleProgressProps> = ({
  roundsCompleted,
  totalRounds,
}) => {
  return (
    <Card shadow="sm" p="xs" radius="sm" withBorder style={{ background: '#4169E1', color: 'white' }}>
      <Text size="md" fw={600} ta="center" mb="xs">
        Battle {roundsCompleted + 1} of {totalRounds}
      </Text>
      <Progress
        value={((roundsCompleted + 1) / totalRounds) * 100}
        size="md"
        radius="xl"
      />
    </Card>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\FlashcardDisplay.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { Card, Text, Stack, Group, Box, Tooltip, ActionIcon } from '@mantine/core';
import { motion } from 'framer-motion';
import { IconRefresh } from '@tabler/icons-react';
import { Flashcard } from '../../../types';

interface FlashcardDisplayProps {
  flashcard: Flashcard;
}

export const FlashcardDisplay: React.FC<FlashcardDisplayProps> = ({
  flashcard,
}) => {
  const [isFlipped, setIsFlipped] = useState(false);

  const handleFlip = useCallback(() => {
    setIsFlipped((prev) => !prev);
  }, []);

  const getFontSize = useCallback((text: string) => {
    const length = text.length;
    if (length > 200) return 'min(7vh, 64px)';
    if (length > 100) return 'min(9vh, 80px)';
    if (length > 50) return 'min(11vh, 96px)';
    return 'min(13vh, 112px)';
  }, []);

  const sharedTextStyle = {
    flexGrow: 1,
    wordBreak: 'break-word' as const,
    maxHeight: '100%',
    overflowY: 'auto' as const,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 'min(2vh, 0.5rem)',
    lineHeight: 1.2,
    width: '100%',
    height: '100%'
  };

  return (
    <Box
      style={{
        perspective: '1000px',
        width: '100%',
        height: '100%',
        position: 'relative',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center'
      }}
    >
      <motion.div
        style={{
          width: '100%',
          height: '100%',
          position: 'absolute',
          transformStyle: 'preserve-3d',
          transition: 'transform 0.8s ease',
          transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)',
        }}
      >
        {/* Front side: question */}
        <motion.div
          style={{
            width: '100%',
            height: '100%',
            position: 'absolute',
            backfaceVisibility: 'hidden',
          }}
        >
          <Card
            shadow="sm"
            p={{ base: 'xs', sm: 'md' }}
            radius="sm"
            withBorder
            style={{
              width: '100%',
              height: '100%',
              background: 'linear-gradient(135deg, #ff6b6b 0%, #ff4444 100%)',
              color: '#fff',
              boxSizing: 'border-box',
              cursor: 'pointer',
              position: 'relative',
              borderRadius: 'min(2vh, 12px)',
              boxShadow: '0 8px 16px rgba(0,0,0,0.15)',
              border: '1px solid rgba(255,255,255,0.1)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center'
            }}
            onClick={handleFlip}
          >
            <Text
              size={getFontSize(flashcard.question)}
              fw={700}
              ta="center"
              style={{
                ...sharedTextStyle,
                textShadow: '0 1px 2px rgba(0,0,0,0.2)',
              }}
            >
              {flashcard.question}
            </Text>
            <Tooltip label="Flip to see Answer" withArrow position="bottom">
              <ActionIcon
                variant="subtle"
                color="gray.0"
                style={{
                  position: 'absolute',
                  bottom: '5px',
                  right: '5px',
                  opacity: 0.7,
                }}
              >
                <IconRefresh size={16} />
              </ActionIcon>
            </Tooltip>
          </Card>
        </motion.div>

        {/* Back side: answer */}
        <motion.div
          style={{
            width: '100%',
            height: '100%',
            position: 'absolute',
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)',
          }}
        >
          <Card
            shadow="sm"
            p={{ base: 'xs', sm: 'md' }}
            radius="sm"
            withBorder
            style={{
              width: '100%',
              height: '100%',
              background: 'linear-gradient(135deg, #66bb6a 0%, #4CAF50 100%)',
              color: '#fff',
              boxSizing: 'border-box',
              cursor: 'pointer',
              position: 'relative',
              borderRadius: 'min(2vh, 12px)',
              boxShadow: '0 8px 16px rgba(0,0,0,0.15)',
              border: '1px solid rgba(255,255,255,0.1)',
              display: 'flex',
              flexDirection: 'column',
              justifyContent: 'center'
            }}
            onClick={handleFlip}
          >
            <Text
              size={getFontSize(flashcard.answer)}
              fw={700}
              ta="center"
              style={{
                ...sharedTextStyle,
                textShadow: '0 1px 2px rgba(0,0,0,0.2)',
              }}
            >
              {flashcard.answer}
            </Text>
            <Tooltip label="Flip to see Question" withArrow position="bottom">
              <ActionIcon
                variant="subtle"
                color="gray.0"
                style={{
                  position: 'absolute',
                  bottom: '5px',
                  right: '5px',
                  opacity: 0.7,
                }}
              >
                <IconRefresh size={16} />
              </ActionIcon>
            </Tooltip>
          </Card>
        </motion.div>
      </motion.div>
    </Box>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\index.ts
================================================================================

export { BattleProgress } from './BattleProgress';
export { FlashcardDisplay } from './FlashcardDisplay';
export { PlayerProfile } from './PlayerProfile';
export { WinnerSelection } from './WinnerSelection';



================================================================================
File: frontend\src\components\arena\battle-card\PlayerProfile.tsx
================================================================================

import React from 'react';
import { Stack, Avatar, Text, Badge, Box } from '@mantine/core';
import { motion } from 'framer-motion';
import { Student } from '../../../types';

interface PlayerProfileProps {
  player: Student;
  elo: number;
  colorGradient: { from: string; to: string };
}

export const PlayerProfile: React.FC<PlayerProfileProps> = ({
  player,
  elo,
  colorGradient,
}) => {
  return (
    <Stack align="center" gap={4} style={{ flex: 1 }}>
      <Avatar
        src={player.avatar_url || undefined}
        alt={player.name}
        radius="xl"
        size={48}
        style={{
          border: `2px solid ${colorGradient.from}`,
        }}
      >
        {(!player.avatar_url && player.name) ? player.name.charAt(0) : ''}
      </Avatar>
      <Text size="md" fw={600}>
        {player.name}
      </Text>
      <Text size="sm" c="dimmed">
        ELO: {elo} • W/L: {player.wins}/{player.losses}
      </Text>
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\WinnerSelection.tsx
================================================================================

import React from 'react';
import { Card, Text, Group, Button } from '@mantine/core';
import { motion } from 'framer-motion';
import { IconSword, IconTrophy } from '@tabler/icons-react';
import { Badge } from '@mantine/core';
import { Student } from '../../../types';

interface WinnerSelectionProps {
  player1: Student;
  player2: Student;
  onSelectWinner: (winnerIds: string[]) => void;
  isLoading?: boolean;
  canPickWinner: boolean;
}

export const WinnerSelection: React.FC<WinnerSelectionProps> = ({
  player1,
  player2,
  onSelectWinner,
  isLoading = false,
  canPickWinner,
}) => {
  return (
    <Card shadow="sm" p="xs" radius="sm" withBorder>
      <Group grow gap="xs">
        <Button
          variant="filled"
          color="pink"
          data-testid={`select-winner-${player1.id}`}
          onClick={() => onSelectWinner([player1.id])}
          disabled={!canPickWinner || isLoading}
          size="sm"
        >
          Winner
        </Button>
        <Button
          variant="filled"
          color="pink"
          data-testid={`select-winner-${player2.id}`}
          onClick={() => onSelectWinner([player2.id])}
          disabled={!canPickWinner || isLoading}
          size="sm"
        >
          Winner
        </Button>
      </Group>
    </Card>
  );
};



================================================================================
File: frontend\src\components\arena\screens\BattleScreen.tsx
================================================================================

import React from 'react';
import { Stack, Paper } from '@mantine/core';
import { ErrorAlert } from '../../shared/ErrorAlert';
import { ErrorBoundary } from '../../shared/ErrorBoundary';
import { ArenaBattleCard } from '../ArenaBattleCard';
import { Student, Flashcard } from '../../../types';
import { findMatchPlayers } from '../../../utils/playerUtils';
import { FullScreenWrapper } from './FullScreenWrapper';

interface BattleScreenProps {
  currentMatch: {
    player1_id: string;
    player2_id: string;
    player1_elo_before: number;
    player2_elo_before: number;
  } | null;
  currentFlashcard: Flashcard | null;
  students: Student[];
  arenaSession: {
    rounds_completed: number;
    num_rounds: number;
  } | null;
  onSelectWinner: (winnerIds: string[]) => void;
  onReset: () => void;
  isLoading: boolean;
  canPickWinner: boolean;
}

export const BattleScreen: React.FC<BattleScreenProps> = ({
  currentMatch,
  currentFlashcard,
  students,
  arenaSession,
  onSelectWinner,
  onReset,
  isLoading,
  canPickWinner,
}) => {
  if (!currentMatch || !currentFlashcard) {
    return (
      <FullScreenWrapper>
        <Paper
          p="xl"
          radius="lg"
          style={{
            background: 'rgba(255, 255, 255, 0.07)',
            backdropFilter: 'blur(12px)',
            maxWidth: '600px',
            width: '100%',
          }}
        >
          <ErrorAlert error="Battle data not found" onRetry={onReset} />
        </Paper>
      </FullScreenWrapper>
    );
  }

  const playersResult = findMatchPlayers(
    students,
    currentMatch.player1_id,
    currentMatch.player2_id
  );

  if (playersResult instanceof Error) {
    return (
      <FullScreenWrapper>
        <Paper
          p="xl"
          radius="lg"
          style={{
            background: 'rgba(255, 255, 255, 0.07)',
            backdropFilter: 'blur(12px)',
            maxWidth: '600px',
            width: '100%',
          }}
        >
          <ErrorAlert error={playersResult.message} onRetry={onReset} />
        </Paper>
      </FullScreenWrapper>
    );
  }

  const { player1, player2 } = playersResult;

  return (
    <ErrorBoundary 
      fallback={
        <FullScreenWrapper>
          <Paper
            p="xl"
            radius="lg"
            style={{
              background: 'rgba(255, 255, 255, 0.07)',
              backdropFilter: 'blur(12px)',
              maxWidth: '600px',
              width: '100%',
            }}
          >
            <ErrorAlert error="Failed to display battle" onRetry={onReset} />
          </Paper>
        </FullScreenWrapper>
      }
    >
      <FullScreenWrapper>
        <Stack
          align="center"
          justify="center"
          style={{
            width: '100%',
            height: '100%',
            position: 'relative',
            padding: 0,
            overflow: 'hidden'
          }}
        >
          <ArenaBattleCard
            flashcard={currentFlashcard}
            player1={player1}
            player2={player2}
            roundsCompleted={arenaSession?.rounds_completed || 0}
            totalRounds={arenaSession?.num_rounds || 0}
            onSelectWinner={onSelectWinner}
            player1ELO={currentMatch.player1_elo_before}
            player2ELO={currentMatch.player2_elo_before}
            isLoading={isLoading}
            canPickWinner={canPickWinner}
          />
        </Stack>
      </FullScreenWrapper>
    </ErrorBoundary>
  );
};


================================================================================
File: frontend\src\components\arena\screens\FinalResultScreen.tsx
================================================================================

import React from 'react';
import { Stack } from '@mantine/core';
import { Student } from '../../../types';
import { ErrorAlert } from '../../shared/ErrorAlert';
import { ErrorBoundary } from '../../shared/ErrorBoundary';
import { ArenaResultScreen } from '../ArenaResultScreen';

interface FinalResultScreenProps {
  arenaSession: {
    participants: any[];
  } | null;
  students: Student[];
  onReset: () => void;
}

export const FinalResultScreen: React.FC<FinalResultScreenProps> = ({
  arenaSession,
  students,
  onReset,
}) => {
  if (!arenaSession) {
    return <ErrorAlert error="Session data not found" onRetry={onReset} />;
  }

  return (
    <ErrorBoundary fallback={<ErrorAlert error="Failed to display results" onRetry={onReset} />}>
      <Stack gap="md">
        <ArenaResultScreen
          results={arenaSession.participants.map(participant => {
            const student = students.find(s => s.id === participant.student_id);
            return {
              ...participant,
              avatar_url: student?.avatar_url
            };
          })}
          onFinish={onReset}
        />
      </Stack>
    </ErrorBoundary>
  );
};


================================================================================
File: frontend\src\components\arena\screens\FullScreenWrapper.tsx
================================================================================

import React, { ReactNode } from 'react';
import { Stack, MantineTheme } from '@mantine/core';

interface FullScreenWrapperProps {
  children: ReactNode;
}

export function FullScreenWrapper({ children }: FullScreenWrapperProps) {
  return (
    <Stack
      justify="center"
      align="center"
      styles={(theme: MantineTheme) => ({
        root: {
          flex: 1,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          justifyContent: 'center',
          overflow: 'hidden',
          gap: theme.spacing.md,
          width: '100%',
          height: '100%',
          padding: theme.spacing.lg,
        },
      })}
    >
      {children}
    </Stack>
  );
}


================================================================================
File: frontend\src\components\arena\screens\RoundResultScreen.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Global, css } from '@emotion/react';
import {
  Card,
  Text,
  Stack,
  Title,
  Grid,
  Group,
  Avatar,
  Badge,
  Button,
  Box,
  useMantineTheme,
} from '@mantine/core';
import { IconArrowUp, IconArrowDown, IconConfetti, IconCrown } from '@tabler/icons-react';
import { Student, ArenaMatch, StudentAchievementResponse } from '../../../types';
import { getStudentAchievements } from '../../../achievements/getStudentAchievements';
import { FullScreenWrapper } from './FullScreenWrapper';

interface RoundResultScreenProps {
  currentMatch: ArenaMatch;
  students: Student[];
  onNextRound: () => void;
  onReset: () => void;
}

export const RoundResultScreen: React.FC<RoundResultScreenProps> = ({
  currentMatch,
  students,
  onNextRound,
  onReset,
}) => {
  const theme = useMantineTheme();

  // State for achievements
  const [p1Achievements, setP1Achievements] = useState<StudentAchievementResponse[]>([]);
  const [p2Achievements, setP2Achievements] = useState<StudentAchievementResponse[]>([]);

  // Identify each player from the students array
  const player1 = students.find((s) => s.id === currentMatch.player1_id);
  const player2 = students.find((s) => s.id === currentMatch.player2_id);

  // Fetch achievements for both players
  useEffect(() => {
    async function fetchPlayerAchievements() {
      if (!player1 || !player2) return;
      try {
        const [p1Response, p2Response] = await Promise.all([
          getStudentAchievements(player1.id),
          getStudentAchievements(player2.id)
        ]);
        setP1Achievements(p1Response);
        setP2Achievements(p2Response);
      } catch (err) {
        console.error('Failed to fetch achievements:', err);
      }
    }
    void fetchPlayerAchievements();
  }, [player1, player2]);

  // Safeguard
  if (!player1 || !player2) {
    return (
      <FullScreenWrapper>
        <Card
          p="xl"
          radius="lg"
          style={{
            background: 'rgba(255, 255, 255, 0.07)',
            backdropFilter: 'blur(12px)',
            maxWidth: '600px',
            width: '100%',
          }}
        >
          <Stack align="center" gap="md">
            <Text c="red">Players not found. Something went wrong.</Text>
            <Button onClick={onReset}>Return</Button>
          </Stack>
        </Card>
      </FullScreenWrapper>
    );
  }

  // ELO changes
  const p1Change =
    (currentMatch.player1_elo_after || 0) - currentMatch.player1_elo_before;
  const p2Change =
    (currentMatch.player2_elo_after || 0) - currentMatch.player2_elo_before;

  // Who is the winner? Possibly multiple winners
  const isP1Winner = currentMatch.winner_ids?.includes(player1.id) || false;
  const isP2Winner = currentMatch.winner_ids?.includes(player2.id) || false;


  // Animations
  const containerVariants = {
    hidden: { opacity: 0, scale: 0.9 },
    visible: {
      opacity: 1,
      scale: 1,
      transition: { duration: 0.4, ease: 'easeOut' },
    },
    exit: { opacity: 0, scale: 0.9 },
  };

  // Shared styling for winner card background
  const winnerStyle = {
    background: 'linear-gradient(60deg, var(--mantine-color-yellow-4), var(--mantine-color-orange-4))',
    color: 'var(--mantine-color-dark-9)',
    boxShadow: '0 0 30px rgba(255, 215, 0, 0.3)',
  };

  const loserStyle = {
    background: 'linear-gradient(60deg, var(--mantine-color-gray-2), var(--mantine-color-gray-3))',
    color: 'var(--mantine-color-dark-7)',
    boxShadow: '0 0 20px rgba(0, 0, 0, 0.1)',
  };

  const getCardStyle = (isWinner: boolean) => (isWinner ? winnerStyle : loserStyle);

  // ELO Change UI
  const ELOChangeDisplay: React.FC<{ change: number }> = ({ change }) => {
    const isPositive = change >= 0;
    return (
      <Group gap="xs">
        {isPositive ? (
          <IconArrowUp size={18} color={theme.colors.green[5]} />
        ) : (
          <IconArrowDown size={18} color={theme.colors.red[5]} />
        )}
        <Text
          fw={800}
          size="xl"
          c={isPositive ? 'green.3' : 'red.3'}
          style={{
            textShadow: isPositive ? '0 0 4px rgba(0,255,0,0.5)' : '0 0 4px rgba(255,0,0,0.5)',
            background: 'rgba(0,0,0,0.25)',
            padding: '4px 12px',
            borderRadius: '6px',
            fontSize: 'clamp(1.2rem, 3vh, 1.8rem)'
          }}
        >
          {isPositive ? `+${change}` : change}
        </Text>
      </Group>
    );
  };

  return (
    <FullScreenWrapper>
      <Global
        styles={css`
          @keyframes glow {
            from {
              box-shadow: 0 0 20px rgba(255,215,0,0.4);
            }
            to {
              box-shadow: 0 0 40px rgba(255,215,0,0.7);
            }
          }
        `}
      />
      <AnimatePresence mode="sync">
        <motion.div
          key="round-result-screen"
          variants={containerVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
          style={{
            width: '100%',
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center'
          }}
        >
          <Card
            p={{ base: 'md', sm: 'lg', md: 'xl' }}
            radius="md"
            shadow="xl"
            style={{
              position: 'relative',
              overflow: 'hidden',
              background: 'linear-gradient(45deg, var(--mantine-color-violet-9), var(--mantine-color-indigo-9))',
              color: '#fff',
              height: '100%',
              display: 'flex',
              flexDirection: 'column'
            }}
          >
            {/* Rotating Confetti Icon in BG */}
            <motion.div
              initial={{ rotate: 0 }}
              animate={{ rotate: 360 }}
              transition={{
                duration: 30,
                repeat: Infinity,
                ease: 'linear',
              }}
              style={{
                position: 'absolute',
                top: '-100px',
                right: '-100px',
                opacity: 0.2,
              }}
            >
              <IconConfetti size={200} />
            </motion.div>

            <Stack gap="md" align="center" justify="center" style={{ height: '100%' }}>
              {/* Title */}
              <motion.div
                initial={{ y: -30, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ type: 'spring', stiffness: 100, damping: 15 }}
              >
                <Title
                  order={2}
                  ta="center"
                  style={{
                    fontSize: 'clamp(1.5rem, 5vw, 2.25rem)',
                    textTransform: 'uppercase',
                    textShadow: '0 2px 15px rgba(0,0,0,0.5)',
                  }}
                >
                  Round Complete!
                </Title>
              </motion.div>

              {/* Round Info */}
              <motion.div
                initial={{ y: 10, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ type: 'spring', stiffness: 100, damping: 15, delay: 0.1 }}
              >
                <Text size="md" c="cyan.2" fw={500}>
                  Rounds Completed: {currentMatch.rounds_completed}/{currentMatch.num_rounds}
                </Text>
              </motion.div>

              {/* Participants Grid */}
              <Grid
                gutter={{ base: 'md', sm: 'lg', md: 'xl' }}
                style={{
                  width: '100%',
                  flex: 1,
                  display: 'flex',
                  alignItems: 'stretch'
                }}
                align="stretch"
                justify="center"
              >
                {[{ player: player1, isWinner: isP1Winner, eloChange: p1Change, achievements: p1Achievements },
                  { player: player2, isWinner: isP2Winner, eloChange: p2Change, achievements: p2Achievements }]
                  .map(({ player, isWinner, eloChange, achievements }, index) => (
                    <Grid.Col
                      key={player.id}
                      span={6}
                      style={{ display: 'flex', justifyContent: 'center' }}
                    >
                      <motion.div
                        initial={{ scale: 0.8, opacity: 0 }}
                        animate={{
                          scale: 1,
                          opacity: 1
                        }}
                        transition={{
                          type: 'spring',
                          stiffness: 100,
                          damping: 15,
                          delay: 0.2 + index * 0.1
                        }}
                        style={{ 
                          width: '100%', 
                          maxWidth: 400,
                          animation: isWinner ? 'glow 1.5s ease-in-out infinite alternate' : undefined
                        }}
                      >
                        <Card
                          p={{ base: 'md', sm: 'lg', md: 'xl' }}
                          radius="lg"
                          withBorder
                          style={{
                            ...getCardStyle(isWinner),
                            position: 'relative',
                            overflow: 'hidden',
                            height: '100%',
                            display: 'flex',
                            flexDirection: 'column'
                          }}
                        >
                          <Stack gap="md" align="center" style={{ flex: 1, justifyContent: 'space-around' }}>
                            {/* Crown for winner */}
                            {isWinner && (
                              <Box mb={-20} style={{ position: 'relative', zIndex: 2 }}>
                                <IconCrown
                                  size={48}
                                  style={{
                                    color: theme.colors.yellow[4],
                                    filter: 'drop-shadow(0 2px 4px rgba(0,0,0,0.2))',
                                  }}
                                />
                              </Box>
                            )}
                            {/* AVATAR + NAME */}
                            <Avatar
                              src={player.avatar_url || undefined}
                              alt={player.name}
                              size="clamp(80px, 20vh, 160px)"
                              radius="50%"
                              style={{
                                border: `2px solid ${
                                  isWinner ? theme.colors.yellow[4] : '#fff'
                                }`,
                                boxShadow: isWinner
                                  ? '0 0 10px rgba(255,215,0,0.5)'
                                  : '0 0 8px rgba(255,255,255,0.2)',
                              }}
                            >
                              {(!player.avatar_url && player.name)
                                ? player.name.charAt(0)
                                : ''}
                            </Avatar>

                            <Title
                              order={3}
                              style={{
                                textAlign: 'center',
                                fontSize: 'clamp(1.5rem, 4vh, 2.2rem)',
                                lineHeight: 1.2,
                                marginTop: '2vh',
                                marginBottom: '1vh',
                                fontWeight: 700,
                                color: isWinner ? 'var(--mantine-color-dark-9)' : 'var(--mantine-color-dark-7)',
                                textShadow: isWinner ? '0 2px 4px rgba(0,0,0,0.1)' : 'none',
                                letterSpacing: '0.5px'
                              }}
                            >
                              {player.name}
                            </Title>

                            {/* Winner / Loser badge */}
                            {isWinner ? (
                              <Badge
                                size="lg"
                                variant="filled"
                                color="green"
                                style={{
                                  padding: 'clamp(0.8rem, 2vh, 1.2rem) clamp(1.2rem, 3vh, 2rem)',
                                  fontSize: 'clamp(1.4rem, 3.5vh, 2rem)',
                                  fontWeight: 700,
                                  textTransform: 'uppercase',
                                  letterSpacing: '1px',
                                  boxShadow: '0 0 20px rgba(0, 255, 0, 0.2)',
                                  color: 'var(--mantine-color-green-0)'
                                }}
                              >
                                Winner!
                              </Badge>
                            ) : (
                              <Badge
                                size="lg"
                                variant="filled"
                                color="red"
                                style={{
                                  padding: 'clamp(0.8rem, 2vh, 1.2rem) clamp(1.2rem, 3vh, 2rem)',
                                  fontSize: 'clamp(1.4rem, 3.5vh, 2rem)',
                                  fontWeight: 600,
                                  textTransform: 'uppercase',
                                  letterSpacing: '1px',
                                  color: 'var(--mantine-color-red-0)',
                                  boxShadow: '0 0 20px rgba(255, 0, 0, 0.2)'
                                }}
                              >
                                Defeated
                              </Badge>
                            )}

                            {/* ELO Ratings */}
                            <Group gap="md" mt="2vh">
                              <Group
                                style={{
                                  background: 'rgba(0,0,0,0.15)',
                                  padding: '0.8rem 1.2rem',
                                  borderRadius: '12px',
                                  boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                                  backdropFilter: 'blur(4px)'
                                }}
                              >
                                <Text fw={700} style={{
                                  fontSize: 'clamp(1.1rem, 2.5vh, 1.5rem)',
                                  color: isWinner ? 'var(--mantine-color-dark-9)' : 'var(--mantine-color-dark-7)'
                                }}>
                                  ELO: {player.elo_rating}
                                </Text>
                              </Group>
                              <Box style={{ transform: 'scale(clamp(1.2, 2vh, 1.6))' }}>
                                <ELOChangeDisplay change={eloChange} />
                              </Box>
                            </Group>

                            {/* Achievements */}
                            {achievements.length > 0 && (
                              <Stack gap="md" align="center" mt="2vh">
                                <Text fw={600} style={{ fontSize: 'clamp(1rem, 2.5vh, 1.4rem)' }}>
                                  Achievements:
                                </Text>
                                <Group gap="xs">
                                  {achievements.map((achievementRecord: StudentAchievementResponse) => (
                                    <Badge
                                      key={achievementRecord.id}
                                      size="md"
                                      variant="filled"
                                      color="violet"
                                    >
                                      {achievementRecord.achievement.title}
                                    </Badge>
                                  ))}
                                </Group>
                              </Stack>
                            )}
                          </Stack>
                        </Card>
                      </motion.div>
                    </Grid.Col>
                  ))}
              </Grid>

              {/* Buttons */}
              <motion.div
                initial={{ y: 20, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ delay: 0.5, type: 'spring', stiffness: 100, damping: 15 }}
              >
                <Group mt="xl" justify="center">
                  <Button
                    variant="gradient"
                    gradient={{ from: 'cyan.5', to: 'blue.5' }}
                    size="lg"
                    onClick={onNextRound}
                  >
                    Next Round
                  </Button>
                  <Button variant="light" color="gray" size="lg" onClick={onReset}>
                    Exit Arena
                  </Button>
                </Group>
              </motion.div>
            </Stack>
          </Card>
        </motion.div>
      </AnimatePresence>
    </FullScreenWrapper>
  );
};



================================================================================
File: frontend\src\components\arena\screens\VersusScreenWrapper.tsx
================================================================================

import React from 'react';
import { ErrorAlert } from '../../shared/ErrorAlert';
import { ErrorBoundary } from '../../shared/ErrorBoundary';
import { VersusScreen } from '../VersusScreen';
import { Student } from '../../../types';
import { findMatchPlayers, createParticipantData } from '../../../utils/playerUtils';

interface VersusScreenWrapperProps {
  currentMatch: {
    player1_id: string;
    player2_id: string;
    player1_elo_before: number;
    player2_elo_before: number;
  } | null;
  students: Student[];
  onAnimationComplete: () => void;
  onReset: () => void;
}

export const VersusScreenWrapper: React.FC<VersusScreenWrapperProps> = ({
  currentMatch,
  students,
  onAnimationComplete,
  onReset,
}) => {
  if (!currentMatch) {
    return <ErrorAlert error="Match data not found" onRetry={onReset} />;
  }

  const playersResult = findMatchPlayers(
    students,
    currentMatch.player1_id,
    currentMatch.player2_id
  );

  if (playersResult instanceof Error) {
    return <ErrorAlert error={playersResult.message} onRetry={onReset} />;
  }

  const { player1, player2 } = playersResult;

  return (
    <ErrorBoundary fallback={<ErrorAlert error="Failed to display versus screen" onRetry={onReset} />}>
      <VersusScreen
        participants={[
          createParticipantData(player1, currentMatch.player1_elo_before),
          createParticipantData(player2, currentMatch.player2_elo_before),
        ]}
        onAnimationComplete={onAnimationComplete}
      />
    </ErrorBoundary>
  );
};


================================================================================
File: frontend\src\components\arena\setup\ArenaHeader.tsx
================================================================================

import React from 'react';
import { Box, Text, MantineTheme } from '@mantine/core';

export const ArenaHeader: React.FC = () => {
  return (
    <Box
      style={{
        position: 'relative',
        width: 400,
        height: 120
      }}
    >
      <Box
        style={{
          position: 'absolute',
          top: -20,
          left: '50%',
          transform: 'translateX(-50%)',
          width: 120,
          height: 120,
          background: 'radial-gradient(circle, rgba(112, 72, 232, 0.3) 0%, transparent 70%)',
          filter: 'blur(20px)',
          zIndex: 0
        }}
      />
      <Text
        component="h1"
        size="3rem"
        fw={900}
        variant="gradient"
        gradient={{ from: 'violet', to: 'indigo', deg: 45 }}
        styles={(theme: MantineTheme) => ({
          root: {
            textAlign: 'center',
            textTransform: 'uppercase',
            letterSpacing: '2px',
            textShadow: '0 2px 10px rgba(0,0,0,0.3)',
            position: 'relative',
            zIndex: 1
          }
        })}
      >
        Flashcard Battle Setup
      </Text>
    </Box>
  );
};


================================================================================
File: frontend\src\components\arena\setup\ArenaPackSelect.tsx
================================================================================

import React from 'react';
import { Select } from '@mantine/core';
import { inputStyles } from './styles';

interface ArenaPackSelectProps {
  packSelectData: { value: string; label: string }[];
  selectedPackId: string;
  onPackChange: (value: string | null) => void;
  error?: string;
}

export const ArenaPackSelect: React.FC<ArenaPackSelectProps> = ({
  packSelectData,
  selectedPackId,
  onPackChange,
  error
}) => {
  return (
    <Select
      label="Select a Flashcard Pack"
      placeholder="Choose your battle deck"
      data={packSelectData}
      value={selectedPackId}
      onChange={onPackChange}
      error={error}
      required
      size="lg"
      styles={inputStyles}
    />
  );
};


================================================================================
File: frontend\src\components\arena\setup\ArenaPlayerSelect.tsx
================================================================================

import React from 'react';
import { SimpleGrid, Card, Group, Avatar, Stack, Text, Badge, Alert, Box } from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import { Student } from '../../../types';
import { playerCardStyles } from './styles';

interface ArenaPlayerSelectProps {
  students: Student[];
  selectedPlayerIds: string[];
  onTogglePlayer: (id: string) => void;
}

export const ArenaPlayerSelect: React.FC<ArenaPlayerSelectProps> = ({
  students,
  selectedPlayerIds,
  onTogglePlayer
}) => {
  return (
    <Box mt="xl">
      <Text
        fw={700}
        mb="md"
        size="lg"
        variant="gradient"
        gradient={{ from: 'violet', to: 'indigo', deg: 45 }}
      >
        Select Players (at least 2)
      </Text>
      {students.length === 0 ? (
        <Alert icon={<IconAlertCircle size={16} />} color="yellow">
          No students found. Please add some students first.
        </Alert>
      ) : (
        <SimpleGrid
          cols={{ base: 1, sm: 2, md: 3 }}
          spacing={{ base: 'sm', sm: 'md', md: 'lg' }}
          mt="lg"
        >
          {students.map((student: Student) => {
            const isSelected = selectedPlayerIds.includes(student.id);
            return (
              <Card
                key={student.id}
                onClick={() => onTogglePlayer(student.id)}
                shadow={isSelected ? 'lg' : 'md'}
                withBorder
                p="lg"
                style={{
                  cursor: 'pointer',
                  transform: isSelected ? 'translateY(-4px)' : 'none',
                  transition: 'all 0.2s ease'
                }}
                styles={(theme) => playerCardStyles(theme, isSelected)}
              >
                <Group>
                  <Avatar
                    radius="xl"
                    size={50}
                    src={student.avatar_url}
                    alt={student.name}
                  >
                    {(!student.avatar_url && student.name) ? student.name.charAt(0) : ''}
                  </Avatar>
                  <Stack gap="xs">
                    <Text size="lg" fw={700} c="white">{student.name}</Text>
                    <Badge
                      size="lg"
                      variant="gradient"
                      gradient={{ from: 'violet', to: 'indigo', deg: 45 }}
                    >
                      ELO: {student.elo_rating}
                    </Badge>
                  </Stack>
                </Group>
              </Card>
            );
          })}
        </SimpleGrid>
      )}
    </Box>
  );
};


================================================================================
File: frontend\src\components\arena\setup\ArenaRoundsInput.tsx
================================================================================

import React from 'react';
import { NumberInput } from '@mantine/core';
import { inputStyles } from './styles';

interface ArenaRoundsInputProps {
  numRounds: number;
  onRoundsChange: (value: number | string) => void;
  error?: string;
}

export const ArenaRoundsInput: React.FC<ArenaRoundsInputProps> = ({
  numRounds,
  onRoundsChange,
  error
}) => {
  return (
    <NumberInput
      label="Number of Rounds"
      description="Choose how many rounds of battle (1-20)"
      min={1}
      max={20}
      value={numRounds}
      onChange={onRoundsChange}
      error={error}
      required
      size="lg"
      styles={inputStyles}
    />
  );
};


================================================================================
File: frontend\src\components\arena\setup\ArenaStartButton.tsx
================================================================================

import React from 'react';
import { Button } from '@mantine/core';
import { buttonStyles } from './styles';

interface ArenaStartButtonProps {
  onClick: () => void;
  isLoading?: boolean;
}

export const ArenaStartButton: React.FC<ArenaStartButtonProps> = ({
  onClick,
  isLoading = false
}) => {
  return (
    <Button
      onClick={onClick}
      variant="gradient"
      gradient={{ from: 'violet', to: 'indigo', deg: 45 }}
      loading={isLoading}
      size="xl"
      fullWidth
      mt="xl"
      styles={buttonStyles}
      data-testid="start-arena-button"
    >
      Start Arena Battle
    </Button>
  );
};


================================================================================
File: frontend\src\components\arena\setup\index.ts
================================================================================

export * from './ArenaHeader';
export * from './ArenaPackSelect';
export * from './ArenaRoundsInput';
export * from './ArenaPlayerSelect';
export * from './ArenaStartButton';


================================================================================
File: frontend\src\components\arena\setup\styles.ts
================================================================================

import { MantineTheme } from '@mantine/core';

export const containerStyles = (theme: MantineTheme) => ({
  root: {
    borderRadius: theme.radius.xl,
    background: `linear-gradient(165deg, ${theme.colors.dark[7]} 0%, ${theme.colors.dark[9]} 100%)`,
    boxShadow: `0 8px 32px rgba(0, 0, 0, 0.2)`,
    border: `1px solid ${theme.colors.dark[4]}`,
    position: 'relative' as const,
    overflow: 'hidden'
  }
});

export const paperStyles = (theme: MantineTheme) => ({
  root: {
    background: `linear-gradient(165deg, rgba(25, 26, 30, 0.8) 0%, rgba(15, 16, 20, 0.9) 100%)`,
    backdropFilter: 'blur(16px)',
    border: `1px solid rgba(149, 97, 255, 0.2)`,
    boxShadow: `0 8px 32px rgba(0, 0, 0, 0.2), inset 0 1px 1px rgba(255, 255, 255, 0.1)`,
    position: 'relative' as const,
    overflow: 'hidden',
    '&::before': {
      content: '""',
      position: 'absolute',
      top: 0,
      left: 0,
      right: 0,
      bottom: 0,
      background: 'radial-gradient(circle at top right, rgba(120, 100, 255, 0.1), transparent 70%)',
      pointerEvents: 'none'
    }
  }
});

export const inputStyles = (theme: MantineTheme) => ({
  label: {
    color: theme.white,
    fontSize: theme.fontSizes.lg,
    fontWeight: 600,
    marginBottom: theme.spacing.xs
  },
  input: {
    fontSize: theme.fontSizes.md,
    background: theme.colors.dark[7],
    border: `1px solid ${theme.colors.dark[4]}`,
    color: theme.white,
    '&:focus': {
      borderColor: theme.colors.violet[5]
    }
  },
  item: {
    '&[data-selected]': {
      '&, &:hover': {
        backgroundColor: theme.colors.violet[9],
        color: theme.white
      }
    }
  }
});

export const buttonStyles = (theme: MantineTheme) => ({
  root: {
    height: 56,
    fontSize: theme.fontSizes.lg,
    fontWeight: 700,
    boxShadow: theme.shadows.md,
    '&:hover': {
      boxShadow: theme.shadows.lg
    }
  }
});

export const playerCardStyles = (theme: MantineTheme, isSelected: boolean) => ({
  root: {
    backgroundColor: isSelected ? theme.colors.dark[6] : theme.colors.dark[7],
    borderColor: isSelected ? theme.colors.violet[5] : theme.colors.dark[4],
    '&:hover': {
      transform: 'translateY(-4px)',
      boxShadow: theme.shadows.lg
    }
  }
});


================================================================================
File: frontend\src\components\flashcards\FlashcardControls.tsx
================================================================================

import React, { useCallback, useMemo } from 'react';
import {
  Group,
  TextInput,
  Select,
  SegmentedControl,
  ActionIcon,
  Text,
  Popover,
} from '@mantine/core';
import {
  IconSearch,
  IconFilter,
  IconKeyboard,
  IconLayoutGrid,
  IconLayoutList,
} from '@tabler/icons-react';
import { DifficultyLevel } from '../../types';
import { ViewMode, AdvancedFilters } from '../../hooks/useFlashcardFilters';

interface FlashcardControlsProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  difficultyFilter: string;
  onDifficultyChange: (value: string) => void;
  viewMode: ViewMode;
  onViewModeChange: (value: ViewMode) => void;
  advancedFilters: AdvancedFilters;
  onShowAdvancedFilters: () => void;
  onShowKeyboardShortcuts: () => void;
}

export const FlashcardControls = React.memo(function FlashcardControls({
  searchQuery,
  onSearchChange,
  difficultyFilter,
  onDifficultyChange,
  viewMode,
  onViewModeChange,
  advancedFilters,
  onShowAdvancedFilters,
  onShowKeyboardShortcuts,
}: FlashcardControlsProps) {
  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    onSearchChange(e.currentTarget.value);
  }, [onSearchChange]);

  const handleDifficultyChange = useCallback((value: string | null) => {
    onDifficultyChange(value || 'all');
  }, [onDifficultyChange]);

  const handleViewModeChange = useCallback((value: string) => {
    onViewModeChange(value as ViewMode);
  }, [onViewModeChange]);

  const difficultyOptions = useMemo(() => [
    { value: 'all', label: 'All Difficulties' },
    { value: DifficultyLevel.EASY, label: 'Easy' },
    { value: DifficultyLevel.MEDIUM, label: 'Medium' },
    { value: DifficultyLevel.HARD, label: 'Hard' },
  ], []);

  const viewModeOptions = useMemo(() => [
    {
      value: 'grid',
      label: (
        <Group gap={4}>
          <IconLayoutGrid size={16} />
          <Text size="sm">Grid</Text>
        </Group>
      ),
    },
    {
      value: 'list',
      label: (
        <Group gap={4}>
          <IconLayoutList size={16} />
          <Text size="sm">List</Text>
        </Group>
      ),
    },
  ], []);

  const isFiltersActive = useMemo(() => 
    advancedFilters.dateRange[0] || 
    advancedFilters.successRateRange[0] !== 0 || 
    advancedFilters.usageRange[0] !== 0,
    [advancedFilters]
  );

  return (
    <Group justify="space-between" mb="md">
      <Group>
        <TextInput
          name="search"
          placeholder="Search flashcards..."
          value={searchQuery}
          onChange={handleSearchChange}
          leftSection={<IconSearch size={16} />}
          style={{ width: 300 }}
        />
        
        <Popover width={200} position="bottom" withArrow shadow="md">
          <Popover.Target>
            <ActionIcon
              variant="light"
              size="lg"
              onClick={onShowAdvancedFilters}
              aria-label="Advanced filters"
            >
              <IconFilter size={20} />
            </ActionIcon>
          </Popover.Target>
          <Popover.Dropdown>
            <Text size="sm">
              {isFiltersActive ? 'Filters active' : 'No filters active'}
            </Text>
          </Popover.Dropdown>
        </Popover>
      </Group>
      
      <Group>
        <ActionIcon
          variant="light"
          size="lg"
          onClick={onShowKeyboardShortcuts}
          aria-label="Keyboard shortcuts"
        >
          <IconKeyboard size={20} />
        </ActionIcon>
        
        <Select
          value={difficultyFilter}
          onChange={handleDifficultyChange}
          data={difficultyOptions}
          style={{ width: 150 }}
        />

        <SegmentedControl
          value={viewMode}
          onChange={handleViewModeChange}
          data={viewModeOptions}
        />
      </Group>
    </Group>
  );
});



================================================================================
File: frontend\src\components\flashcards\FlashcardEditor.tsx
================================================================================

import React, { useCallback, useState } from 'react';
import {
  Box,
  Button,
  Group,
  Paper,
  Select,
  Stack,
  Text,
  Textarea,
  rem,
} from '@mantine/core';
import { motion } from 'framer-motion';
import { IconDeviceFloppy, IconX } from '@tabler/icons-react';
import { DifficultyLevel, Flashcard } from '../../types';
import { useFlashcardStore } from '../../stores/flashcardStore';

interface FlashcardEditorProps {
  packId: string;
  flashcard?: Flashcard;
  onClose: () => void;
}

export function FlashcardEditor({
  packId,
  flashcard,
  onClose,
}: FlashcardEditorProps) {
  const { addFlashcard, updateFlashcard, loading, error } = useFlashcardStore();

  const [question, setQuestion] = useState<string>(flashcard?.question || '');
  const [answer, setAnswer] = useState<string>(flashcard?.answer || '');
  const [difficulty, setDifficulty] = useState<DifficultyLevel>(
    flashcard?.difficulty || DifficultyLevel.MEDIUM
  );

  const handleSave = useCallback(async () => {
    if (!question.trim() || !answer.trim()) {
      return;
    }

    const payload = {
      question,
      answer,
      pack_id: packId,
      difficulty,
    };

    try {
      if (flashcard?.id) {
        await updateFlashcard(flashcard.id, payload);
      } else {
        await addFlashcard(payload);
      }
      onClose();
    } catch (err) {
      console.error('Failed to save flashcard:', err);
    }
  }, [question, answer, difficulty, packId, flashcard, onClose, addFlashcard, updateFlashcard]);

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: 20 }}
      transition={{ duration: 0.2 }}
    >
      <Paper p="xl" radius="md" withBorder>
        <Stack gap="lg">
          <Box>
            <Text fw={500} size="sm" mb="xs">
              Question
            </Text>
            <Textarea
              placeholder="Type the question here..."
              minRows={6}
              autosize
              styles={{
                input: {
                  fontSize: rem(14),
                  lineHeight: 1.5,
                },
              }}
              value={question}
              onChange={(e) => setQuestion(e.currentTarget.value)}
            />
          </Box>

          <Box>
            <Text fw={500} size="sm" mb="xs">
              Answer
            </Text>
            <Textarea
              placeholder="Type the answer here..."
              minRows={6}
              autosize
              styles={{
                input: {
                  fontSize: rem(14),
                  lineHeight: 1.5,
                },
              }}
              value={answer}
              onChange={(e) => setAnswer(e.currentTarget.value)}
            />
          </Box>

          <Select
            label="Difficulty"
            value={difficulty}
            onChange={(val) => {
              if (val) {
                setDifficulty(val as DifficultyLevel);
              }
            }}
            data={[
              { value: DifficultyLevel.EASY, label: 'Easy' },
              { value: DifficultyLevel.MEDIUM, label: 'Medium' },
              { value: DifficultyLevel.HARD, label: 'Hard' },
            ]}
          />

          {error && (
            <Text color="red" size="sm">
              {error}
            </Text>
          )}

          <Group justify="flex-end" gap="sm">
            <Button
              variant="light"
              color="gray"
              onClick={onClose}
              leftSection={<IconX size={16} />}
            >
              Cancel
            </Button>
            <Button
              onClick={handleSave}
              loading={loading}
              leftSection={<IconDeviceFloppy size={16} />}
            >
              Save Flashcard
            </Button>
          </Group>
        </Stack>
      </Paper>
    </motion.div>
  );
}



================================================================================
File: frontend\src\components\flashcards\FlashcardForm.tsx
================================================================================

import React, { useCallback, useMemo } from 'react';
import { Modal } from '@mantine/core';
import { FlashcardEditor } from './FlashcardEditor';
import { Flashcard } from '../../types';

interface FlashcardFormProps {
  packId: string;
  flashcard?: Flashcard;
  opened: boolean;
  onClose: () => void;
}

export const FlashcardForm = React.memo(function FlashcardForm({ 
  packId, 
  flashcard, 
  opened, 
  onClose 
}: FlashcardFormProps) {
  const handleClose = useCallback(() => {
    onClose();
  }, [onClose]);

  const modalTitle = useMemo(() => 
    flashcard ? 'Edit Flashcard' : 'Create New Flashcard',
    [flashcard]
  );
  return (
    <Modal
      opened={opened}
      onClose={handleClose}
      title={modalTitle}
      size="xl"
    >
      <FlashcardEditor
        packId={packId}
        flashcard={flashcard}
        onClose={handleClose}
      />
    </Modal>
  );
});



================================================================================
File: frontend\src\components\flashcards\FlashcardGrid.tsx
================================================================================

import React, { useCallback, useMemo, useState } from 'react';
import {
  Grid,
  Card,
  Text,
  Group,
  ActionIcon,
  Progress,
  Tooltip,
  Stack,
  Box,
  Badge,
  rem,
} from '@mantine/core';
import { IconChartBar, IconEdit, IconRefresh } from '@tabler/icons-react';
import { motion, AnimatePresence } from 'framer-motion';
import { Flashcard, DifficultyLevel } from '../../types';

const DIFFICULTY_COLORS = {
  [DifficultyLevel.EASY]: 'green',
  [DifficultyLevel.MEDIUM]: 'yellow',
  [DifficultyLevel.HARD]: 'red',
};

interface FlashcardGridProps {
  flashcards: Flashcard[];
  onEdit: (flashcard: Flashcard) => void;
}

export const FlashcardGrid = React.memo(function FlashcardGrid({
  flashcards,
  onEdit,
}: FlashcardGridProps) {
  const [flippedCards, setFlippedCards] = useState<{ [id: string]: boolean }>({});

  const handleFlip = useCallback((id: string) => {
    setFlippedCards((prev) => ({
      ...prev,
      [id]: !prev[id],
    }));
  }, []);

  const handleEdit = useCallback(
    (card: Flashcard) => {
      onEdit(card);
    },
    [onEdit]
  );

  const cardVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1 },
  };

  const renderFlashcard = (card: Flashcard) => {
    const { id, question, answer, difficulty, success_rate, times_used } = card;
    const isFlipped = flippedCards[id] === true;

    const successRatePercentage = (success_rate * 100).toFixed(1);
    const progressColor =
      success_rate > 0.7 ? 'green' : success_rate > 0.4 ? 'yellow' : 'red';

    return (
      <Grid.Col key={id} span={{ base: 12, sm: 6, md: 4 }}>
        <Box
          style={{
            perspective: '1000px',
            width: '100%',
            height: '400px',
            position: 'relative',
          }}
        >
          <motion.div
            style={{
              width: '100%',
              height: '100%',
              position: 'absolute',
              transformStyle: 'preserve-3d',
              transition: 'transform 0.8s ease',
              transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)',
            }}
          >
            <motion.div
              key={`${id}-front`}
              variants={cardVariants}
              initial="hidden"
              animate="visible"
              exit="hidden"
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                borderRadius: rem(8),
                overflow: 'hidden',
              }}
            >
              <Card
                shadow="sm"
                padding="lg"
                radius="md"
                withBorder
                style={{ height: '100%', boxSizing: 'border-box' }}
              >
                <Stack gap="md" style={{ height: '100%' }}>
                  <Group justify="space-between">
                    <Badge color={DIFFICULTY_COLORS[difficulty]}>
                      {difficulty}
                    </Badge>
                    <ActionIcon variant="light" onClick={() => handleEdit(card)}>
                      <IconEdit size={16} />
                    </ActionIcon>
                  </Group>

                  <Stack justify="center" style={{ flex: 1 }}>
                    <Text size="lg" fw={700} ta="center" lineClamp={3}>
                      {question}
                    </Text>
                  </Stack>

                  <Tooltip label="Success Rate" position="bottom">
                    <Group gap="xs">
                      <IconChartBar size={16} />
                      <Text size="sm">{successRatePercentage}%</Text>
                      <Progress
                        value={Number(successRatePercentage)}
                        color={progressColor}
                        size="sm"
                        style={{ flex: 1 }}
                      />
                    </Group>
                  </Tooltip>
                  <Text size="xs" color="dimmed">
                    Used {times_used} times
                  </Text>

                  <ActionIcon
                    variant="default"
                    onClick={() => handleFlip(id)}
                    style={{ marginTop: 'auto' }}
                  >
                    <IconRefresh size={16} />
                  </ActionIcon>
                </Stack>
              </Card>
            </motion.div>

            <motion.div
              key={`${id}-back`}
              variants={cardVariants}
              initial="hidden"
              animate="visible"
              exit="hidden"
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                transform: 'rotateY(180deg)',
                borderRadius: rem(8),
                overflow: 'hidden',
              }}
            >
              <Card
                shadow="sm"
                padding="lg"
                radius="md"
                withBorder
                style={{
                  height: '100%',
                  boxSizing: 'border-box',
                  backgroundColor: '#fffbee',
                }}
              >
                <Stack gap="md" style={{ height: '100%' }}>
                  <Group justify="space-between">
                    <Badge color={DIFFICULTY_COLORS[difficulty]}>
                      {difficulty}
                    </Badge>
                    <ActionIcon variant="light" onClick={() => handleEdit(card)}>
                      <IconEdit size={16} />
                    </ActionIcon>
                  </Group>

                  <Stack justify="center" style={{ flex: 1 }}>
                    <Text size="lg" fw={700} ta="center" lineClamp={6}>
                      {answer}
                    </Text>
                  </Stack>

                  <ActionIcon
                    variant="default"
                    onClick={() => handleFlip(id)}
                    style={{ marginTop: 'auto' }}
                  >
                    <IconRefresh size={16} />
                  </ActionIcon>
                </Stack>
              </Card>
            </motion.div>
          </motion.div>
        </Box>
      </Grid.Col>
    );
  };

  const renderedCards = useMemo(
    () => flashcards.map(renderFlashcard),
    [flashcards, flippedCards, renderFlashcard]
  );

  return <Grid>{renderedCards}</Grid>;
});



================================================================================
File: frontend\src\components\flashcards\FlashcardList.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { Stack, Text, Box, TextInput, SegmentedControl, Button, Select, Flex } from '@mantine/core';
import { LoadingOverlay } from '../shared/LoadingOverlay';
import { ErrorBoundary } from '../shared/ErrorBoundary';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { Flashcard, DifficultyLevel } from '../../types';
import { FlashcardForm } from './FlashcardForm';
import { FlashcardGrid } from './FlashcardGrid';
import { FlashcardTable } from './FlashcardTable';
import { useFlashcardFilters, ViewMode } from '../../hooks/useFlashcardFilters';

export function FlashcardList() {
  const { flashcards, loading, error, fetchFlashcards } = useFlashcardStore();
  const { packs, fetchPacks } = usePackStore();
  const [viewMode, setViewMode] = useState<ViewMode>('grid');
  const [selectedFlashcard, setSelectedFlashcard] = useState<Flashcard | undefined>();
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [selectedPackId, setSelectedPackId] = useState<string>('');

  const {
    searchQuery,
    setSearchQuery,
    difficultyFilter,
    setDifficultyFilter,
    sort,
    handleSortChange,
    filteredAndSortedFlashcards,
  } = useFlashcardFilters(flashcards);

  useEffect(() => {
    Promise.all([fetchFlashcards(), fetchPacks()]);
  }, [fetchFlashcards, fetchPacks]);

  useEffect(() => {
    // Set initial pack selection when packs are loaded
    if (packs.length > 0 && !selectedPackId) {
      setSelectedPackId(packs[0].id);
    }
  }, [packs, selectedPackId]);

  // Memoize handlers to prevent recreation on every render
  const handleEdit = React.useCallback((flashcard: Flashcard) => {
    setSelectedFlashcard(flashcard);
    setIsEditModalOpen(true);
  }, []);

  const handleCreate = React.useCallback(() => {
    setSelectedFlashcard(undefined);
    setIsEditModalOpen(true);
  }, []);

  // Memoize view mode change handler
  const handleViewModeChange = React.useCallback((value: string) => {
    setViewMode(value as ViewMode);
  }, []);

  // Memoize pack selection handler
  const handlePackSelect = React.useCallback((value: string | null) => {
    if (value) setSelectedPackId(value);
  }, []);

  // Memoize modal close handler
  const handleModalClose = React.useCallback(() => {
    setIsEditModalOpen(false);
    setSelectedFlashcard(undefined);
  }, []);

  // Memoize difficulty filter handler
  const handleDifficultyChange = React.useCallback((value: string | null) => {
    if (value) setDifficultyFilter(value as DifficultyLevel | 'all');
  }, [setDifficultyFilter]);

  return (
    <ErrorBoundary>
      <Stack gap="lg">
        {error && (
          <Text c="red" ta="center" size="lg">
            Error loading flashcards: {error}
          </Text>
        )}

        <Flex gap="md" align="center">
          <Select
            label="Flashcard Pack"
            placeholder="Select a pack"
            value={selectedPackId}
            onChange={handlePackSelect}
            data={packs.map(pack => ({
              value: pack.id,
              label: pack.name
            }))}
            style={{ minWidth: 200 }}
          />
          <TextInput
            placeholder="Search flashcards..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)} // Keep inline since it's a simple event handler
            style={{ flex: 1 }}
          />
          <Select
            value={difficultyFilter}
            onChange={handleDifficultyChange}
            data={[
              { value: 'all', label: 'All Difficulties' },
              { value: DifficultyLevel.EASY, label: 'Easy' },
              { value: DifficultyLevel.MEDIUM, label: 'Medium' },
              { value: DifficultyLevel.HARD, label: 'Hard' }
            ]}
          />
          <SegmentedControl
            value={viewMode}
            onChange={handleViewModeChange}
            data={[
              { label: 'Grid', value: 'grid' },
              { label: 'List', value: 'list' }
            ]}
          />
          <Button onClick={handleCreate}>Create Flashcard</Button>
        </Flex>

        <Box pos="relative" mih={400}>
          <LoadingOverlay visible={loading} />
          {viewMode === 'grid' ? (
            <FlashcardGrid
              flashcards={filteredAndSortedFlashcards}
              onEdit={handleEdit}
            />
          ) : (
            <FlashcardTable
              flashcards={filteredAndSortedFlashcards}
              onEdit={handleEdit}
              sort={sort}
              onSortChange={handleSortChange}
            />
          )}
        </Box>

        <FlashcardForm
          flashcard={selectedFlashcard}
          packId={selectedPackId}
          opened={isEditModalOpen}
          onClose={handleModalClose}
        />
      </Stack>
    </ErrorBoundary>
  );
}



================================================================================
File: frontend\src\components\flashcards\FlashcardPacks.tsx
================================================================================

import React, { useEffect, useState, useCallback, useMemo } from 'react';
import { 
  Grid, 
  Card, 
  Text, 
  Button, 
  Group,
  Badge,
  ActionIcon,
  Tooltip
} from '@mantine/core';
import { motion } from 'framer-motion';
import { IconPlus, IconEdit, IconTrash, IconCards, IconSquarePlus } from '@tabler/icons-react';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { FlashcardPack, Flashcard } from '../../types';
import { FlashcardForm } from './FlashcardForm';
import { DeleteConfirmationModal, PackFormModal } from './modals/FlashcardModals';

export function FlashcardPacks() {
  const { flashcards, fetchFlashcards } = useFlashcardStore();
  const { packs, loading, error, fetchPacks, addPack, updatePack, deletePack } = usePackStore();
  const [packFormOpen, setPackFormOpen] = useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [flashcardModalOpen, setFlashcardModalOpen] = useState(false);
  const [selectedPack, setSelectedPack] = useState<FlashcardPack | null>(null);
  const [selectedFlashcard, setSelectedFlashcard] = useState<Flashcard | null>(null);

  useEffect(() => {
    fetchPacks();
    fetchFlashcards();
  }, [fetchPacks, fetchFlashcards]);

  // Memoize handlers
  const handlePackSubmit = useCallback(async (name: string) => {
    try {
      if (selectedPack) {
        await updatePack(selectedPack.id, { name });
      } else {
        await addPack({ name });
      }
      // Always fetch all packs after any operation
      await fetchPacks();
      setPackFormOpen(false);
      setSelectedPack(null);
    } catch (err) {
      console.error('Failed to submit pack:', err);
    }
  }, [selectedPack, updatePack, addPack, fetchPacks]);

  const handleDeletePack = useCallback(async () => {
    if (!selectedPack) return;
    try {
      await deletePack(selectedPack.id);
      await Promise.all([
        fetchPacks(),      // Refresh packs list
        fetchFlashcards()  // Refresh flashcards
      ]);
      setDeleteModalOpen(false);
      setSelectedPack(null);
    } catch (err) {
      console.error('Failed to delete pack:', err);
    }
  }, [selectedPack, deletePack, fetchPacks, fetchFlashcards]);

  const openEditModal = useCallback((pack: FlashcardPack) => {
    setSelectedPack(pack);
    setPackFormOpen(true);
  }, []);

  const openCreateModal = useCallback(() => {
    setSelectedPack(null);
    setPackFormOpen(true);
  }, []);

  const openDeleteModal = useCallback((pack: FlashcardPack) => {
    setSelectedPack(pack);
    setDeleteModalOpen(true);
  }, []);

  const openFlashcardModal = useCallback((pack: FlashcardPack, flashcard?: Flashcard) => {
    setSelectedPack(pack);
    setSelectedFlashcard(flashcard || null);
    setFlashcardModalOpen(true);
  }, []);

  const closePackForm = useCallback(() => {
    setPackFormOpen(false);
    setSelectedPack(null);
  }, []);

  const closeDeleteModal = useCallback(() => {
    setDeleteModalOpen(false);
    setSelectedPack(null);
  }, []);

  const closeFlashcardModal = useCallback(() => {
    setFlashcardModalOpen(false);
    setSelectedPack(null);
    setSelectedFlashcard(null);
  }, []);

  // Memoize helper functions
  const getPackFlashcardCount = useCallback((packId: string) => {
    return flashcards.filter(f => f.pack_id === packId).length;
  }, [flashcards]);

  // Memoize pack data transformations
  const packData = useMemo(() => packs.map((pack: FlashcardPack) => ({
    ...pack,
    flashcardCount: getPackFlashcardCount(pack.id),
    createdDate: new Date(pack.created_at).toLocaleDateString()
  })), [packs, getPackFlashcardCount]);

  return (
    <>
      <Group justify="space-between" mb="xl">
        <Text size="xl" fw={700}>Flashcard Packs</Text>
        <Button
          leftSection={<IconPlus size={20} />}
          onClick={openCreateModal}
          variant="filled"
        >
          Create Pack
        </Button>
      </Group>

      {error && (
        <Text c="red" ta="center" size="lg" mb="xl">
          Error loading flashcard packs: {error}
        </Text>
      )}

      <Grid>
        {packData.map((pack) => (
          <Grid.Col key={pack.id} span={{ base: 12, sm: 6, md: 4 }}>
            <motion.div
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              whileHover={{ scale: 1.02 }}
              transition={{ duration: 0.2 }}
              style={{ height: '100%' }}
            >
              <Card shadow="sm" h="100%">
                <Group justify="space-between" mb="xs">
                  <Text fw={600} size="lg">{pack.name}</Text>
                  <Badge variant="light" color="blue">
                    <Group gap="xs">
                      <IconCards size={14} />
                      <Text size="xs">{pack.flashcardCount} cards</Text>
                    </Group>
                  </Badge>
                </Group>

                <Text size="sm" c="dimmed" mb="md" lineClamp={2}>
                  {pack.description || 'No description provided'}
                </Text>

                <Group mt="auto" justify="space-between">
                  <Text size="xs" c="dimmed">
                    Created: {pack.createdDate}
                  </Text>
                  <Group gap="xs">
                    <Tooltip label="Add Flashcard">
                      <ActionIcon 
                        variant="light" 
                        color="green"
                        onClick={() => openFlashcardModal(pack)}
                      >
                        <IconSquarePlus size={18} />
                      </ActionIcon>
                    </Tooltip>
                    <Tooltip label="Edit Pack">
                      <ActionIcon 
                        variant="light" 
                        color="blue"
                        onClick={() => openEditModal(pack)}
                      >
                        <IconEdit size={18} />
                      </ActionIcon>
                    </Tooltip>
                    <Tooltip label="Delete Pack">
                      <ActionIcon 
                        variant="light" 
                        color="red"
                        onClick={() => openDeleteModal(pack)}
                      >
                        <IconTrash size={18} />
                      </ActionIcon>
                    </Tooltip>
                  </Group>
                </Group>
              </Card>
            </motion.div>
          </Grid.Col>
        ))}
      </Grid>

      {/* Modals */}
      <PackFormModal
        opened={packFormOpen}
        onClose={closePackForm}
        onSubmit={handlePackSubmit}
        initialName={selectedPack?.name}
        loading={loading}
        mode={selectedPack ? 'edit' : 'create'}
      />

      <DeleteConfirmationModal
        opened={deleteModalOpen}
        onClose={closeDeleteModal}
        onConfirm={handleDeletePack}
        itemType="pack"
        itemName={selectedPack?.name}
        loading={loading}
      />

      {selectedPack && (
        <FlashcardForm
          packId={selectedPack.id}
          flashcard={selectedFlashcard || undefined}
          opened={flashcardModalOpen}
          onClose={closeFlashcardModal}
        />
      )}
    </>
  );
}



================================================================================
File: frontend\src\components\flashcards\FlashcardTable.tsx
================================================================================

import React, { useCallback, useMemo } from 'react';
import {
  Table,
  Badge,
  Text,
  ActionIcon,
  Progress,
  Group,
} from '@mantine/core';
import { IconEdit, IconArrowUp, IconArrowDown } from '@tabler/icons-react';
import { Flashcard, DifficultyLevel } from '../../types';
import { SortField, SortConfig } from '../../hooks/useFlashcardFilters';

// Memoize constant objects
const DIFFICULTY_COLORS = {
  [DifficultyLevel.EASY]: 'green',
  [DifficultyLevel.MEDIUM]: 'yellow',
  [DifficultyLevel.HARD]: 'red',
} as const;

interface FlashcardTableProps {
  flashcards: Flashcard[];
  onEdit: (flashcard: Flashcard) => void;
  sort: SortConfig;
  onSortChange: (field: SortField) => void;
}

export function FlashcardTable({ 
  flashcards, 
  onEdit, 
  sort, 
  onSortChange 
}: FlashcardTableProps) {
  // Memoize handlers
  const handleEdit = useCallback((card: Flashcard) => {
    onEdit(card);
  }, [onEdit]);

  const handleSortChange = useCallback((field: SortField) => {
    onSortChange(field);
  }, [onSortChange]);

  // Memoize sort icon renderer
  const renderSortIcon = useCallback((field: SortField) => {
    if (sort.field !== field) {
      return null;
    }
    const Icon = sort.order === 'asc' ? IconArrowUp : IconArrowDown;
    return <Icon size={14} />;
  }, [sort.field, sort.order]);

  // Memoize column headers with sort functionality
  const columnHeaders = useMemo(() => ({
    difficulty: (
      <Group gap={4} onClick={() => handleSortChange('difficulty')} style={{ cursor: 'pointer' }}>
        Difficulty {renderSortIcon('difficulty')}
      </Group>
    ),
    successRate: (
      <Group gap={4} onClick={() => handleSortChange('success_rate')} style={{ cursor: 'pointer' }}>
        Success Rate {renderSortIcon('success_rate')}
      </Group>
    )
  }), [handleSortChange, renderSortIcon]);

  // Memoize row rendering function
  const renderRow = useCallback((card: Flashcard) => {
    const successRatePercentage = (card.success_rate * 100).toFixed(1);
    const successRateColor = card.success_rate > 0.7 ? 'green' : card.success_rate > 0.4 ? 'yellow' : 'red';

    return (
      <Table.Tr key={card.id}>
        <Table.Td>
          <Badge color={DIFFICULTY_COLORS[card.difficulty]}>
            {card.difficulty}
          </Badge>
        </Table.Td>
        <Table.Td>
          <Text lineClamp={2}>{card.question}</Text>
        </Table.Td>
        <Table.Td>
          <Text lineClamp={2}>{card.answer}</Text>
        </Table.Td>
        <Table.Td>
          <Group gap="xs">
            <Text size="sm">{successRatePercentage}%</Text>
            <Progress
              value={card.success_rate * 100}
              color={successRateColor}
              size="sm"
              w={60}
            />
          </Group>
        </Table.Td>
        <Table.Td>
          <ActionIcon
            variant="light"
            onClick={() => handleEdit(card)}
          >
            <IconEdit size={16} />
          </ActionIcon>
        </Table.Td>
      </Table.Tr>
    );
  }, [handleEdit]);

  // Memoize rows
  const tableRows = useMemo(() => 
    flashcards.map(card => renderRow(card)),
    [flashcards, renderRow]
  );

  return (
    <Table striped highlightOnHover>
      <Table.Thead>
        <Table.Tr>
          <Table.Th>{columnHeaders.difficulty}</Table.Th>
          <Table.Th>Question</Table.Th>
          <Table.Th>Answer</Table.Th>
          <Table.Th>{columnHeaders.successRate}</Table.Th>
          <Table.Th>Actions</Table.Th>
        </Table.Tr>
      </Table.Thead>
      <Table.Tbody>
        {tableRows}
      </Table.Tbody>
    </Table>
  );
}



================================================================================
File: frontend\src\components\flashcards\modals\FlashcardModals.tsx
================================================================================

import React, { useState, useCallback } from 'react';
import {
  Modal,
  Text,
  Stack,
  Group,
  Button,
  Box,
  Progress,
  Divider,
  RangeSlider,
  Kbd,
  FileInput,
  Alert,
  Select,
  TextInput,
} from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { IconChartBar, IconUpload, IconDownload, IconAlertCircle, IconTrash } from '@tabler/icons-react';
import { StatsCard } from '../../shared/StatsCard';
import { Flashcard, FlashcardPack, BulkImportResult } from '../../../types';
import { AdvancedFilters, INITIAL_FILTERS } from '../../../hooks/useFlashcardFilters';
import { flashcardApi } from '../../../services/api';

interface StatsModalProps {
  opened: boolean;
  onClose: () => void;
  flashcard: Flashcard | null;
}

export function StatsModal({ opened, onClose, flashcard }: StatsModalProps) {
  return (
    <Modal
      opened={opened && !!flashcard}
      onClose={onClose}
      title={<Text fw={700}>Flashcard Statistics</Text>}
      size="lg"
    >
      {flashcard && (
        <Stack gap="md">
          <Group grow>
            <StatsCard
              title="Success Rate"
              value={`${(flashcard.success_rate * 100).toFixed(1)}%`}
              icon={<IconChartBar size={20} />}
            />
            <StatsCard
              title="Times Used"
              value={flashcard.times_used.toString()}
              icon={<IconChartBar size={20} />}
            />
          </Group>
          
          <Divider />
          
          <Box>
            <Text fw={500} mb="xs">Performance Trend</Text>
            <Box>
              <Progress
                value={(flashcard.times_correct / flashcard.times_used) * 100}
                color="green"
                size="xl"
              />
              <Group mt="xs" justify="space-between">
                <Text size="sm" c="green">Correct: {flashcard.times_correct}</Text>
                <Text size="sm" c="red">
                  Incorrect: {flashcard.times_used - flashcard.times_correct}
                </Text>
              </Group>
            </Box>
          </Box>

          <Group>
            <Text size="sm">Created: {new Date(flashcard.created_at).toLocaleDateString()}</Text>
            <Text size="sm">Last Updated: {new Date(flashcard.updated_at).toLocaleDateString()}</Text>
          </Group>
        </Stack>
      )}
    </Modal>
  );
}

interface AdvancedFiltersModalProps {
  opened: boolean;
  onClose: () => void;
  filters: AdvancedFilters;
  onFiltersChange: (filters: AdvancedFilters) => void;
}

export function AdvancedFiltersModal({
  opened,
  onClose,
  filters,
  onFiltersChange,
}: AdvancedFiltersModalProps) {
  // Memoize handlers
  const handleDateRangeChange = useCallback((value: [Date | null, Date | null]) => {
    onFiltersChange({ ...filters, dateRange: value });
  }, [filters, onFiltersChange]);

  const handleSuccessRateChange = useCallback((value: [number, number]) => {
    onFiltersChange({ ...filters, successRateRange: value });
  }, [filters, onFiltersChange]);

  const handleUsageRangeChange = useCallback((value: [number, number]) => {
    onFiltersChange({ ...filters, usageRange: value });
  }, [filters, onFiltersChange]);

  const handleReset = useCallback(() => {
    onFiltersChange(INITIAL_FILTERS);
  }, [onFiltersChange]);

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Advanced Filters</Text>}
      size="lg"
    >
      <Stack gap="md">
        <Box>
          <Text fw={500} mb="xs">Date Range</Text>
          <DatePickerInput
            type="range"
            value={filters.dateRange}
            onChange={handleDateRangeChange}
            clearable
          />
        </Box>

        <Box>
          <Text fw={500} mb="xs">Success Rate Range (%)</Text>
          <RangeSlider
            value={filters.successRateRange}
            onChange={handleSuccessRateChange}
            min={0}
            max={100}
            step={5}
            marks={[
              { value: 0, label: '0%' },
              { value: 50, label: '50%' },
              { value: 100, label: '100%' }
            ]}
          />
        </Box>

        <Box>
          <Text fw={500} mb="xs">Usage Count Range</Text>
          <RangeSlider
            value={filters.usageRange}
            onChange={handleUsageRangeChange}
            min={0}
            max={100}
            step={5}
            marks={[
              { value: 0, label: '0' },
              { value: 50, label: '50' },
              { value: 100, label: '100+' }
            ]}
          />
        </Box>

        <Group justify="flex-end">
          <Button variant="light" onClick={handleReset}>
            Reset Filters
          </Button>
          <Button onClick={onClose}>
            Apply Filters
          </Button>
        </Group>
      </Stack>
    </Modal>
  );
}

interface KeyboardShortcutsModalProps {
  opened: boolean;
  onClose: () => void;
}

export function KeyboardShortcutsModal({ opened, onClose }: KeyboardShortcutsModalProps) {
  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Keyboard Shortcuts</Text>}
    >
      <Stack gap="md">
        <Group>
          <Kbd>g</Kbd>
          <Text>Switch to grid view</Text>
        </Group>
        <Group>
          <Kbd>l</Kbd>
          <Text>Switch to list view</Text>
        </Group>
        <Group>
          <Kbd>/</Kbd>
          <Text>Focus search</Text>
        </Group>
        <Group>
          <Kbd>f</Kbd>
          <Text>Open advanced filters</Text>
        </Group>
        <Group>
          <Kbd>?</Kbd>
          <Text>Show this help</Text>
        </Group>
        <Group>
          <Kbd>esc</Kbd>
          <Text>Close any open modal</Text>
        </Group>
      </Stack>
    </Modal>
  );
}

interface BulkOperationsModalProps {
  opened: boolean;
  onClose: () => void;
  packs: FlashcardPack[];
  onImportComplete?: () => void;
}

interface DeleteConfirmationModalProps {
  opened: boolean;
  onClose: () => void;
  onConfirm: () => void;
  itemType: 'flashcard' | 'pack';
  itemName?: string;
  loading?: boolean;
}

export function DeleteConfirmationModal({
  opened,
  onClose,
  onConfirm,
  itemType,
  itemName,
  loading = false,
}: DeleteConfirmationModalProps) {
  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Delete {itemType}</Text>}
      size="sm"
    >
      <Stack gap="md">
        <Text>
          Are you sure you want to delete this {itemType}
          {itemName ? ` "${itemName}"` : ''}? This action cannot be undone.
          {itemType === 'pack' && ' All flashcards in this pack will also be deleted.'}
        </Text>

        <Group justify="flex-end">
          <Button variant="light" onClick={onClose} disabled={loading}>
            Cancel
          </Button>
          <Button 
            color="red" 
            leftSection={<IconTrash size={20} />}
            onClick={onConfirm}
            loading={loading}
          >
            Delete
          </Button>
        </Group>
      </Stack>
    </Modal>
  );
}

interface PackFormModalProps {
  opened: boolean;
  onClose: () => void;
  onSubmit: (name: string) => void;
  initialName?: string;
  loading?: boolean;
  mode: 'create' | 'edit';
}

export function PackFormModal({
  opened,
  onClose,
  onSubmit,
  initialName = '',
  loading = false,
  mode,
}: PackFormModalProps) {
  const [name, setName] = useState(initialName);

  // Memoize handlers
  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    if (name.trim()) {
      onSubmit(name.trim());
    }
  }, [name, onSubmit]);

  const handleNameChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
  }, []);

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>{mode === 'create' ? 'Create New Pack' : 'Edit Pack'}</Text>}
      size="sm"
    >
      <form onSubmit={handleSubmit}>
        <Stack gap="md">
          <TextInput
            label="Pack Name"
            value={name}
            onChange={handleNameChange}
            placeholder="Enter pack name"
            required
            data-autofocus
          />

          <Group justify="flex-end">
            <Button variant="light" onClick={onClose} disabled={loading}>
              Cancel
            </Button>
            <Button type="submit" loading={loading}>
              {mode === 'create' ? 'Create Pack' : 'Save Changes'}
            </Button>
          </Group>
        </Stack>
      </form>
    </Modal>
  );
}

export function BulkOperationsModal({
  opened,
  onClose,
  packs,
  onImportComplete,
}: BulkOperationsModalProps) {
  const [selectedPack, setSelectedPack] = useState<string | null>(null);
  const [file, setFile] = useState<File | null>(null);
  const [importing, setImporting] = useState(false);
  const [importResult, setImportResult] = useState<(BulkImportResult & { success: boolean }) | null>(null);

  // Memoize handlers
  const handleDownloadTemplate = useCallback(async () => {
    try {
      const blob = await flashcardApi.getImportTemplate();
      const url = window.URL.createObjectURL(new Blob([blob]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', 'flashcard_template.csv');
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      console.error('Failed to download template:', error);
    }
  }, []);

  const handleExport = useCallback(async () => {
    if (!selectedPack) return;

    try {
      const blob = await flashcardApi.exportPack(selectedPack);
      const url = window.URL.createObjectURL(new Blob([blob]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `flashcards_pack_${selectedPack}.csv`);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      console.error('Failed to export flashcards:', error);
    }
  }, [selectedPack]);

  const handleImport = useCallback(async () => {
    if (!file) return;

    setImporting(true);
    setImportResult(null);

    try {
      const response = await flashcardApi.bulkImport(file);
      const importResult: BulkImportResult & { success: boolean } = {
        ...response.data.data,
        success: response.data.data.successful > 0
      };
      setImportResult(importResult);
      if (onImportComplete) {
        onImportComplete();
      }
    } catch (error) {
      console.error('Failed to import flashcards:', error);
      setImportResult({
        success: false,
        total: 0,
        successful: 0,
        failed: 0,
        errors: ['Failed to import flashcards. Please try again.'],
      });
    } finally {
      setImporting(false);
    }
  }, [file, onImportComplete]);

  const handlePackSelect = useCallback((value: string | null) => {
    setSelectedPack(value);
  }, []);

  const handleFileChange = useCallback((file: File | null) => {
    setFile(file);
  }, []);

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Bulk Operations</Text>}
      size="lg"
    >
      <Stack gap="md">
        <Box>
          <Text fw={500} mb="xs">Import Flashcards</Text>
          <Stack gap="sm">
            <Button
              leftSection={<IconDownload size={20} />}
              variant="light"
              onClick={handleDownloadTemplate}
            >
              Download Import Template
            </Button>
            <FileInput
              label="Upload CSV File"
              placeholder="Choose file"
              accept=".csv"
              value={file}
              onChange={handleFileChange}
              leftSection={<IconUpload size={20} />}
            />
            <Button
              onClick={handleImport}
              loading={importing}
              disabled={!file}
            >
              Import Flashcards
            </Button>
          </Stack>
        </Box>

        {importResult && (
          <Alert
            color={importResult.success ? 'green' : 'red'}
            title={importResult.success ? 'Import Successful' : 'Import Failed'}
            icon={<IconAlertCircle />}
          >
            <Text>Total processed: {importResult.total}</Text>
            <Text>Successfully imported: {importResult.successful}</Text>
            <Text>Failed: {importResult.failed}</Text>
            {importResult.errors.length > 0 && (
              <Box mt="xs">
                <Text fw={500}>Errors:</Text>
                <Stack gap="xs">
                  {importResult.errors.map((error, index) => (
                    <Text key={index} size="sm" c="red">
                      {error}
                    </Text>
                  ))}
                </Stack>
              </Box>
            )}
          </Alert>
        )}

        <Divider />

        <Box>
          <Text fw={500} mb="xs">Export Flashcards</Text>
          <Stack gap="sm">
            <Select
              label="Select Pack to Export"
              placeholder="Choose a pack"
              data={packs.map(pack => ({
                value: pack.id,
                label: pack.name,
              }))}
              value={selectedPack}
              onChange={handlePackSelect}
            />
            <Button
              leftSection={<IconDownload size={20} />}
              onClick={handleExport}
              disabled={!selectedPack}
            >
              Export Pack
            </Button>
          </Stack>
        </Box>
      </Stack>
    </Modal>
  );
}



================================================================================
File: frontend\src\components\shared\EloTimelineChart.tsx
================================================================================

import React from 'react';
import {
  ResponsiveContainer,
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip
} from 'recharts';
import { Box, Text, MantineTheme } from '@mantine/core';

// Define the type for a data point
export interface EloDataPoint {
  date: string; // e.g., formatted date string
  elo: number;
}

interface EloTimelineChartProps {
  data: EloDataPoint[];
}

/**
 * CustomTooltip
 *
 * A custom tooltip that displays the date and the elo value.
 */
const CustomTooltip: React.FC<any> = ({ active, payload, label }) => {
  if (active && payload && payload.length) {
    return (
      <Box
        style={{
          backgroundColor: '#1A1B1E',
          padding: '12px',
          borderRadius: '4px',
          boxShadow: '0 1px 3px rgba(0, 0, 0, 0.1)',
        }}
      >
        <Text size="sm" color="gray.0">
          {label}
        </Text>
        <Text size="sm" color="gray.0">
          ELO: {payload[0].value}
        </Text>
      </Box>
    );
  }

  return null;
};

/**
 * EloTimelineChart
 *
 * This component renders a responsive line chart for the ELO history.
 */
export const EloTimelineChart: React.FC<EloTimelineChartProps> = ({ data }) => {
  return (
    <ResponsiveContainer width="100%" height={300}>
      <LineChart
        data={data}
        margin={{ top: 20, right: 30, left: 20, bottom: 5 }}
      >
        <CartesianGrid strokeDasharray="3 3" stroke="#ccc" />
        <XAxis
          dataKey="date"
          tick={{ fontSize: 12, fill: '#666' }}
        />
        <YAxis tick={{ fontSize: 12, fill: '#666' }} />
        <Tooltip content={<CustomTooltip />} />
        <Line
          type="monotone"
          dataKey="elo"
          stroke="#8884d8"
          strokeWidth={2}
          dot={{ r: 4 }}
          activeDot={{ r: 6 }}
        />
      </LineChart>
    </ResponsiveContainer>
  );
};



================================================================================
File: frontend\src\components\shared\ErrorAlert.tsx
================================================================================

import React from 'react';
import { Stack, Alert, Text, Button } from '@mantine/core';
import { IconAlertCircle, IconRefresh } from '@tabler/icons-react';

interface ErrorAlertProps { 
  error: string; 
  onRetry?: () => void;
  withRetry?: boolean;
}

export const ErrorAlert: React.FC<ErrorAlertProps> = ({ 
  error, 
  onRetry, 
  withRetry = true 
}) => (
  <Alert 
    icon={<IconAlertCircle size={16} />} 
    title="Error" 
    color="red"
    variant="filled"
  >
    <Stack gap="sm">
      <Text>{error}</Text>
      {withRetry && onRetry && (
        <Button 
          variant="white" 
          color="red" 
          size="xs" 
          leftSection={<IconRefresh size={14} />}
          onClick={onRetry}
        >
          Retry
        </Button>
      )}
    </Stack>
  </Alert>
);



================================================================================
File: frontend\src\components\shared\ErrorBoundary.tsx
================================================================================

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Container, Title, Text, Button, Stack, Paper } from '@mantine/core';
import { IconAlertTriangle } from '@tabler/icons-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
    errorInfo: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
      errorInfo: null
    };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
    this.setState({
      error,
      errorInfo
    });
  }

  private handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <Container size="sm" py="xl">
          <Paper p="xl" radius="md" withBorder>
            <Stack align="center" gap="md">
              <IconAlertTriangle size={48} stroke={1.5} color="red" />
              <Title order={2} ta="center" c="red.7">Something went wrong</Title>
              <Text c="dimmed" size="sm" ta="center" maw={400} mx="auto">
                {this.state.error?.message || 'An unexpected error occurred'}
              </Text>
              {process.env.NODE_ENV === 'development' && this.state.errorInfo && (
                <Paper withBorder p="xs" bg="gray.0" style={{ maxHeight: '200px', overflow: 'auto', width: '100%' }}>
                  <pre style={{ margin: 0, fontSize: '12px' }}>
                    <code>
                      {this.state.errorInfo.componentStack}
                    </code>
                  </pre>
                </Paper>
              )}
              <Button onClick={this.handleReset} variant="light" color="red" leftSection={<IconAlertTriangle size={16} />}>
                Try Again
              </Button>
            </Stack>
          </Paper>
        </Container>
      );
    }

    return this.props.children;
  }
}



================================================================================
File: frontend\src\components\shared\Layout.tsx
================================================================================

import React from 'react';
import { Container, useMantineTheme } from '@mantine/core';
import { Navigation } from './Navigation';

interface LayoutProps {
  children: React.ReactNode;
}

export function Layout({ children }: LayoutProps) {
  const theme = useMantineTheme();
  
  return (
    <Navigation>
      <Container
        fluid
        p={0}
        style={{
          background: `linear-gradient(165deg, ${theme.colors.custom[9]} 0%, ${theme.colors.custom[8]} 100%)`,
          minHeight: '100vh',
          maxWidth: '100vw'
        }}
      >
        {children}
      </Container>
    </Navigation>
  );
}



================================================================================
File: frontend\src\components\shared\LoadingOverlay.tsx
================================================================================

import React from 'react';
import { Center, Loader, Text, Stack, Box, MantineSize } from '@mantine/core';
import { motion, AnimatePresence } from 'framer-motion';

interface LoadingOverlayProps {
  visible: boolean;
  message?: string;
  size?: MantineSize;
  overlay?: boolean;
  loaderSize?: number;
  blur?: boolean;
}

export function LoadingOverlay({
  visible,
  message = 'Loading...',
  size = 'md',
  overlay = false,
  loaderSize = 36,
  blur = true
}: LoadingOverlayProps) {
  const MotionStack = motion(Stack) as any; // Type assertion needed for framer-motion

  return (
    <AnimatePresence>
      {visible && (
        <Box
          pos={overlay ? 'absolute' : 'relative'}
          top={0}
          left={0}
          right={0}
          bottom={0}
          style={{
            backgroundColor: overlay ? 'rgba(255, 255, 255, 0.8)' : 'transparent',
            backdropFilter: overlay && blur ? 'blur(2px)' : 'none',
            zIndex: 1000,
            minHeight: overlay ? '100%' : '200px',
          }}
        >
          <Center h="100%">
            <MotionStack
              align="center"
              gap="sm"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              transition={{ duration: 0.2 }}
            >
              <Loader size={loaderSize} />
              {message && (
                <Text size={size} c="dimmed" ta="center">
                  {message}
                </Text>
              )}
            </MotionStack>
          </Center>
        </Box>
      )}
    </AnimatePresence>
  );
}



================================================================================
File: frontend\src\components\shared\Navigation.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import {
  AppShell,
  Text,
  Burger,
  Group,
  UnstyledButton,
  ThemeIcon,
  Box,
  rem,
  useMantineTheme
} from '@mantine/core';
import { Link, useLocation } from 'react-router-dom';
import {
  IconUsers,
  IconCards,
  IconSwords,
  IconTrophy,
  IconSchool
} from '@tabler/icons-react';

interface NavItemProps {
  icon: JSX.Element;
  label: string;
  path: string;
  active: boolean;
  onClick?: () => void;
}

const NavItem = ({ icon, label, path, active, onClick }: NavItemProps) => {
  const theme = useMantineTheme();
  return (
    <UnstyledButton
      component={Link}
      to={path}
      onClick={onClick}
      style={{
        display: 'block',
        width: '100%',
        padding: rem(12),
        borderRadius: 'var(--mantine-radius-md)',
        backgroundColor: active ? `${theme.colors.custom[5]}20` : 'transparent',
        transition: 'all 0.2s ease',
        '&:hover': {
          backgroundColor: active
            ? `${theme.colors.custom[5]}30`
            : `${theme.colors.custom[7]}50`,
          transform: 'translateX(4px)',
        },
      }}
    >
      <Group>
        <ThemeIcon
          variant={active ? "filled" : "light"}
          size={36}
          color={active ? "custom.5" : "dark"}
          style={{
            transition: 'all 0.2s ease',
            backgroundColor: active ? theme.colors.custom[5] : `${theme.colors.custom[7]}50`,
          }}
        >
          {icon}
        </ThemeIcon>
        <Text
          size="sm"
          c={active ? "custom.5" : "gray.3"}
          fw={active ? 600 : 500}
          style={{
            transition: 'all 0.2s ease',
            textShadow: active ? `0 0 20px ${theme.colors.custom[5]}40` : 'none',
          }}
        >
          {label}
        </Text>
      </Group>
    </UnstyledButton>
  );
};

export function Navigation({ children }: { children: React.ReactNode }) {
  const [opened, setOpened] = useState(false);
  const location = useLocation();
  const theme = useMantineTheme();

  const toggleOpened = useCallback(() => {
    setOpened(o => !o);
  }, []);

  const handleNavItemClick = useCallback(() => {
    setOpened(false);
  }, []);

  const navItems = useMemo(() => [
    { label: 'Students', icon: <IconUsers size={24} stroke={1.5} />, path: '/students' },
    { label: 'Flashcards', icon: <IconCards size={24} stroke={1.5} />, path: '/flashcards' },
    { label: 'Battle Arena', icon: <IconSwords size={24} stroke={1.5} />, path: '/arena' },
    { label: 'Leaderboard', icon: <IconTrophy size={24} stroke={1.5} />, path: '/leaderboard' },
  ], []);

  return (
    <AppShell
      header={{ height: { base: 60, md: 70 } }}
      navbar={{
        width: { sm: 240, lg: 300 },
        breakpoint: 'sm',
        collapsed: { mobile: !opened }
      }}
      padding="md"
    >
      <AppShell.Header style={{
        background: `linear-gradient(135deg, ${theme.colors.custom[5]} 0%, ${theme.colors.custom[7]} 100%)`,
        boxShadow: '0 2px 8px rgba(0, 0, 0, 0.15)',
      }}>
        <Group h="100%" px="xl">
          <Burger
            opened={opened}
            onClick={toggleOpened}
            hiddenFrom="sm"
            size="sm"
            color="white"
          />
          <Group gap="xs">
            <IconSchool size={30} stroke={1.5} style={{ color: theme.white }} />
            <Text
              component={Link}
              to="/"
              size="lg"
              fw={700}
              style={{
                textDecoration: 'none',
                color: theme.white,
                letterSpacing: '0.5px'
              }}
            >
              Flashcard Battle Arena
            </Text>
          </Group>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md" style={{
        background: theme.colors.custom[7],
        borderRight: 'none',
        boxShadow: '2px 0 8px rgba(0, 0, 0, 0.2)',
      }}>
        <Box py="md">
          {navItems.map((item, index) => (
            <Box key={item.label} mb={index !== navItems.length - 1 ? "xs" : 0}>
              <NavItem
                icon={item.icon}
                label={item.label}
                path={item.path}
                active={location.pathname === item.path}
                onClick={handleNavItemClick}
              />
            </Box>
          ))}
        </Box>
      </AppShell.Navbar>

      <AppShell.Main style={{
        background: `
          linear-gradient(135deg, ${theme.colors.custom[9]} 0%, ${theme.colors.custom[8]} 100%),
          repeating-linear-gradient(45deg,
            ${theme.colors.custom[5]}05 0px,
            ${theme.colors.custom[5]}05 2px,
            transparent 2px,
            transparent 12px
          )
        `,
        color: theme.white,
      }}>
        <Box p="md" style={{
          backgroundColor: `${theme.colors.custom[9]}80`,
          borderRadius: 'var(--mantine-radius-lg)',
          backdropFilter: 'blur(8px)',
          minHeight: '100%'
        }}>
          {children}
        </Box>
      </AppShell.Main>
    </AppShell>
  );
}



================================================================================
File: frontend\src\components\shared\StatsCard.tsx
================================================================================

import React, { ReactNode } from 'react';
import { Paper, Text, Group, ThemeIcon, useMantineTheme } from '@mantine/core';

interface StatsCardProps {
  title: string;
  value: string | number;
  icon: ReactNode;
  description?: string;
}

export function StatsCard({ title, value, icon, description }: StatsCardProps) {
  const theme = useMantineTheme();
  
  return (
    <Paper 
      radius="md" 
      p="md"
      style={{
        backgroundColor: theme.colors.custom[7],
      }}
    >
      <Group justify="space-between">
        <div>
          <Text size="xs" c="custom.0" tt="uppercase" fw={700}>
            {title}
          </Text>
          <Text fw={700} size="xl" c="custom.0">
            {value}
          </Text>
          {description && (
            <Text size="xs" c="custom.0" mt={4} opacity={0.7}>
              {description}
            </Text>
          )}
        </div>
        <ThemeIcon
          size={48}
          radius="md"
          variant="filled"
          color="custom.5"
        >
          {icon}
        </ThemeIcon>
      </Group>
    </Paper>
  );
}



================================================================================
File: frontend\src\components\students\StudentCard.tsx
================================================================================

import React, { useMemo } from 'react';
import { Card, Text, Group, Stack, Button, Avatar, Box, useMantineTheme } from '@mantine/core';
import { StatsCard } from '../shared/StatsCard';
import { Student } from '../../types';

interface StudentCardProps {
  student: Student;
  onViewStats?: () => void;
  onSelectForBattle?: () => void;
  onEdit?: () => void;
  onDelete?: () => void;
  onReset?: () => void;
  isSelected?: boolean;
}

export const StudentCard = React.memo(function StudentCard({
  student,
  onViewStats,
  onSelectForBattle,
  onEdit,
  onDelete,
  onReset,
  isSelected = false
}: StudentCardProps) {
  const theme = useMantineTheme();
  
  const winRateDisplay = useMemo(() => {
    return `${(student.win_rate * 100).toFixed(1)}%`;
  }, [student.win_rate]);

  const recordDisplay = useMemo(() => {
    return `${student.wins}W - ${student.losses}L`;
  }, [student.wins, student.losses]);

  return (
    <Card
      withBorder
      radius="md"
      p="xl"
      style={{
        backgroundColor: theme.colors.custom[8],
        border: isSelected ? `2px solid ${theme.colors.custom[5]}` : 'none',
        transition: 'transform 0.2s ease, box-shadow 0.2s ease',
        boxShadow: '0 4px 12px rgba(0, 0, 0, 0.3)',
        '&:hover': {
          transform: 'translateY(-4px)',
          boxShadow: '0 8px 24px rgba(0, 0, 0, 0.4)'
        }
      }}
    >
      <Stack gap="lg">
        <Group justify="space-between" align="flex-start">
          <Group gap="md">
            <Avatar
              src={student.avatar_url || undefined}
              alt={student.name}
              radius="xl"
              size={60}
              style={{
                border: `2px solid ${theme.colors.custom[5]}`,
                boxShadow: `0 0 10px ${theme.colors.custom[5]}30`
              }}
            >
              {(!student.avatar_url && student.name) ? student.name.charAt(0) : ''}
            </Avatar>
            <Text 
              size="xl" 
              fw={700}
              c="custom.0"
            >
              {student.name}
            </Text>
          </Group>

          <Group gap="xs">
            {onEdit && (
              <Button 
                variant="filled" 
                onClick={onEdit} 
                color="custom.5"
                size="sm"
              >
                Edit
              </Button>
            )}
            {onDelete && (
              <Button 
                variant="filled" 
                onClick={onDelete} 
                color="red.7"
                size="sm"
              >
                Delete
              </Button>
            )}
            {onReset && (
              <Button 
                variant="filled" 
                onClick={onReset} 
                style={{
                  backgroundColor: '#9B8D27'
                }}
                size="sm"
              >
                Reset Stats
              </Button>
            )}
          </Group>
        </Group>

        <Group grow gap="md">
          <StatsCard
            title="ELO RATING"
            value={student.elo_rating}
            icon="🏆"
            description="Current ranking points"
          />
          <StatsCard
            title="WIN RATE"
            value={winRateDisplay}
            icon="📊"
            description={recordDisplay}
          />
        </Group>

        {onViewStats && (
          <Button 
            variant="subtle" 
            onClick={onViewStats} 
            fullWidth
            color="custom.5"
            style={{
              marginTop: theme.spacing.xs
            }}
          >
            View Detailed Stats
          </Button>
        )}

        {onSelectForBattle && (
          <Button
            variant="filled"
            color="custom.5"
            onClick={onSelectForBattle}
            disabled={isSelected}
            fullWidth
          >
            {isSelected ? 'Selected' : 'Select for Battle'}
          </Button>
        )}
      </Stack>
    </Card>
  );
});



================================================================================
File: frontend\src\components\students\StudentForm.tsx
================================================================================

import React, { useCallback, useMemo, useState } from 'react';
import { TextInput, Stack, Button, Group, Box, Text, Avatar } from '@mantine/core';
import { useForm } from '@mantine/form';
import { motion } from 'framer-motion';
import { Student } from '../../types';

interface StudentFormProps {
  student?: Student | null;
  onSubmit: (values: { name: string; avatar_url?: string }) => void;
  onCancel: () => void;
}

export function StudentForm({ student, onSubmit, onCancel }: StudentFormProps) {
  const [isPreviewHovered, setIsPreviewHovered] = useState(false);

  // Memoize validation function
  const validateName = useCallback((value: string) => {
    return !value ? 'Name is required' : null;
  }, []);

  // Memoize form configuration
  const formConfig = useMemo(() => ({
    initialValues: {
      name: student?.name || '',
      avatar_url: student?.avatar_url || '',
    },
    validate: {
      name: validateName,
    },
  }), [student?.name, student?.avatar_url, validateName]);

  const form = useForm(formConfig);

  // Memoize form submission handler
  const handleSubmit = useCallback((values: { name: string; avatar_url?: string }) => {
    onSubmit(values);
  }, [onSubmit]);

  const currentAvatarUrl = form.values.avatar_url;
  const currentName = form.values.name;

  return (
    <form onSubmit={form.onSubmit(handleSubmit)}>
      <Stack gap="xl">
        {/* Avatar Preview */}
        <Box
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '1rem'
          }}
        >
          <Text 
            size="sm" 
            fw={500}
            style={{
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent'
            }}
          >
            Avatar Preview
          </Text>
          <Box
            style={{
              position: 'relative',
              padding: '4px',
              borderRadius: '50%',
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              boxShadow: '0 0 10px rgba(77, 171, 247, 0.3)',
              cursor: 'pointer'
            }}
            onMouseEnter={() => setIsPreviewHovered(true)}
            onMouseLeave={() => setIsPreviewHovered(false)}
          >
            <motion.div
              animate={isPreviewHovered ? {
                scale: 1.05,
                rotate: [-3, 3, -3]
              } : {
                scale: 1,
                rotate: 0
              }}
              transition={{
                duration: 0.3
              }}
            >
              <Avatar
                src={currentAvatarUrl || undefined}
                alt={currentName}
                radius="xl"
                size={120}
                style={{
                  border: '2px solid #fff',
                  boxShadow: '0 0 10px rgba(77, 171, 247, 0.2)'
                }}
              >
                {(!currentAvatarUrl && currentName) ? currentName.charAt(0) : ''}
              </Avatar>
            </motion.div>
          </Box>
        </Box>

        <TextInput
          label="Name"
          placeholder="Enter student name"
          required
          styles={{
            label: {
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 500
            }
          }}
          {...form.getInputProps('name')}
        />
        <TextInput
          label="Avatar URL"
          placeholder="https://example.com/photo.jpg"
          styles={{
            label: {
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 500
            }
          }}
          {...form.getInputProps('avatar_url')}
        />
        <Group justify="flex-end" mt="md">
          <Button 
            variant="light" 
            onClick={onCancel}
            style={{
              transition: 'all 0.2s ease'
            }}
          >
            Cancel
          </Button>
          <Button 
            type="submit"
            variant="gradient"
            gradient={{ from: '#4dabf7', to: '#228be6' }}
            style={{
              transition: 'all 0.2s ease'
            }}
          >
            {student ? 'Update' : 'Add'} Student
          </Button>
        </Group>
      </Stack>
    </form>
  );
}



================================================================================
File: frontend\src\components\students\StudentList.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { Grid, TextInput, Group, Modal, Stack, Alert, useMantineTheme } from '@mantine/core';
import { StudentCard } from './StudentCard';
import { StudentStats } from './StudentStats';
import { Student } from '../../types';
import { LoadingOverlay } from '../shared/LoadingOverlay';

interface StudentListProps {
  students?: Student[];
  onSelectForBattle?: (student: Student) => void;
  onEdit?: (student: Student) => void;
  onDelete?: (student: Student) => void;
  onReset?: (student: Student) => void;
  loading?: boolean;
  error?: string | null;
  selectedStudents?: Student[];
}

export function StudentList({ 
  students = [], 
  onSelectForBattle, 
  onEdit,
  onDelete,
  loading = false,
  error = null,
  selectedStudents = [],
  onReset
}: StudentListProps) {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedStudent, setSelectedStudent] = useState<Student | null>(null);
  const theme = useMantineTheme();

  const handleSearchChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(event.currentTarget.value);
  }, []);

  const handleViewStats = useCallback((student: Student) => {
    setSelectedStudent(student);
  }, []);

  const handleCloseStats = useCallback(() => {
    setSelectedStudent(null);
  }, []);

  const handleBattleSelect = useCallback((student: Student) => {
    if (onSelectForBattle) {
      onSelectForBattle(student);
    }
  }, [onSelectForBattle]);

  const handleEdit = useCallback((student: Student) => {
    if (onEdit) {
      onEdit(student);
    }
  }, [onEdit]);

  const filteredStudents = useMemo(() => {
    const query = searchQuery.toLowerCase();
    return students.filter(student =>
      student.name.toLowerCase().includes(query)
    );
  }, [students, searchQuery]);

  return (
    <Stack gap="xl">
      {loading && <LoadingOverlay visible={true} />}

      {error && (
        <Alert color="red" title="Error">
          {error}
        </Alert>
      )}

      {!loading && !error && (
        <>
          <Group justify="space-between">
            <TextInput
              placeholder="Search students..."
              value={searchQuery}
              onChange={handleSearchChange}
              style={{ flex: 1 }}
              styles={{
                input: {
                  backgroundColor: theme.colors.custom[7],
                  color: theme.colors.custom[0],
                  border: `1px solid ${theme.colors.custom[5]}30`,
                  '&::placeholder': {
                    color: theme.colors.custom[0],
                    opacity: 0.5,
                  },
                  '&:focus': {
                    borderColor: theme.colors.custom[5],
                  },
                },
              }}
            />
          </Group>

          <Grid gutter="xl">
            {filteredStudents.map((student) => (
              <Grid.Col 
                key={student.id} 
                span={{ base: 12, sm: 6, lg: 4 }}
                style={{
                  marginBottom: theme.spacing.xl,
                }}
              >
                <StudentCard
                  student={student}
                  onViewStats={() => handleViewStats(student)}
                  onSelectForBattle={onSelectForBattle ? () => handleBattleSelect(student) : undefined}
                  onEdit={onEdit ? () => handleEdit(student) : undefined}
                  onDelete={onDelete ? () => onDelete(student) : undefined}
                  onReset={onReset ? () => onReset(student) : undefined}
                  isSelected={selectedStudents.some(s => s.id === student.id)}
                />
              </Grid.Col>
            ))}
          </Grid>

          <Modal
            opened={!!selectedStudent}
            onClose={handleCloseStats}
            title={selectedStudent?.name + "'s Statistics"}
            size="xl"
            styles={{
              header: {
                backgroundColor: theme.colors.custom[9],
                color: theme.colors.custom[0],
              },
              content: {
                backgroundColor: theme.colors.custom[9],
              },
            }}
          >
            {selectedStudent && (
              <StudentStats
                student={selectedStudent}
              />
            )}
          </Modal>
        </>
      )}
    </Stack>
  );
}



================================================================================
File: frontend\src\components\students\StudentStats.tsx
================================================================================

import React, { useEffect, useMemo, useState } from 'react';
import { Card, Text, Stack, Grid, Table, Center, Avatar, Group, Box, Badge, Title } from '@mantine/core';
import { motion } from 'framer-motion';
import { EloTimelineChart } from '../shared/EloTimelineChart';
import { StatsCard } from '../shared/StatsCard';
import { Student, StudentAchievementResponse } from '../../types';
import { useStudentStore } from '../../stores';
import { getStudentAchievements } from '../../achievements/getStudentAchievements';

interface StudentStatsProps {
  student: Student;
}

export const StudentStats = React.memo(function StudentStats({ student }: StudentStatsProps) {
  // Store retrieval for match history
  const { studentHistory, fetchStudentHistory } = useStudentStore();
  const historyData = useMemo(
    () => studentHistory[student.id] || [],
    [studentHistory, student.id]
  );

  // Fetch match history if not already fetched
  useEffect(() => {
    void fetchStudentHistory(student.id);
  }, [student.id, fetchStudentHistory]);

  // Prepare data for ELO timeline chart
  const eloTimeline = useMemo(() => {
    return historyData.map((mh) => ({
      date: new Date(mh.date).toLocaleDateString(),
      elo: mh.new_elo,
    }));
  }, [historyData]);

  // Compute display of student's win-rate and record
  const winRateDisplay = useMemo(
    () => `${(student.win_rate * 100).toFixed(1)}%`,
    [student.win_rate]
  );
  const recordDisplay = useMemo(
    () => `${student.wins}W - ${student.losses}L`,
    [student.wins, student.losses]
  );

  // Fetch student's achievements
  const [studentAchievements, setStudentAchievements] = useState<StudentAchievementResponse[]>([]);

  useEffect(() => {
    async function fetchAchievements() {
      try {
        const achievements = await getStudentAchievements(student.id);
        setStudentAchievements(achievements);
      } catch (err) {
        console.error('Failed to fetch achievements:', err);
      }
    }
    void fetchAchievements();
  }, [student.id]);

  return (
    <Stack gap="lg">
      {/* AVATAR & NAME */}
      <Group gap="md" align="center" mb="xl">
        <Box
          style={{
            position: 'relative',
            padding: '4px',
            borderRadius: '50%',
            background: 'linear-gradient(45deg, #4dabf7, #228be6)',
            boxShadow: '0 0 10px rgba(77, 171, 247, 0.3)'
          }}
        >
          <motion.div
            animate={{
              scale: [1, 1.05, 1],
              rotate: [0, 2, -2, 0]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              repeatType: "reverse"
            }}
          >
            <Avatar
              src={student.avatar_url || undefined}
              alt={student.name}
              radius="xl"
              size={90}
              style={{
                border: '2px solid #fff',
                boxShadow: '0 0 10px rgba(77, 171, 247, 0.2)'
              }}
            >
              {(!student.avatar_url && student.name) ? student.name.charAt(0) : ''}
            </Avatar>
          </motion.div>
        </Box>
        <Text 
          size="xl" 
          fw={700}
          style={{
            background: 'linear-gradient(45deg, #4dabf7, #228be6)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent'
          }}
        >
          {student.name}
        </Text>
      </Group>

      {/* Top Stats (Matches, Win Rate, ELO) */}
      <Grid>
        <Grid.Col span={4}>
          <StatsCard
            title="Total Matches"
            value={student.total_matches}
            icon="🎮"
            description="Career battles"
          />
        </Grid.Col>
        <Grid.Col span={4}>
          <StatsCard
            title="Win Rate"
            value={winRateDisplay}
            icon="📊"
            description={recordDisplay}
          />
        </Grid.Col>
        <Grid.Col span={4}>
          <StatsCard
            title="ELO Rating"
            value={student.elo_rating}
            icon="🏆"
            description="Current ranking"
          />
        </Grid.Col>
      </Grid>

      {/* Achievements Section */}
      <Card withBorder radius="md" p="md">
        <Title order={3} mb="md">Achievements</Title>
        <Group gap="lg">
          {studentAchievements.length > 0 ? (
            studentAchievements.map((achievementRecord) => (
              <Card
                key={achievementRecord.id}
                shadow="md"
                p="md"
                radius="md"
                withBorder
                style={{
                  width: 180,
                  textAlign: 'center',
                  background: 'rgba(255,255,255,0.05)',
                }}
              >
                <Badge
                  color="violet"
                  size="lg"
                  variant="filled"
                  style={{ fontSize: '1rem', marginBottom: '0.5rem' }}
                >
                  {achievementRecord.achievement.title}
                </Badge>
                <Text size="sm" color="dimmed">
                  {achievementRecord.achievement.description || 'No description provided'}
                </Text>
                <Text size="xs" color="gray" mt="xs">
                  Achieved on: {new Date(achievementRecord.achieved_at).toLocaleDateString()}
                </Text>
              </Card>
            ))
          ) : (
            <Text>No achievements unlocked yet.</Text>
          )}
        </Group>
      </Card>

      {/* ELO Timeline Chart */}
      <Card withBorder radius="md" p="md">
        <Text size="lg" fw={700} mb="md">
          ELO Timeline
        </Text>
        {eloTimeline.length < 2 ? (
          <Center>
            <Text size="sm" color="dimmed">
              Not enough data to show chart
            </Text>
          </Center>
        ) : (
          <EloTimelineChart data={eloTimeline} />
        )}
      </Card>

      {/* Match History Table */}
      <Card withBorder radius="md" p="md">
        <Text size="lg" fw={700} mb="md">
          Match History
        </Text>
        {historyData.length === 0 ? (
          <Text size="sm" color="dimmed">
            No match history yet.
          </Text>
        ) : (
          <Table striped highlightOnHover>
            <thead>
              <tr>
                <th>Date</th>
                <th>Opponent</th>
                <th>Result</th>
                <th>Old ELO</th>
                <th>Change</th>
                <th>New ELO</th>
              </tr>
            </thead>
            <tbody>
              {historyData.map((mh) => (
                <tr key={mh.match_id}>
                  <td>{new Date(mh.date).toLocaleDateString()}</td>
                  <td>{mh.opponent_name}</td>
                  <td style={{ color: mh.result === 'win' ? 'green' : 'red' }}>
                    {mh.result.toUpperCase()}
                  </td>
                  <td>{mh.old_elo.toFixed(1)}</td>
                  <td>
                    {mh.elo_change > 0 ? `+${mh.elo_change}` : mh.elo_change}
                  </td>
                  <td>{mh.new_elo.toFixed(1)}</td>
                </tr>
              ))}
            </tbody>
          </Table>
        )}
      </Card>
    </Stack>
  );
});



================================================================================
File: frontend\src\hooks\useArenaBattle.ts
================================================================================

import { useState } from 'react';
import { useBattleStore } from '../stores';
import { useFlashcardStore } from '../stores/flashcardStore';
import type { Flashcard } from '../types';
import { ArenaStep } from '../types/arena';

export const useArenaBattle = () => {
  const { flashcards } = useFlashcardStore();
  const { 
    currentArenaSession,
    currentArenaMatch,
    createArenaSession,
    getNextArenaMatch,
    setArenaMatchWinner,
    getArenaResults
  } = useBattleStore();

  const [currentFlashcard, setCurrentFlashcard] = useState<Flashcard | null>(null);
  const [arenaStep, setArenaStep] = useState<ArenaStep>(ArenaStep.SETUP);
  const [isLoading, setIsLoading] = useState(false);

  const getRandomFlashcard = (): Flashcard | null => {
    if (!flashcards || flashcards.length === 0) return null;
    const randomIndex = Math.floor(Math.random() * flashcards.length);
    return flashcards[randomIndex];
  };

  const startBattle = async (playerIds: string[], rounds: number) => {
    setIsLoading(true);
    try {
      // Create arena session with selected players
      await createArenaSession(playerIds, rounds);

      // Get first match
      await getNextArenaMatch();

      // Set random flashcard
      const flashcard = getRandomFlashcard();
      if (!flashcard) throw new Error('No flashcards available');
      setCurrentFlashcard(flashcard);

      // Move to VS screen
      setArenaStep(ArenaStep.VERSUS);
    } catch (error) {
      console.error('Failed to start battle:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const handleVersusReady = () => {
    setArenaStep(ArenaStep.BATTLE);
  };

  const handleSelectWinner = async (winnerIds: string[]) => {
    if (isLoading) return; // Prevent double submission
    setIsLoading(true);
    try {
      await setArenaMatchWinner(winnerIds);
      setArenaStep(ArenaStep.ROUND_RESULT);
    } catch (error) {
      console.error('Failed to process winner:', error);
      // Don't throw, just log the error and return
      return;
    } finally {
      setIsLoading(false);
    }
  };

  const handleNextRound = async () => {
    if (!currentArenaSession) return;
    setIsLoading(true);
    try {
      // If we've done all rounds, show final result
      if (currentArenaSession.rounds_completed >= currentArenaSession.num_rounds) {
        await getArenaResults();
        setArenaStep(ArenaStep.FINAL_RESULT);
        return;
      }

      // Otherwise, get next match and continue
      await getNextArenaMatch();
      const flashcard = getRandomFlashcard();
      if (!flashcard) {
        console.error('No flashcards available');
        return;
      }
      setCurrentFlashcard(flashcard);
      setArenaStep(ArenaStep.VERSUS);
    } catch (error) {
      console.error('Failed to process next round:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const resetBattle = () => {
    setArenaStep(ArenaStep.SETUP);
    setCurrentFlashcard(null);
  };

  return {
    // State
    currentFlashcard,
    arenaStep,
    isLoading,
    currentArenaSession,
    currentArenaMatch,

    // Methods
    startBattle,
    handleVersusReady,
    handleSelectWinner,
    handleNextRound,
    resetBattle,
    setArenaStep
  };
};



================================================================================
File: frontend\src\hooks\useArenaBattleSounds.ts
================================================================================

import { useEffect } from 'react';
import { ArenaStep } from '../types/arena';
import { useSound } from './useSound';

export const useArenaBattleSounds = (step: ArenaStep) => {
  const {
    playBattleSound,
    stopBattleSound,
    playVsSound,
    playResultSound,
    stopResultSound,
    playRoundResultSound,
  } = useSound();

  useEffect(() => {
    switch (step) {
      case ArenaStep.VERSUS:
        stopBattleSound();
        stopResultSound();
        playVsSound();
        break;
      case ArenaStep.BATTLE:
        stopResultSound();
        playBattleSound();
        break;
      case ArenaStep.ROUND_RESULT:
        stopBattleSound();
        stopResultSound();
        playRoundResultSound();
        break;
      case ArenaStep.FINAL_RESULT:
        stopBattleSound();
        playResultSound();
        break;
      default:
        stopBattleSound();
        stopResultSound();
        break;
    }
    return () => {
      stopBattleSound();
      stopResultSound();
    };
  }, [step, playBattleSound, stopBattleSound, playVsSound, playResultSound]);
};


================================================================================
File: frontend\src\hooks\useArenaSetup.ts
================================================================================

import { useState, useMemo } from 'react';
import { useStudentStore, useFlashcardStore } from '../stores';
import { usePackStore } from '../stores/packStore';
import type { ValidationError, ArenaSetupData } from '../types/arena';

export const useArenaSetup = () => {
  const { students } = useStudentStore();
  const { packs } = usePackStore();

  // Setup state
  const [selectedPackId, setSelectedPackId] = useState<string>('');
  const [numRounds, setNumRounds] = useState(3);
  const [selectedPlayerIds, setSelectedPlayerIds] = useState<string[]>([]);
  const [validationErrors, setValidationErrors] = useState<ValidationError>({});

  // Computed values
  const studentSelectData = useMemo(() => {
    return students.map((s) => ({
      value: s.id,
      label: `${s.name} (ELO: ${s.elo_rating})`,
    }));
  }, [students]);

  const packSelectData = useMemo(() => {
    return packs.map((p) => ({
      value: p.id,
      label: p.name || 'Untitled Pack',
    }));
  }, [packs]);

  const validateSetup = (): boolean => {
    const errors: ValidationError = {};

    if (!selectedPackId) {
      errors.pack = 'Please select a flashcard pack';
    }

    if (selectedPlayerIds.length < 2) {
      errors.players = 'Please select at least 2 players';
    }

    if (numRounds < 1 || numRounds > 20) {
      errors.rounds = 'Number of rounds must be between 1 and 20';
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const { getByPack } = useFlashcardStore();

  const handlePackChange = async (value: string | null) => {
    const packId = value || '';
    setSelectedPackId(packId);
    setValidationErrors({});
    
    if (packId) {
      await getByPack(packId);
    }
  };

  const handleRoundsChange = (value: string | number) => {
    const numValue = typeof value === 'string' ? parseInt(value, 10) : value;
    setNumRounds(Number.isFinite(numValue) ? numValue : 1);
    setValidationErrors({});
  };

  const handlePlayersChange = (value: string[]) => {
    setSelectedPlayerIds(value);
    setValidationErrors({});
  };

  const getSetupData = (): ArenaSetupData => ({
    selectedPackId,
    numRounds,
    selectedPlayerIds
  });

  const resetSetup = () => {
    setSelectedPackId('');
    setSelectedPlayerIds([]);
    setNumRounds(3);
    setValidationErrors({});
  };

  return {
    // State
    selectedPackId,
    numRounds,
    selectedPlayerIds,
    validationErrors,
    
    // Computed
    studentSelectData,
    packSelectData,
    
    // Methods
    validateSetup,
    handlePackChange,
    handleRoundsChange,
    handlePlayersChange,
    getSetupData,
    resetSetup
  };
};



================================================================================
File: frontend\src\hooks\useFlashcardFilters.ts
================================================================================

import { useState, useMemo } from 'react';
import { Flashcard } from '../types';

export type SortField = 'difficulty' | 'success_rate' | 'created_at' | 'times_used';
export type SortOrder = 'asc' | 'desc';
export type ViewMode = 'grid' | 'list';

export interface SortConfig {
  field: SortField;
  order: SortOrder;
}

export interface AdvancedFilters {
  dateRange: [Date | null, Date | null];
  successRateRange: [number, number];
  usageRange: [number, number];
}

export const INITIAL_FILTERS: AdvancedFilters = {
  dateRange: [null, null],
  successRateRange: [0, 100],
  usageRange: [0, 100],
};

export function useFlashcardFilters(flashcards: Flashcard[]) {
  const [searchQuery, setSearchQuery] = useState('');
  const [difficultyFilter, setDifficultyFilter] = useState<string>('all');
  const [sort, setSort] = useState<SortConfig>({ field: 'created_at', order: 'desc' });
  const [advancedFilters, setAdvancedFilters] = useState<AdvancedFilters>(INITIAL_FILTERS);

  const filteredAndSortedFlashcards = useMemo(() => {
    let result = [...flashcards];

    // Apply all filters
    result = result.filter(card => {
      // Text search
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        if (!card.question.toLowerCase().includes(query) &&
            !card.answer.toLowerCase().includes(query)) {
          return false;
        }
      }

      // Difficulty filter
      if (difficultyFilter !== 'all' && card.difficulty !== difficultyFilter) {
        return false;
      }

      // Advanced filters
      const cardDate = new Date(card.created_at);
      if (advancedFilters.dateRange[0] && cardDate < advancedFilters.dateRange[0]) return false;
      if (advancedFilters.dateRange[1] && cardDate > advancedFilters.dateRange[1]) return false;

      const successRate = card.success_rate * 100;
      if (successRate < advancedFilters.successRateRange[0] || 
          successRate > advancedFilters.successRateRange[1]) return false;

      if (card.times_used < advancedFilters.usageRange[0] || 
          card.times_used > advancedFilters.usageRange[1]) return false;

      return true;
    });

    // Apply sorting
    result.sort((a, b) => {
      let comparison = 0;
      switch (sort.field) {
        case 'difficulty':
          comparison = a.difficulty.localeCompare(b.difficulty);
          break;
        case 'success_rate':
          comparison = a.success_rate - b.success_rate;
          break;
        case 'created_at':
          comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
          break;
        case 'times_used':
          comparison = a.times_used - b.times_used;
          break;
      }
      return sort.order === 'asc' ? comparison : -comparison;
    });

    return result;
  }, [flashcards, searchQuery, difficultyFilter, sort, advancedFilters]);

  const handleSortChange = (field: SortField) => {
    setSort(prev => ({
      field,
      order: prev.field === field && prev.order === 'asc' ? 'desc' : 'asc',
    }));
  };

  const resetFilters = () => {
    setSearchQuery('');
    setDifficultyFilter('all');
    setAdvancedFilters(INITIAL_FILTERS);
  };

  return {
    searchQuery,
    setSearchQuery,
    difficultyFilter,
    setDifficultyFilter,
    sort,
    handleSortChange,
    advancedFilters,
    setAdvancedFilters,
    resetFilters,
    filteredAndSortedFlashcards,
  };
}



================================================================================
File: frontend\src\hooks\useSound.ts
================================================================================

import { useEffect, useRef, useCallback } from 'react';

// Sound files are in public/sounds
const battleSoundURL = '/sounds/battle-sound.mp3';
const vsScreenSoundURL = '/sounds/vs-screen-sound.mp3';
const resultScreenSoundURL = '/sounds/result-screen-sound.mp3';
const roundResultSoundURL = '/sounds/round-result-sound.mp3';

/**
 * This hook manages playing/stopping background and one-shot sounds.
 */
export const useSound = () => {
  // Keep refs for audio that needs to be stopped
  const battleAudioRef = useRef<HTMLAudioElement | null>(null);
  const resultAudioRef = useRef<HTMLAudioElement | null>(null);

  // Initialize the battle-sound Audio object once
  useEffect(() => {
    const audio = new Audio(battleSoundURL);
    audio.loop = true;
    audio.volume = 0.3; // 30% volume
    battleAudioRef.current = audio;

    // Cleanup: stop if unmounted
    return () => {
      audio.pause();
      audio.src = '';
    };
  }, []);

  /**
   * Start the battle-sound loop (if not already playing).
   */
  const playBattleSound = useCallback(() => {
    if (battleAudioRef.current) {
      battleAudioRef.current.currentTime = 0; // optional, restart from beginning
      battleAudioRef.current.play().catch((err) => {
        console.error('Failed to play battle-sound:', err);
      });
    }
  }, []);

  /**
   * Stop the battle-sound loop.
   */
  const stopBattleSound = useCallback(() => {
    if (battleAudioRef.current) {
      battleAudioRef.current.pause();
      battleAudioRef.current.currentTime = 0;
    }
  }, []);

  /**
   * Play the "vs" screen sound once (80% volume).
   */
  const playVsSound = useCallback(() => {
    const audio = new Audio(vsScreenSoundURL);
    audio.volume = 0.8;
    audio.play().catch((err) => {
      console.error('Failed to play vs-screen-sound:', err);
    });
  }, []);

  /**
   * Play the final "result" screen sound once (70% volume).
   */
  const playResultSound = useCallback(() => {
    const audio = new Audio(resultScreenSoundURL);
    audio.volume = 0.35;
    resultAudioRef.current = audio;
    audio.play().catch((err) => {
      console.error('Failed to play result-screen-sound:', err);
    });
  }, []);

  /**
   * Stop the result sound.
   */
  const stopResultSound = useCallback(() => {
    if (resultAudioRef.current) {
      resultAudioRef.current.pause();
      resultAudioRef.current.currentTime = 0;
    }
  }, []);

  /**
   * Play the round result screen sound once (100% volume).
   */
  const playRoundResultSound = useCallback(() => {
    const audio = new Audio(roundResultSoundURL);
    audio.volume = 1.0;
    audio.play().catch((err) => {
      console.error('Failed to play round-result-sound:', err);
    });
  }, []);

  /**
   * Keep the existing playSound function for backward compatibility
   */
  const playSound = useCallback((effect: string) => {
    // No-op for now, can be expanded later if needed
  }, []);

  return {
    playBattleSound,
    stopBattleSound,
    playVsSound,
    playResultSound,
    stopResultSound,
    playRoundResultSound,
    playSound, // Keep existing usage safe
  };
};



================================================================================
File: frontend\src\pages\ArenaPage.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { Box, Center, Card, Title, Stack, LoadingOverlay } from '@mantine/core';
import { motion, AnimatePresence } from 'framer-motion';

import { useStudentStore } from '../stores';
import { useFlashcardStore } from '../stores/flashcardStore';
import { usePackStore } from '../stores/packStore';
import { ErrorAlert } from '../components/shared/ErrorAlert';
import { ArenaSetup } from '../components/arena/ArenaSetup';
import { ArenaBattle } from '../components/arena/ArenaBattle';
import { useArenaBattle } from '../hooks/useArenaBattle';
import { ArenaStep } from '../types/arena';

export function ArenaPage() {
  const { students, fetchStudents, error: studentsError } = useStudentStore();
  const { getByPack, error: flashcardsError } = useFlashcardStore();
  const { fetchPacks, error: packsError } = usePackStore();
  const [retryCount, setRetryCount] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  const {
    currentFlashcard,
    arenaStep,
    isLoading: battleLoading,
    currentArenaSession,
    currentArenaMatch,
    startBattle,
    handleVersusReady,
    handleSelectWinner,
    handleNextRound,
    resetBattle
  } = useArenaBattle();

  // Load initial data
  useEffect(() => {
    const loadInitialData = async () => {
      setIsLoading(true);
      try {
        await Promise.all([fetchStudents(), fetchPacks()]);
      } catch (error) {
        console.error('Failed to load initial data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    loadInitialData();
  }, [fetchStudents, fetchPacks, retryCount]);

  const handleStartArena = async (packId: string, playerIds: string[], rounds: number) => {
    setIsLoading(true);
    try {
      await getByPack(packId);
      await startBattle(playerIds, rounds);
    } catch (error) {
      console.error('Failed to start arena:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleRetry = () => {
    setRetryCount(prev => prev + 1);
  };

  // Error handling
  const error = studentsError || flashcardsError || packsError;
  if (error) {
    return (
      <Center style={{ minHeight: '50vh' }}>
        <ErrorAlert 
          error={error} 
          onRetry={handleRetry}
        />
      </Center>
    );
  }

  const renderContent = () => {
    if (arenaStep === ArenaStep.SETUP) {
      return (
        <ArenaSetup 
          onStart={handleStartArena}
          isLoading={isLoading || battleLoading}
        />
      );
    }

    return (
      <ArenaBattle
        step={arenaStep}
        currentFlashcard={currentFlashcard}
        currentMatch={currentArenaMatch}
        arenaSession={currentArenaSession}
        students={students}
        onVersusReady={handleVersusReady}
        onSelectWinner={handleSelectWinner}
        onNextRound={handleNextRound}
        onReset={resetBattle}
        isLoading={battleLoading}
      />
    );
  };

  return (
    <Box
      pos="relative"
      p={{ base: 'md', sm: 'lg', md: 'xl' }}
      style={{
        height: '100vh',
        background: 'linear-gradient(165deg, #1A1B1E 0%, #13151A 100%)',
        display: 'flex',
        flexDirection: 'column'
      }}
    >
      <LoadingOverlay
        visible={isLoading}
        zIndex={1000}
        overlayProps={{ blur: 2 }}
      />
      <Center style={{ flex: 1, width: '100%' }}>
        <AnimatePresence mode="wait">
          <motion.div
            key={arenaStep}
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -20 }}
            transition={{ type: "spring", stiffness: 100, damping: 15 }}
            style={{
              height: '100%',
              width: '100%',
              minHeight: 0,
              display: 'flex',
              flexDirection: 'column'
            }}
          >
            {renderContent()}
          </motion.div>
        </AnimatePresence>
      </Center>
    </Box>
  );
}



================================================================================
File: frontend\src\pages\FlashcardsPage.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { Title, Alert, Stack, Tabs, Card, Center, Box } from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import { useFlashcardStore } from '../stores/flashcardStore';
import { usePackStore } from '../stores/packStore';
import { FlashcardPacks } from '../components/flashcards/FlashcardPacks';
import { FlashcardList } from '../components/flashcards/FlashcardList';

export const FlashcardsPage = React.memo(function FlashcardsPage() {
  const { error: flashcardError } = useFlashcardStore();
  const { error: packError } = usePackStore();
  const error = flashcardError || packError;
  const [activeTab, setActiveTab] = useState<string | null>('packs');

  const handleTabChange = useCallback((value: string | null) => {
    setActiveTab(value);
  }, []);

  const errorAlert = useMemo(() => {
    if (!error) return null;
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="Error" color="red">
        {error}
      </Alert>
    );
  }, [error]);

  const tabPanels = useMemo(() => ({
    packs: <FlashcardPacks />,
    cards: <FlashcardList />
  }), []);

  if (error) {
    return errorAlert;
  }

  return (
    <Box>
      <Center py="xl">
        <Card w="90%" maw={1200}>
          <Stack gap="lg">
            <Title order={2}>Flashcards</Title>
            <Card>
              <Tabs value={activeTab} onChange={handleTabChange} color="teal">
                <Tabs.List>
                  <Tabs.Tab value="packs">Packs</Tabs.Tab>
                  <Tabs.Tab value="cards">All Cards</Tabs.Tab>
                </Tabs.List>

                <Tabs.Panel value="packs" pt="md">
                  {tabPanels.packs}
                </Tabs.Panel>

                <Tabs.Panel value="cards" pt="md">
                  {tabPanels.cards}
                </Tabs.Panel>
              </Tabs>
            </Card>
          </Stack>
        </Card>
      </Center>
    </Box>
  );
});



================================================================================
File: frontend\src\pages\index.ts
================================================================================

export { LeaderboardPage } from './LeaderboardPage';
export { StudentsPage } from './StudentsPage';
export { FlashcardsPage } from './FlashcardsPage';
export { ArenaPage } from './ArenaPage';


================================================================================
File: frontend\src\pages\LeaderboardPage.tsx
================================================================================

import React, { useEffect, useState, useMemo, useCallback } from 'react';
import {
  Box,
  Card,
  Center,
  Stack,
  Title,
  Text,
  Grid,
  Avatar,
  Badge,
  Group,
  useMantineTheme,
  rem,
  Modal,
  rgba,
} from '@mantine/core';
import { IconTrophy } from '@tabler/icons-react';
import { DataTable, DataTableColumn } from 'mantine-datatable';
import { useStudentStore } from '../stores';
import { Student } from '../types';
import { StudentStats } from '../components/students/StudentStats';
import type { MantineTheme } from '@mantine/core';

export function LeaderboardPage() {
  const theme = useMantineTheme();

  const { students, loading, error, fetchStudents } = useStudentStore();
  const [selectedStudent, setSelectedStudent] = useState<Student | null>(null);
  const [statsModalOpen, setStatsModalOpen] = useState(false);

  useEffect(() => {
    void fetchStudents();
  }, [fetchStudents]);

  const sortedStudents = useMemo(() => {
    const clone = [...students];
    clone.sort((a, b) => b.elo_rating - a.elo_rating);
    return clone;
  }, [students]);

  const topThree = useMemo(() => sortedStudents.slice(0, 3), [sortedStudents]);
  const rest = useMemo(() => sortedStudents.slice(3), [sortedStudents]);

  const handleViewStats = useCallback((student: Student) => {
    setSelectedStudent(student);
    setStatsModalOpen(true);
  }, []);

  const handleCloseStats = useCallback(() => {
    setStatsModalOpen(false);
    setSelectedStudent(null);
  }, []);

  const getRankBadgeProps = (rank: number) => {
    switch (rank) {
      case 1:
        return { color: 'yellow', icon: <IconTrophy size={16} /> };
      case 2:
        return { color: 'gray', icon: <IconTrophy size={16} /> };
      case 3:
        return { color: 'orange', icon: <IconTrophy size={16} /> };
      default:
        return { color: 'blue', icon: null };
    }
  };

  const columns: DataTableColumn<Student>[] = [
    {
      accessor: 'rank',
      title: 'Rank',
      textAlign: 'center',
      width: 80,
      render: (student) => {
        const rankInFullList = sortedStudents.indexOf(student) + 1;
        const { color, icon } = getRankBadgeProps(rankInFullList);
        return (
          <Badge
            color={color}
            size="lg"
            variant={icon ? 'filled' : 'light'}
            leftSection={icon}
            style={{
              fontWeight: 700,
              fontSize: rem(14),
            }}
          >
            #{rankInFullList}
          </Badge>
        );
      },
    },
    {
      accessor: 'name',
      title: 'Name',
      width: 240,
      render: (student) => (
        <Group gap="sm">
          <Avatar
            src={student.avatar_url || undefined}
            alt={student.name}
            size={36}
            radius="xl"
          >
            {(!student.avatar_url && student.name)
              ? student.name.charAt(0)
              : ''}
          </Avatar>
          <Text fw={600}>{student.name}</Text>
        </Group>
      ),
    },
    {
      accessor: 'elo_rating',
      title: 'ELO Rating',
      width: 120,
      textAlign: 'center',
      render: (student) => (
        <Text size="sm" fw={700} color="teal">
          {student.elo_rating}
        </Text>
      ),
    },
    {
      accessor: 'wins',
      title: 'Wins',
      textAlign: 'center',
    },
    {
      accessor: 'losses',
      title: 'Losses',
      textAlign: 'center',
    },
    {
      accessor: 'total_matches',
      title: 'Matches',
      textAlign: 'center',
    },
  ];

  if (error) {
    return (
      <Center h="50vh">
        <Text color="red">{error}</Text>
      </Center>
    );
  }

  return (
    <Box
      style={{
        minHeight: '70vh',
        padding: theme.spacing.xl,
        background: `linear-gradient(135deg, ${theme.colors.dark[7]} 0%, ${theme.colors.dark[9]} 100%)`,
      }}
    >
      <Card withBorder radius="md" p="xl">
        <Stack gap="md">
          <Title order={2} ta="center" mb="sm">
            Gaming Leaderboard
          </Title>
          <Text c="dimmed" ta="center">
            Compare top ELO Ratings among students
          </Text>

          {topThree.length > 0 && (
            <Grid mt="md" gutter="xl">
              {topThree.map((student, index) => {
                const rank = index + 1;
                const { color, icon } = getRankBadgeProps(rank);

                return (
                  <Grid.Col
                    key={student.id}
                    span={12 / Math.min(topThree.length, 3)}
                  >
                    <Card
                      style={{
                        position: 'relative',
                        textAlign: 'center',
                        background: `linear-gradient(45deg, ${theme.colors.dark[6]}, ${theme.colors.dark[9]})`,
                        border: `1px solid ${theme.colors.gray[7]}`,
                        boxShadow: theme.shadows.md,
                        cursor: 'pointer',
                        transform: 'translateY(0)',
                        transition: 'transform 0.2s ease, box-shadow 0.2s ease',
                        '&:hover': {
                          transform: 'translateY(-4px)',
                          boxShadow: theme.shadows.xl,
                        },
                      }}
                      onClick={() => handleViewStats(student)}
                    >
                      <Stack gap="xs" align="center">
                        <Badge
                          color={color}
                          size="lg"
                          variant={icon ? 'filled' : 'light'}
                          leftSection={icon}
                          style={{
                            fontWeight: 700,
                            fontSize: rem(14),
                          }}
                        >
                          #{rank}
                        </Badge>
                        <Avatar
                          src={student.avatar_url || undefined}
                          alt={student.name}
                          size={80}
                          radius="xl"
                        >
                          {(!student.avatar_url && student.name)
                            ? student.name.charAt(0)
                            : ''}
                        </Avatar>
                        <Text size="lg" fw={700}>
                          {student.name}
                        </Text>
                        <Text
                          size="xl"
                          fw={800}
                          variant="gradient"
                          gradient={{ from: 'blue.4', to: 'cyan.4', deg: 45 }}
                        >
                          {student.elo_rating} ELO
                        </Text>
                        <Group gap="xs">
                          <Text size="sm" c="green">
                            {student.wins}W
                          </Text>
                          <Text size="sm" c="red">
                            {student.losses}L
                          </Text>
                          <Text size="sm" c="dimmed">
                            {student.total_matches} total
                          </Text>
                        </Group>
                      </Stack>
                    </Card>
                  </Grid.Col>
                );
              })}
            </Grid>
          )}

          {rest.length > 0 && (
            <DataTable<Student>
              minHeight={150}
              records={rest}
              fetching={loading}
              onRowClick={({ record }) => handleViewStats(record)}
              columns={columns}
              highlightOnHover
              rowStyle={() => ({
                backgroundColor: 'transparent',
                cursor: 'pointer',
                '&:hover': {
                  backgroundColor: rgba(theme.colors.gray[8], 0.5),
                },
              })}
            />
          )}

          {!loading && sortedStudents.length === 0 && (
            <Center>
              <Text c="dimmed">No students available.</Text>
            </Center>
          )}
        </Stack>
      </Card>

      <Modal
        opened={statsModalOpen}
        onClose={handleCloseStats}
        size="xl"
        title={selectedStudent?.name ? `${selectedStudent.name}'s Statistics` : 'Statistics'}
      >
        {selectedStudent && <StudentStats student={selectedStudent} />}
      </Modal>
    </Box>
  );
}


================================================================================
File: frontend\src\pages\StudentsPage.tsx
================================================================================

import React, { useEffect, useState, useCallback, useMemo } from 'react';
import { StudentList } from '../components/students/StudentList';
import { StudentForm } from '../components/students/StudentForm';
import { Title, Alert, Button, Modal, Group, Text, Stack, Card, Box, useMantineTheme } from '@mantine/core';
import { useStudentStore } from '../stores';
import { IconAlertCircle, IconPlus } from '@tabler/icons-react';
import { Student } from '../types';

export function StudentsPage() {
  const { students, loading, error, fetchStudents, addStudent, updateStudent, deleteStudent, resetStudentStats } = useStudentStore();
  const [formModalOpen, setFormModalOpen] = useState(false);
  const [selectedStudent, setSelectedStudent] = useState<Student | null>(null);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [studentToDelete, setStudentToDelete] = useState<Student | null>(null);
  const theme = useMantineTheme();

  useEffect(() => {
    fetchStudents();
  }, [fetchStudents]);

  const handleSubmit = useCallback(async (values: { name: string; avatar_url?: string }) => {
    if (selectedStudent) {
      await updateStudent(selectedStudent.id, { 
        name: values.name,
        avatar_url: values.avatar_url
      });
    } else {
      await addStudent({ 
        name: values.name,
        avatar_url: values.avatar_url
      });
    }
    setFormModalOpen(false);
    setSelectedStudent(null);
  }, [selectedStudent, updateStudent, addStudent]);

  const handleEdit = useCallback((student: Student) => {
    setSelectedStudent(student);
    setFormModalOpen(true);
  }, []);

  const handleModalClose = useCallback(() => {
    setFormModalOpen(false);
    setSelectedStudent(null);
  }, []);

  const handleDeleteClick = useCallback((student: Student) => {
    setStudentToDelete(student);
    setDeleteModalOpen(true);
  }, []);

  const handleDeleteConfirm = useCallback(async () => {
    if (studentToDelete) {
      await deleteStudent(studentToDelete.id);
      setDeleteModalOpen(false);
      setStudentToDelete(null);
    }
  }, [deleteStudent, studentToDelete]);

  const handleDeleteCancel = useCallback(() => {
    setDeleteModalOpen(false);
    setStudentToDelete(null);
  }, []);

  const handleReset = useCallback(async (student: Student) => {
    await resetStudentStats(student.id);
  }, [resetStudentStats]);

  const handleAddClick = useCallback(() => {
    setSelectedStudent(null);
    setFormModalOpen(true);
  }, []);

  const modalTitle = useMemo(() => 
    selectedStudent ? 'Edit Student' : 'Add New Student',
    [selectedStudent]
  );

  const errorAlert = useMemo(() => {
    if (!error) return null;
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="Error" color="red">
        {error}
      </Alert>
    );
  }, [error]);

  if (error) {
    return errorAlert;
  }

  return (
    <Box
      style={{
        backgroundColor: theme.colors.custom[9],
        minHeight: '100vh',
        padding: theme.spacing.xl,
      }}
    >
      <Card 
        p="xl"
        radius="lg"
        style={{
          backgroundColor: 'transparent',
          border: 'none',
        }}
      >
        <Stack gap="xl">
          <Group justify="space-between" align="center">
            <Title order={2} c="custom.0">Students</Title>
            <Button
              leftSection={<IconPlus size={16} />}
              onClick={handleAddClick}
              color="custom.5"
              variant="filled"
              radius="md"
              size="md"
            >
              Add Student
            </Button>
          </Group>

          <Box>
            <StudentList 
              students={students} 
              onEdit={handleEdit}
              onDelete={handleDeleteClick}
              onReset={handleReset}
              loading={loading}
              error={error}
            />
          </Box>
        </Stack>
      </Card>

      <Modal
        opened={formModalOpen}
        onClose={handleModalClose}
        title={modalTitle}
        styles={{
          header: {
            backgroundColor: theme.colors.custom[7],
            color: theme.colors.custom[0],
          },
          content: {
            backgroundColor: theme.colors.custom[7],
          },
        }}
      >
        <StudentForm
          student={selectedStudent}
          onSubmit={handleSubmit}
          onCancel={handleModalClose}
        />
      </Modal>

      <Modal
        opened={deleteModalOpen}
        onClose={handleDeleteCancel}
        title="Delete Student"
        styles={{
          header: {
            backgroundColor: theme.colors.custom[7],
            color: theme.colors.custom[0],
          },
          content: {
            backgroundColor: theme.colors.custom[7],
          },
        }}
      >
        <Stack>
          <Text c="custom.0">
            Are you sure you want to delete {studentToDelete?.name}? This action cannot be undone.
          </Text>
          <Group justify="flex-end">
            <Button 
              variant="filled" 
              color="custom.5"
              onClick={handleDeleteCancel}
            >
              Cancel
            </Button>
            <Button 
              color="red.7"
              variant="filled" 
              onClick={handleDeleteConfirm}
            >
              Delete
            </Button>
          </Group>
        </Stack>
      </Modal>
    </Box>
  );
}



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.a11y.test.tsx
================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';
import { 
  Student, 
  Flashcard, 
  ArenaMatch, 
  ArenaSession,
  DifficultyLevel,
  MatchStatus,
  ArenaSessionStatus
} from '../../types';

expect.extend(toHaveNoViolations);

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/flashcardStore', () => ({
  useFlashcardStore: jest.fn()
}));

jest.mock('../../stores/packStore', () => ({
  usePackStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Accessibility', () => {
  const mockStudents: Student[] = [
    {
      id: '1',
      name: 'Student 1',
      elo_rating: 1000,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    },
    {
      id: '2',
      name: 'Student 2',
      elo_rating: 1200,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    }
  ];

  const mockFlashcard: Flashcard = {
    id: '1',
    pack_id: '1',
    question: 'Test Question',
    answer: 'Test Answer',
    difficulty: DifficultyLevel.MEDIUM,
    times_used: 0,
    times_correct: 0,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    success_rate: 0
  };

  const mockMatch: ArenaMatch = {
    id: '1',
    arena_id: '1',
    status: MatchStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    player1_id: '1',
    player2_id: '2',
    player1_elo_before: 1000,
    player2_elo_before: 1200,
    winner_ids: [],
    created_at: '2024-01-01',
    updated_at: '2024-01-01'
  };

  const mockSession: ArenaSession = {
    id: '1',
    status: ArenaSessionStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    participants: [
      { student_id: '1', name: 'Student 1', elo_rating: 1000, elo_change: 0, wins: 0, losses: 0, fights_played: 1 },
      { student_id: '2', name: 'Student 2', elo_rating: 1200, elo_change: 0, wins: 0, losses: 0, fights_played: 1 }
    ]
  };

  beforeEach(() => {
    mockHook(useStudentStore, {
      students: mockStudents,
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(useFlashcardStore, {
      flashcards: [mockFlashcard],
      error: null
    });

    mockHook(usePackStore, {
      packs: [
        { id: '1', name: 'Pack 1', description: 'Test Pack 1' }
      ],
      fetchPacks: jest.fn(),
      error: null
    });
  });

  it('setup step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('versus step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.VERSUS,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('battle step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: false,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('final results step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('has proper heading structure', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    const headings = screen.getAllByRole('heading');
    expect(headings.length).toBeGreaterThan(0);
    expect(headings[0]).toHaveAttribute('aria-level', '1');
  });

  it('form controls have associated labels', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    const inputs = screen.getAllByRole('spinbutton');
    inputs.forEach(input => {
      expect(input).toHaveAccessibleName();
    });
  });

  it('buttons have descriptive text', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    const buttons = screen.getAllByRole('button');
    buttons.forEach(button => {
      expect(button).toHaveAccessibleName();
    });
  });

  it('loading states are announced to screen readers', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: true
    });

    render(<ArenaPage />);
    expect(screen.getByRole('alert')).toHaveTextContent(/loading/i);
  });

  it('error messages are announced to screen readers', () => {
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: jest.fn(),
      error: 'Test error message'
    });

    render(<ArenaPage />);
    expect(screen.getByRole('alert')).toHaveTextContent('Test error message');
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.battle.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';
import { 
  Student, 
  Flashcard, 
  ArenaMatch, 
  ArenaSession,
  DifficultyLevel,
  MatchStatus,
  ArenaSessionStatus
} from '../../types';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/flashcardStore', () => ({
  useFlashcardStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Battle Step', () => {
  const mockStudents: Student[] = [
    {
      id: '1',
      name: 'Student 1',
      elo_rating: 1000,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    },
    {
      id: '2',
      name: 'Student 2',
      elo_rating: 1200,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    }
  ];

  const mockFlashcard: Flashcard = {
    id: '1',
    pack_id: '1',
    question: 'Test Question',
    answer: 'Test Answer',
    difficulty: DifficultyLevel.MEDIUM,
    times_used: 0,
    times_correct: 0,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    success_rate: 0
  };

  const mockMatch: ArenaMatch = {
    id: '1',
    arena_id: '1',
    status: MatchStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    player1_id: '1',
    player2_id: '2',
    player1_elo_before: 1000,
    player2_elo_before: 1200,
    winner_ids: [],
    created_at: '2024-01-01',
    updated_at: '2024-01-01'
  };

  const mockSession: ArenaSession = {
    id: '1',
    status: ArenaSessionStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    participants: [
      { student_id: '1', name: 'Student 1', elo_rating: 1000, elo_change: 0, wins: 0, losses: 0, fights_played: 1 },
      { student_id: '2', name: 'Student 2', elo_rating: 1200, elo_change: 0, wins: 0, losses: 0, fights_played: 1 }
    ]
  };

  beforeEach(() => {
    mockHook(useStudentStore, {
      students: mockStudents,
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(useFlashcardStore, {
      flashcards: [mockFlashcard],
      error: null
    });

    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: false,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      handleSelectWinner: jest.fn(),
      handleVersusReady: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('displays current flashcard during battle', () => {
    render(<ArenaPage />);
    expect(screen.getByText(mockFlashcard.question)).toBeInTheDocument();
    expect(screen.getByText(mockFlashcard.answer)).toBeInTheDocument();
  });

  it('displays current match participants', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/Student 1/)).toBeInTheDocument();
    expect(screen.getByText(/Student 2/)).toBeInTheDocument();
  });

  it('shows ELO ratings for participants', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/1000/)).toBeInTheDocument();
    expect(screen.getByText(/1200/)).toBeInTheDocument();
  });

  it('allows selecting a winner', async () => {
    const mockHandleSelectWinner = jest.fn();
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: false,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      handleSelectWinner: mockHandleSelectWinner
    });

    render(<ArenaPage />);
    
    const winnerButton = screen.getByTestId('select-winner-1');
    fireEvent.click(winnerButton);

    await waitFor(() => {
      expect(mockHandleSelectWinner).toHaveBeenCalledWith(['1']);
    });
  });

  it('shows loading state when selecting winner', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: true,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('loading-overlay')).toBeInTheDocument();
  });

  it('displays battle progress', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/Round 2 of 3/)).toBeInTheDocument();
  });

  it('shows versus screen between matches', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.VERSUS,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('versus-screen')).toBeInTheDocument();
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.scores.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';
import { 
  Student, 
  ArenaMatch, 
  ArenaSession,
  MatchStatus,
  ArenaSessionStatus
} from '../../types';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Final Results', () => {
  const mockStudents: Student[] = [
    {
      id: '1',
      name: 'Student 1',
      elo_rating: 1050,
      wins: 2,
      losses: 1,
      total_matches: 3,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0.67
    },
    {
      id: '2',
      name: 'Student 2',
      elo_rating: 1150,
      wins: 1,
      losses: 2,
      total_matches: 3,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0.33
    }
  ];

  const mockMatch: ArenaMatch = {
    id: '1',
    arena_id: '1',
    status: MatchStatus.COMPLETED,
    num_rounds: 3,
    rounds_completed: 3,
    player1_id: '1',
    player2_id: '2',
    player1_elo_before: 1000,
    player2_elo_before: 1200,
    player1_elo_after: 1050,
    player2_elo_after: 1150,
    winner_ids: ['1'],
    created_at: '2024-01-01',
    updated_at: '2024-01-01'
  };

  const mockSession: ArenaSession = {
    id: '1',
    status: ArenaSessionStatus.COMPLETED,
    num_rounds: 3,
    rounds_completed: 3,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    participants: [
      { 
        student_id: '1', 
        name: 'Student 1', 
        elo_rating: 1050, 
        elo_change: 50, 
        wins: 2, 
        losses: 1, 
        fights_played: 3,
        elo_before: 1000,
        elo_after: 1050
      },
      { 
        student_id: '2', 
        name: 'Student 2', 
        elo_rating: 1150, 
        elo_change: -50, 
        wins: 1, 
        losses: 2, 
        fights_played: 3,
        elo_before: 1200,
        elo_after: 1150
      }
    ]
  };

  beforeEach(() => {
    mockHook(useStudentStore, {
      students: mockStudents,
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      resetBattle: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('displays final results header', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/Final Results/i)).toBeInTheDocument();
  });

  it('shows all participants in final scoreboard', () => {
    render(<ArenaPage />);
    mockSession.participants?.forEach(participant => {
      expect(screen.getByText(participant.name!)).toBeInTheDocument();
    });
  });

  it('displays ELO changes for each participant', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/\+50/)).toBeInTheDocument(); // Student 1 gained 50
    expect(screen.getByText(/-50/)).toBeInTheDocument(); // Student 2 lost 50
  });

  it('shows win/loss record for each participant', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/2 wins/i)).toBeInTheDocument();
    expect(screen.getByText(/1 loss/i)).toBeInTheDocument();
    expect(screen.getByText(/1 win/i)).toBeInTheDocument();
    expect(screen.getByText(/2 losses/i)).toBeInTheDocument();
  });

  it('displays final ELO ratings', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/1050/)).toBeInTheDocument();
    expect(screen.getByText(/1150/)).toBeInTheDocument();
  });

  it('allows starting a new arena', () => {
    const mockResetBattle = jest.fn();
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      resetBattle: mockResetBattle
    });

    render(<ArenaPage />);
    
    const newArenaButton = screen.getByText(/Start New Arena/i);
    fireEvent.click(newArenaButton);

    expect(mockResetBattle).toHaveBeenCalled();
  });

  it('shows loading state when starting new arena', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: true,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('loading-overlay')).toBeInTheDocument();
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.setup.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { usePackStore } from '../../stores/packStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/packStore', () => ({
  usePackStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Setup Step', () => {
  beforeEach(() => {
    mockHook(useStudentStore, {
      students: [
        { id: '1', name: 'Student 1', elo_rating: 1000 },
        { id: '2', name: 'Student 2', elo_rating: 1200 }
      ],
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(usePackStore, {
      packs: [
        { id: '1', name: 'Pack 1', description: 'Test Pack 1' },
        { id: '2', name: 'Pack 2', description: 'Test Pack 2' }
      ],
      fetchPacks: jest.fn(),
      error: null
    });

    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false,
      startBattle: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('displays student selection in setup', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/select players/i)).toBeInTheDocument();
  });

  it('displays pack selection in setup', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/select pack/i)).toBeInTheDocument();
  });

  it('displays rounds input in setup', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/number of rounds/i)).toBeInTheDocument();
  });

  it('validates minimum number of players', () => {
    render(<ArenaPage />);
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);
    expect(screen.getByText(/select at least 2 players/i)).toBeInTheDocument();
  });

  it('validates pack selection', () => {
    render(<ArenaPage />);
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);
    expect(screen.getByText(/select a pack/i)).toBeInTheDocument();
  });

  it('validates rounds input', () => {
    render(<ArenaPage />);
    const roundsInput = screen.getByLabelText(/number of rounds/i);
    fireEvent.change(roundsInput, { target: { value: '0' } });
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);
    expect(screen.getByText(/minimum 1 round required/i)).toBeInTheDocument();
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

// Mock the stores and hooks
jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/flashcardStore', () => ({
  useFlashcardStore: jest.fn()
}));

jest.mock('../../stores/packStore', () => ({
  usePackStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage', () => {
  // Setup default mock implementations
  beforeEach(() => {
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: jest.fn(),
      error: null
    });
    
    mockHook(useFlashcardStore, {
      getByPack: jest.fn(),
      error: null
    });
    
    mockHook(usePackStore, {
      fetchPacks: jest.fn(),
      error: null
    });
    
    mockHook(useArenaBattle, {
      currentFlashcard: null,
      arenaStep: ArenaStep.SETUP,
      isLoading: false,
      currentArenaSession: null,
      currentArenaMatch: null,
      startBattle: jest.fn(),
      handleVersusReady: jest.fn(),
      handleSelectWinner: jest.fn(),
      resetBattle: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('loads initial data on mount', () => {
    const mockFetchStudents = jest.fn();
    const mockFetchPacks = jest.fn();
    
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: mockFetchStudents,
      error: null
    });
    
    mockHook(usePackStore, {
      fetchPacks: mockFetchPacks,
      error: null
    });

    render(<ArenaPage />);

    expect(mockFetchStudents).toHaveBeenCalled();
    expect(mockFetchPacks).toHaveBeenCalled();
  });

  it('shows error alert when there is an error', () => {
    const testError = 'Test error message';
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: jest.fn(),
      error: testError
    });

    render(<ArenaPage />);
    expect(screen.getByText(testError)).toBeInTheDocument();
  });

  it('shows ArenaSetup component in setup step', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('arena-setup')).toBeInTheDocument();
  });

  it('shows ArenaBattle component after setup', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.VERSUS,
      isLoading: false,
      currentArenaMatch: { id: '1' },
      currentArenaSession: { id: '1' }
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('arena-battle')).toBeInTheDocument();
  });

  it('handles start arena action', async () => {
    const mockGetByPack = jest.fn();
    const mockStartBattle = jest.fn();
    
    mockHook(useFlashcardStore, {
      getByPack: mockGetByPack,
      error: null
    });
    
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      startBattle: mockStartBattle,
      isLoading: false
    });

    render(<ArenaPage />);

    // Simulate starting an arena
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);

    await waitFor(() => {
      expect(mockGetByPack).toHaveBeenCalled();
      expect(mockStartBattle).toHaveBeenCalled();
    });
  });
});



================================================================================
File: frontend\src\services\achievementApi.ts
================================================================================

import { axiosInstance, ApiResponseWrapper, handleApiError } from './apiUtils';
import type { Achievement, StudentAchievementResponse } from '../types';

export const achievementApi = {
  getAllAchievements: async (): ApiResponseWrapper<Achievement[]> => {
    try {
      // GET /api/achievements
      return await axiosInstance.get(`/achievements`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getStudentAchievements: async (studentId: string): ApiResponseWrapper<StudentAchievementResponse[]> => {
    try {
      // GET /api/achievements/students/{student_id}
      return await axiosInstance.get(`/students/${studentId}/achievements`);
    } catch (error) {
      throw handleApiError(error);
    }
  },
};



================================================================================
File: frontend\src\services\api.ts
================================================================================

// Re-export all API modules
export * from './apiUtils';
export * from './studentApi';
export * from './flashcardApi';
export * from './flashcardPackApi';
export * from './arenaApi';
export * from './matchApi';

// Note: This file now serves as a central export point for all API modules.
// Each domain has its own file with focused responsibilities and proper error handling.
// The shared axios instance and error handling utilities are in apiUtils.ts.



================================================================================
File: frontend\src\services\apiUtils.ts
================================================================================

import axios, { AxiosError, AxiosInstance, AxiosResponse } from 'axios';
import { ApiResponse } from '../types';

export const BASE_URL = 'http://localhost:8000/api';

// Create base axios instance with common config
export const createAxiosInstance = (): AxiosInstance => {
  return axios.create({
    baseURL: BASE_URL,
    headers: {
      'Content-Type': 'application/json',
    },
  });
};

// Shared axios instance
export const axiosInstance = createAxiosInstance();

// Error handling
export class ApiError extends Error {
  constructor(
    message: string,
    public status?: number,
    public data?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export const handleApiError = (error: unknown): never => {
  if (axios.isAxiosError(error)) {
    const axiosError = error as AxiosError<ApiResponse<any>>;
    const status = axiosError.response?.status;
    const message = axiosError.response?.data?.message || axiosError.message;
    const data = axiosError.response?.data;
    
    throw new ApiError(message, status, data);
  }
  
  if (error instanceof Error) {
    throw new ApiError(error.message);
  }
  
  throw new ApiError('An unknown error occurred');
};

// Type helper for API responses
export type ApiResponseWrapper<T> = Promise<AxiosResponse<ApiResponse<T>>>;


================================================================================
File: frontend\src\services\arenaApi.ts
================================================================================

import { ApiResponse } from '../types';
import { ArenaSession, ArenaMatch } from '../types/arena';
import { axiosInstance, ApiResponseWrapper, handleApiError } from './apiUtils';
import { transformMatchData } from '../utils/matchTransformUtils';
import { RawMatch } from './matchApi';

export interface ArenaResults {
  rankings: Array<{
    student_id: string;
    name: string;
    elo_rating: number;
    wins: number;
    losses: number;
    fights_played: number;
    elo_change: number;
  }>;
  matches: RawMatch[];
}

interface SetMatchWinnerResponse {
  match: RawMatch;
  arena_session: ArenaSession;
}

export const arenaApi = {
  createSession: async (data: { student_ids: string[]; num_rounds: number }): ApiResponseWrapper<ArenaSession> => {
    try {
      return await axiosInstance.post<ApiResponse<ArenaSession>>('/arena', data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getNextMatch: async (arenaId: string): ApiResponseWrapper<RawMatch> => {
    try {
      return await axiosInstance.get<ApiResponse<RawMatch>>(`/arena/${arenaId}/next-match`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  setMatchWinner: async (matchId: string, winnerIds: string[]): ApiResponseWrapper<SetMatchWinnerResponse> => {
    try {
      return await axiosInstance.patch<ApiResponse<SetMatchWinnerResponse>>(`/arena/matches/${matchId}/winner`, {
        winner_ids: winnerIds
      });
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getResults: async (arenaId: string): ApiResponseWrapper<ArenaResults> => {
    try {
      return await axiosInstance.get<ApiResponse<ArenaResults>>(`/arena/${arenaId}/results`);
    } catch (error) {
      throw handleApiError(error);
    }
  },
};


================================================================================
File: frontend\src\services\flashcardApi.ts
================================================================================

import { ApiResponse, Flashcard, CreateFlashcardRequest, FlashcardStats, FlashcardUsageStats, FlashcardArenaStats, BulkImportResult } from '../types';
import { axiosInstance, ApiResponseWrapper, handleApiError } from './apiUtils';

export const flashcardApi = {
  getAll: async (): ApiResponseWrapper<Flashcard[]> => {
    try {
      return await axiosInstance.get<ApiResponse<Flashcard[]>>('/flashcards/all');
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getById: async (id: string): ApiResponseWrapper<Flashcard> => {
    try {
      return await axiosInstance.get<ApiResponse<Flashcard>>(`/flashcards/${id}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  create: async (data: CreateFlashcardRequest): ApiResponseWrapper<Flashcard> => {
    try {
      return await axiosInstance.post<ApiResponse<Flashcard>>('/flashcards', data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  update: async (id: string, data: CreateFlashcardRequest): ApiResponseWrapper<Flashcard> => {
    try {
      return await axiosInstance.put<ApiResponse<Flashcard>>(`/flashcards/${id}`, data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  delete: async (id: string): ApiResponseWrapper<void> => {
    try {
      return await axiosInstance.delete(`/flashcards/${id}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getByPack: async (packId: string): ApiResponseWrapper<Flashcard[]> => {
    try {
      return await axiosInstance.get<ApiResponse<Flashcard[]>>(`/flashcards/pack/${packId}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  // Statistics endpoints
  getStats: async (id: string): ApiResponseWrapper<FlashcardStats> => {
    try {
      return await axiosInstance.get<ApiResponse<FlashcardStats>>(`/stats/flashcards/${id}/stats`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getMostUsed: async (limit?: number): ApiResponseWrapper<FlashcardUsageStats[]> => {
    try {
      return await axiosInstance.get<ApiResponse<FlashcardUsageStats[]>>('/stats/flashcards/most-used', {
        params: { limit }
      });
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getArenaStats: async (arenaId: string): ApiResponseWrapper<FlashcardArenaStats[]> => {
    try {
      return await axiosInstance.get<ApiResponse<FlashcardArenaStats[]>>(`/stats/arena/${arenaId}/flashcard-stats`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  // Bulk operations
  getImportTemplate: async (): Promise<Blob> => {
    try {
      const response = await axiosInstance.post<Blob>('/flashcards/template', null, { 
        responseType: 'blob' 
      });
      return response.data;
    } catch (error) {
      throw handleApiError(error);
    }
  },

  bulkImport: async (file: File): ApiResponseWrapper<BulkImportResult> => {
    try {
      const formData = new FormData();
      formData.append('file', file);
      return await axiosInstance.post<ApiResponse<BulkImportResult>>('/flashcards/bulk-import', formData, {
        headers: { 'Content-Type': 'multipart/form-data' },
      });
    } catch (error) {
      throw handleApiError(error);
    }
  },

  exportPack: async (packId: string): Promise<Blob> => {
    try {
      const response = await axiosInstance.get<Blob>(`/flashcards/export/${packId}`, { 
        responseType: 'blob' 
      });
      return response.data;
    } catch (error) {
      throw handleApiError(error);
    }
  },
};


================================================================================
File: frontend\src\services\flashcardEntityApi.ts
================================================================================

import type { Flashcard } from '../types';
import { flashcardApi } from './api';
import { EntityApi } from '../stores/createEntityStore';

export const flashcardEntityApi: EntityApi<Flashcard> = {
  getAll: async () => {
    const response = await flashcardApi.getAll();
    return response.data.data;
  },
  getById: async (id: string) => {
    const response = await flashcardApi.getById(id);
    return response.data.data;
  },
  create: async (data: Partial<Flashcard>) => {
    const response = await flashcardApi.create({
      question: data.question as string,
      answer: data.answer as string,
      pack_id: data.pack_id as string,
      difficulty: data.difficulty,
    });
    return response.data.data;
  },
  update: async (id: string, data: Partial<Flashcard>) => {
    const response = await flashcardApi.update(id, {
      question: data.question as string,
      answer: data.answer as string,
      pack_id: data.pack_id as string,
      difficulty: data.difficulty,
    });
    return response.data.data;
  },
  delete: async (id: string) => {
    await flashcardApi.delete(id);
  },
};

// Additional flashcard-specific operations that don't fit the EntityApi interface
export const flashcardExtraApi = {
  getByPack: flashcardApi.getByPack,
  getImportTemplate: flashcardApi.getImportTemplate,
  bulkImport: flashcardApi.bulkImport,
  exportPack: flashcardApi.exportPack,
};



================================================================================
File: frontend\src\services\flashcardPackApi.ts
================================================================================

import { ApiResponse, FlashcardPack, CreateFlashcardPackRequest } from '../types';
import { axiosInstance, ApiResponseWrapper, handleApiError } from './apiUtils';

export const flashcardPackApi = {
  getAll: async (): ApiResponseWrapper<FlashcardPack[]> => {
    try {
      return await axiosInstance.get<ApiResponse<FlashcardPack[]>>('/flashcards/packs');
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getById: async (id: string): ApiResponseWrapper<FlashcardPack> => {
    try {
      return await axiosInstance.get<ApiResponse<FlashcardPack>>(`/flashcards/packs/${id}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  create: async (data: CreateFlashcardPackRequest): ApiResponseWrapper<FlashcardPack> => {
    try {
      return await axiosInstance.post<ApiResponse<FlashcardPack>>('/flashcards/packs', data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  update: async (id: string, data: CreateFlashcardPackRequest): ApiResponseWrapper<FlashcardPack> => {
    try {
      return await axiosInstance.put<ApiResponse<FlashcardPack>>(`/flashcards/packs/${id}`, data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  delete: async (id: string): ApiResponseWrapper<void> => {
    try {
      return await axiosInstance.delete(`/flashcards/packs/${id}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },
};


================================================================================
File: frontend\src\services\flashcardPackEntityApi.ts
================================================================================

import type { FlashcardPack, CreateFlashcardPackRequest } from '../types';
import { flashcardPackApi } from './api';
import { EntityApi } from '../stores/createEntityStore';

export const flashcardPackEntityApi: EntityApi<FlashcardPack> = {
  getAll: async () => {
    const response = await flashcardPackApi.getAll();
    return response.data.data;
  },
  getById: async (id: string) => {
    const response = await flashcardPackApi.getById(id);
    return response.data.data;
  },
  create: async (data: Partial<FlashcardPack>) => {
    const response = await flashcardPackApi.create({
      name: data.name as string,
      description: data.description,
    });
    return response.data.data;
  },
  update: async (id: string, data: Partial<FlashcardPack>) => {
    const response = await flashcardPackApi.update(id, {
      name: data.name as string,
      description: data.description,
    });
    return response.data.data;
  },
  delete: async (id: string) => {
    await flashcardPackApi.delete(id);
  },
};



================================================================================
File: frontend\src\services\matchApi.ts
================================================================================

import { ApiResponse } from '../types';
import { axiosInstance, ApiResponseWrapper, handleApiError } from './apiUtils';
import { MatchStatus } from '../types';

// Shared interface for raw match data from API
export interface RawMatch {
  id: string;
  arena_id?: string;  // Optional since it was made nullable
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  participants: Array<{
    student_id: string;
    elo_before: number;
    elo_after: number | null;
  }>;
  winner_ids: string[];
  created_at: string;
  updated_at: string;
}

interface Round {
  id: string;
  match_id: string;
  flashcard_id: string;
  status: string;
  answers: {
    player_id: string;
    answer: string;
  }[];
  winner_ids: string[];
}

// Match API
export const matchApi = {
  createMultiplayer: async (data: { player_ids: string[]; num_rounds: number }): ApiResponseWrapper<RawMatch> => {
    try {
      return await axiosInstance.post<ApiResponse<RawMatch>>('/matches/multiplayer', data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  autoMatch: async (data: { num_players: number; num_rounds: number; student_id: string }): ApiResponseWrapper<RawMatch> => {
    try {
      return await axiosInstance.post<ApiResponse<RawMatch>>('/matches/auto-match', data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getById: async (matchId: string): ApiResponseWrapper<RawMatch> => {
    try {
      return await axiosInstance.get<ApiResponse<RawMatch>>(`/matches/${matchId}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  updateStatus: async (matchId: string, status: MatchStatus): ApiResponseWrapper<RawMatch> => {
    try {
      return await axiosInstance.patch<ApiResponse<RawMatch>>(`/matches/${matchId}/status`, { status });
    } catch (error) {
      throw handleApiError(error);
    }
  },
};

// Round API
export const roundApi = {
  create: async (data: { match_id: string; flashcard_id: string }): ApiResponseWrapper<Round> => {
    try {
      return await axiosInstance.post<ApiResponse<Round>>('/matches/rounds', data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  submitAnswer: async (roundId: string, playerId: string, answer: string): ApiResponseWrapper<Round> => {
    try {
      return await axiosInstance.post<ApiResponse<Round>>(`/matches/rounds/${roundId}/answer`, {
        player_id: playerId,
        answer,
      });
    } catch (error) {
      throw handleApiError(error);
    }
  },

  setWinners: async (roundId: string, winnerIds: string[]): ApiResponseWrapper<Round> => {
    try {
      return await axiosInstance.post<ApiResponse<Round>>(`/matches/rounds/${roundId}/winner`, {
        winner_ids: winnerIds,
      });
    } catch (error) {
      throw handleApiError(error);
    }
  },
};


================================================================================
File: frontend\src\services\studentApi.ts
================================================================================

import { ApiResponse, CreateStudentRequest, Student } from '../types';
import { axiosInstance, ApiResponseWrapper, handleApiError } from './apiUtils';

export const studentApi = {
  getAll: async (): ApiResponseWrapper<Student[]> => {
    try {
      return await axiosInstance.get<ApiResponse<Student[]>>('/students');
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getById: async (id: string): ApiResponseWrapper<Student> => {
    try {
      return await axiosInstance.get<ApiResponse<Student>>(`/students/${id}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  create: async (data: CreateStudentRequest): ApiResponseWrapper<Student> => {
    try {
      return await axiosInstance.post<ApiResponse<Student>>('/students', data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  update: async (id: string, data: CreateStudentRequest): ApiResponseWrapper<Student> => {
    try {
      return await axiosInstance.put<ApiResponse<Student>>(`/students/${id}`, data);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  delete: async (id: string): ApiResponseWrapper<void> => {
    try {
      return await axiosInstance.delete(`/students/${id}`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getStats: async (id: string): ApiResponseWrapper<Student> => {
    try {
      return await axiosInstance.get<ApiResponse<Student>>(`/students/${id}/stats`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  getHistory: async (id: string): ApiResponseWrapper<any[]> => {
    try {
      return await axiosInstance.get<ApiResponse<any[]>>(`/students/${id}/history`);
    } catch (error) {
      throw handleApiError(error);
    }
  },

  resetStats: async (id: string): ApiResponseWrapper<Student> => {
    try {
      return await axiosInstance.post<ApiResponse<Student>>(`/students/${id}/reset`);
    } catch (error) {
      throw handleApiError(error);
    }
  },
};


================================================================================
File: frontend\src\services\studentEntityApi.ts
================================================================================

import type { Student, CreateStudentRequest } from '../types';
import { studentApi } from './api';
import { EntityApi } from '../stores/createEntityStore';

export const studentEntityApi: EntityApi<Student> = {
  getAll: async () => {
    const response = await studentApi.getAll();
    return response.data.data;
  },
  getById: async (id: string) => {
    const response = await studentApi.getById(id);
    return response.data.data;
  },
  create: async (data: Partial<Student>) => {
    const response = await studentApi.create({
      name: data.name as string,
      avatar_url: data.avatar_url as string,
    });
    return response.data.data;
  },
  update: async (id: string, data: Partial<Student>) => {
    const response = await studentApi.update(id, {
      name: data.name as string,
      avatar_url: data.avatar_url as string,
    });
    return response.data.data;
  },
  delete: async (id: string) => {
    await studentApi.delete(id);
  },
};



================================================================================
File: frontend\src\stores\battleStore.ts
================================================================================

import { create } from 'zustand';
import type { StateCreator, StoreApi } from 'zustand';
import { createMatchSlice, type MatchSlice } from './slices/matchSlice';
import { createArenaSlice, type ArenaSlice } from './slices/arenaSlice';
import type { ArenaMatch, ArenaSession } from '../types/arena';

// Base state interface
interface BattleState {
  loading: boolean;
  error: string | null;
  currentArenaMatch: ArenaMatch | null;
  currentArenaSession: ArenaSession | null;
}

// Combined store type
type BattleStore = BattleState & MatchSlice & ArenaSlice;

// Middleware type
type StoreMiddleware = <T extends BattleState>(
  config: StateCreator<T, [], [], T>
) => StateCreator<T, [], [], T>;

// Middleware to handle loading and error states
const withLoadingMiddleware: StoreMiddleware = (config) => 
  (set, get, api) => {
    const wrappedSet: typeof set = (...args) => {
      const currentState = get();
      const newState = args[0];
      
      // Preserve loading and error states if they're not explicitly set
      if (typeof newState === 'object') {
        if (!('loading' in newState)) {
          (newState as any).loading = currentState.loading;
        }
        if (!('error' in newState)) {
          (newState as any).error = currentState.error;
        }
      }
      
      return set(...args);
    };
    
    return config(wrappedSet, get, api);
  };

// Initial state
const initialState: BattleState = {
  loading: false,
  error: null,
  currentArenaMatch: null,
  currentArenaSession: null,
};

// Create the store with middleware
export const useBattleStore = create<BattleStore>()(
  withLoadingMiddleware((set, get, _store) => ({
    ...initialState,
    ...createMatchSlice(set, get, _store),
    ...createArenaSlice(set, get, _store)
  }))
);



================================================================================
File: frontend\src\stores\createEntityStore.ts
================================================================================

import { StateCreator } from 'zustand';

/** 
 * Define a minimal interface for your API. 
 * You might have slightly different naming or additional methods, 
 * but the idea is that createEntityStore just needs to know how 
 * to do the 5 major CRUD ops plus maybe a custom "getStats".
 */
export interface EntityApi<T> {
  getAll: () => Promise<T[]>;
  getById?: (id: string) => Promise<T>; 
  create?: (data: Partial<T>) => Promise<T>;
  update?: (id: string, data: Partial<T>) => Promise<T>;
  delete?: (id: string) => Promise<void>;
  /** If you have custom endpoints like getStats, put them here. */
}

export interface EntityState<T> {
  items: T[];
  loading: boolean;
  error: string | null;
  fetchAll: () => Promise<void>;
  fetchOne?: (id: string) => Promise<void>;
  createItem?: (data: Partial<T>) => Promise<void>;
  updateItem?: (id: string, data: Partial<T>) => Promise<void>;
  deleteItem?: (id: string) => Promise<void>;
}

/**
 * This is the actual factory function that creates a slice of Zustand state 
 * for a given entity type `T`. 
 *
 * It receives an `entityName` (for better error messages) and an `api` 
 * object that knows how to perform the CRUD calls on that entity.
 */
export function createEntityStore<T>(
  entityName: string,
  api: EntityApi<T>
): StateCreator<
  EntityState<T>, // the slice we are creating
  [],
  [],
  EntityState<T>
> {
  return (set, get) => ({
    items: [],
    loading: false,
    error: null,

    // Fetch all
    fetchAll: async () => {
      set({ loading: true, error: null });
      try {
        const data = await api.getAll();
        set({
          items: data,
          loading: false,
          error: null,
        });
      } catch (err) {
        console.error(`Failed to fetchAll ${entityName}:`, err);
        set({
          error: `Failed to fetch ${entityName}`,
          loading: false,
        });
      }
    },

    // Optional: Fetch one
    fetchOne: api.getById
      ? async (id: string) => {
          set({ loading: true, error: null });
          try {
            const item = await api.getById!(id);
            // if you want to store this single item in items[], 
            // you can push or replace an existing item.
            const existingItems = get().items;
            const index = existingItems.findIndex((x: any) => (x.id || x._id) === id);
            if (index !== -1) {
              existingItems[index] = item;
            } else {
              existingItems.push(item);
            }
            set({
              items: [...existingItems],
              loading: false,
              error: null,
            });
          } catch (err) {
            console.error(`Failed to fetchOne ${entityName}:`, err);
            set({
              error: `Failed to fetch one ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,

    // Optional: Create
    createItem: api.create
      ? async (data: Partial<T>) => {
          set({ loading: true, error: null });
          try {
            const createdItem = await api.create!(data);
            // Fetch all items to ensure we have the latest state
            const allItems = await api.getAll();
            set({
              items: allItems,
              loading: false,
              error: null,
            });
          } catch (err) {
            console.error(`Failed to create ${entityName}:`, err);
            set({
              error: `Failed to create ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,

    // Optional: Update
    updateItem: api.update
      ? async (id: string, data: Partial<T>) => {
          set({ loading: true, error: null });
          try {
            const updatedItem = await api.update!(id, data);
            // Set local state first for immediate feedback
            set((state) => ({
              items: state.items.map((i: any) => {
                if ((i.id || i._id) === id) {
                  return updatedItem;
                }
                return i;
              }),
              loading: false,
              error: null,
            }));
            // Re-fetch from server to ensure we have the latest state
            await get().fetchAll();
          } catch (err) {
            console.error(`Failed to update ${entityName}:`, err);
            set({
              error: `Failed to update ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,

    // Optional: Delete
    deleteItem: api.delete
      ? async (id: string) => {
          set({ loading: true, error: null });
          try {
            await api.delete!(id);
            // Set local state first for immediate feedback
            set((state) => ({
              items: state.items.filter((i: any) => (i.id || i._id) !== id),
              loading: false,
              error: null,
            }));
            // Re-fetch from server to ensure we have the latest state
            await get().fetchAll();
          } catch (err) {
            console.error(`Failed to delete ${entityName}:`, err);
            set({
              error: `Failed to delete ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,
  });
}



================================================================================
File: frontend\src\stores\flashcardStore.ts
================================================================================

import { create } from 'zustand';
import { createEntityStore, EntityState } from './createEntityStore';
import { flashcardEntityApi, flashcardExtraApi } from '../services/flashcardEntityApi';
import type { Flashcard } from '../types';

interface FlashcardStoreState extends EntityState<Flashcard> {
  flashcards: Flashcard[];
  fetchFlashcards: () => Promise<void>;
  addFlashcard: (data: Partial<Flashcard>) => Promise<void>;
  updateFlashcard: (id: string, data: Partial<Flashcard>) => Promise<void>;
  deleteFlashcard: (id: string) => Promise<void>;
  getByPack: (packId: string) => Promise<void>;
}

const createStore = (
  set: (partial: Partial<FlashcardStoreState> | ((state: FlashcardStoreState) => Partial<FlashcardStoreState>)) => void,
  get: () => FlashcardStoreState,
  store: any
): FlashcardStoreState => {
  // Create a wrapped set function that syncs items and flashcards
  const wrappedSet = (
    partial: Partial<FlashcardStoreState> | ((state: FlashcardStoreState) => Partial<FlashcardStoreState>)
  ) => {
    set((state) => {
      const newState = typeof partial === 'function' ? partial(state) : partial;
      return {
        ...state,
        ...newState,
        // Ensure flashcards and items stay in sync
        items: 'items' in newState ? newState.items : state.items,
        flashcards: 'items' in newState ? newState.items : state.flashcards,
      };
    });
  };

  // Create the entity store with our wrapped set
  const entityStore = createEntityStore<Flashcard>(
    'flashcards',
    flashcardEntityApi
  )(wrappedSet, get, store);

  const getByPack = async (packId: string) => {
    wrappedSet({ loading: true, error: null });
    try {
      const response = await flashcardExtraApi.getByPack(packId);
      const items = response.data.data;
      wrappedSet({ items, loading: false });
    } catch (err) {
      console.error('Failed to get flashcards by pack:', err);
      wrappedSet({ error: 'Failed to get flashcards by pack', loading: false });
    }
  };

  // Initialize state and return store interface
  return {
    // Initialize with entityStore's state
    ...entityStore,
    // Add flashcard-specific state
    flashcards: entityStore.items,
    // Add flashcard-specific operations
    fetchFlashcards: entityStore.fetchAll,
    addFlashcard: entityStore.createItem!,
    updateFlashcard: entityStore.updateItem!,
    deleteFlashcard: entityStore.deleteItem!,
    // Add pack operations
    getByPack,
  };
};

export const useFlashcardStore = create<FlashcardStoreState>(createStore);



================================================================================
File: frontend\src\stores\importExportStore.ts
================================================================================

import { create } from 'zustand';
import { flashcardExtraApi } from '../services/flashcardEntityApi';
import { useFlashcardStore } from './flashcardStore';

interface ImportExportStoreState {
  loading: boolean;
  error: string | null;
  bulkImport: (file: File) => Promise<void>;
  getImportTemplate: () => Promise<void>;
  exportPack: (packId: string) => Promise<void>;
}

const createStore = (set: any, get: any): ImportExportStoreState => ({
  loading: false,
  error: null,

  bulkImport: async (file: File) => {
    set({ loading: true, error: null });
    try {
      await flashcardExtraApi.bulkImport(file);
      // Refresh the flashcards list after bulk import
      await useFlashcardStore.getState().fetchFlashcards();
      set({ loading: false });
    } catch (err) {
      console.error('Failed to bulk import flashcards:', err);
      set({
        error: 'Failed to bulk import flashcards',
        loading: false
      });
    }
  },

  getImportTemplate: async () => {
    try {
      await flashcardExtraApi.getImportTemplate();
    } catch (err) {
      console.error('Failed to get import template:', err);
      set({ error: 'Failed to get import template' });
    }
  },

  exportPack: async (packId: string) => {
    try {
      await flashcardExtraApi.exportPack(packId);
    } catch (err) {
      console.error('Failed to export pack:', err);
      set({ error: 'Failed to export pack' });
    }
  }
});

export const useImportExportStore = create<ImportExportStoreState>(createStore);



================================================================================
File: frontend\src\stores\index.ts
================================================================================

export { useStudentStore } from './studentStore';
export { useFlashcardStore } from './flashcardStore';
export { usePackStore } from './packStore';
export { useImportExportStore } from './importExportStore';
export { useBattleStore } from './battleStore';

// Re-export types that might be needed by components
export type { EntityState } from './createEntityStore';



================================================================================
File: frontend\src\stores\packStore.ts
================================================================================

import { create } from 'zustand';
import { createEntityStore, EntityState } from './createEntityStore';
import { flashcardPackEntityApi } from '../services/flashcardPackEntityApi';
import type { FlashcardPack } from '../types';

interface PackStoreState {
  packs: FlashcardPack[];
  loading: boolean;
  error: string | null;
  fetchPacks: () => Promise<void>;
  addPack: (data: Partial<FlashcardPack>) => Promise<void>;
  updatePack: (id: string, data: Partial<FlashcardPack>) => Promise<void>;
  deletePack: (id: string) => Promise<void>;
}

type SetState = (
  partial: Partial<PackStoreState> | 
  ((state: PackStoreState) => Partial<PackStoreState>),
  replace?: boolean
) => void;

const createCustomSet = (baseSet: SetState): SetState => (partial) => {
  baseSet((state) => {
    const newState = typeof partial === 'function' ? partial(state) : partial;
    return {
      ...state,
      ...newState
    };
  });
};

const createStore = (baseSet: any, get: any, _store: any): PackStoreState => {
  const set = createCustomSet(baseSet as SetState);
  
  const entityStore = createEntityStore<FlashcardPack>('packs', flashcardPackEntityApi)(
    (partial: EntityState<FlashcardPack> | Partial<EntityState<FlashcardPack>>) =>
      set((state) => ({
        ...state,
        loading: 'loading' in partial ? partial.loading : state.loading,
        error: 'error' in partial ? partial.error : state.error,
        packs: 'items' in partial ? partial.items : state.packs
      })),
    () => ({
      items: get().packs,
      loading: get().loading,
      error: get().error,
      fetchAll: get().fetchPacks,
    }),
    _store
  );

  return {
    // Initialize state
    packs: [],
    loading: false,
    error: null,

    // Pack operations
    fetchPacks: entityStore.fetchAll,
    addPack: entityStore.createItem!,
    updatePack: entityStore.updateItem!,
    deletePack: entityStore.deleteItem!
  };
};

export const usePackStore = create<PackStoreState>(createStore);



================================================================================
File: frontend\src\stores\studentStore.ts
================================================================================

import { create } from 'zustand';
import { createEntityStore, EntityState } from './createEntityStore';
import { studentEntityApi } from '../services/studentEntityApi';
import { studentApi } from '../services/api';
import type { Student, MatchHistoryItem } from '../types';
import { useBattleStore } from './battleStore';

interface StudentStoreState {
  // Base state
  students: Student[];
  loading: boolean;
  error: string | null;
  studentHistory: Record<string, MatchHistoryItem[]>;
  // Operations
  fetchStudents: () => Promise<void>;
  addStudent: (data: Partial<Student>) => Promise<void>;
  updateStudent: (id: string, data: Partial<Student>) => Promise<void>;
  deleteStudent: (id: string) => Promise<void>;
  // Custom functionality
  updateStudentStats: (studentId: string) => Promise<void>;
  fetchStudentHistory: (studentId: string) => Promise<void>;
  resetStudentStats: (studentId: string) => Promise<void>;
}

type SetState = (
  partial: Partial<StudentStoreState> | 
  ((state: StudentStoreState) => Partial<StudentStoreState>),
  replace?: boolean
) => void;

// Custom set function to handle state updates
const createCustomSet = (baseSet: SetState): SetState => (partial) => {
  baseSet((state) => {
    const newState = typeof partial === 'function' ? partial(state) : partial;
    return {
      ...state,
      ...newState
    };
  });
};

// Store implementation
const createStore = (baseSet: any, get: any, _store: any): StudentStoreState => {
  const set = createCustomSet(baseSet as SetState);

  // Create entity store directly
  const studentStore = createEntityStore<Student>(
    'students',
    studentEntityApi
  )(
    (partial) => set((state) => ({
      ...state,
      loading: 'loading' in partial ? partial.loading : state.loading,
      error: 'error' in partial ? partial.error : state.error,
      students: 'items' in partial ? partial.items : state.students
    })),
    () => {
      const state = get();
      return {
        items: state.students,
        loading: state.loading,
        error: state.error,
        fetchAll: state.fetchStudents,
        createItem: state.addStudent,
        updateItem: state.updateStudent,
        deleteItem: state.deleteStudent
      };
    },
    _store
  );

  return {
    // Initialize state
    students: [],
    loading: false,
    error: null,
    studentHistory: {},

    // Map operations
    fetchStudents: studentStore.fetchAll,
    addStudent: studentStore.createItem!,
    updateStudent: studentStore.updateItem!,
    deleteStudent: studentStore.deleteItem!,
    
    // Custom functionality
    updateStudentStats: async (studentId: string) => {
      try {
        const response = await studentApi.getStats(studentId);
        set((state) => ({
          ...state,
          students: state.students.map((student: Student) =>
            student.id === studentId ? response.data.data : student
          ),
          error: null
        }));
      } catch (err) {
        console.error('Failed to update student stats:', err);
        set((state) => ({
          ...state,
          error: 'Failed to update student stats'
        }));
      }
    },

    fetchStudentHistory: async (studentId: string) => {
      // Skip if we already have the history
      const currentState = get();
      if (studentId in currentState.studentHistory) {
        return;
      }
      
      set({ loading: true, error: null });
      try {
        const response = await studentApi.getHistory(studentId);
        const { data } = response.data;
        set(state => ({
          ...state,
          studentHistory: {
            ...state.studentHistory,
            [studentId]: data,
          },
          loading: false,
          error: null
        }));
      } catch (err) {
        console.error('Failed to fetch student history:', err);
        set({ loading: false, error: 'Failed to fetch student history' });
      }
    },

    resetStudentStats: async (studentId: string) => {
      set({ loading: true, error: null });
      try {
        const response = await studentApi.resetStats(studentId);
        
        // Update student in store and clear their match history
        set((state) => {
          const updatedHistory = { ...state.studentHistory };
          delete updatedHistory[studentId]; // Remove their entire history

          return {
            ...state,
            students: state.students.map((student) =>
              student.id === studentId ? response.data.data : student
            ),
            studentHistory: updatedHistory,
            loading: false,
            error: null
          };
        });

        // Reset arena state if the student is in the current session
        const battleStore = useBattleStore.getState();
        const currentSession = battleStore.currentArenaSession;
        if (currentSession?.participants.some(p => p.student_id === studentId)) {
          battleStore.resetArena();
        }
      } catch (err) {
        console.error('Failed to reset student stats:', err);
        set({
          loading: false,
          error: 'Failed to reset student stats'
        });
      }
    }
  };
};

// Create and export the store
export const useStudentStore = create<StudentStoreState>(createStore);



================================================================================
File: frontend\src\stores\slices\arenaSlice.ts
================================================================================

import type { StateCreator } from 'zustand';
import type { ArenaMatch, ArenaSession } from '../../types/arena';
import { arenaApi } from '../../services/api';
import { wrapStoreAction } from '../../utils/errorUtils';
import { transformMatchData } from '../../utils/matchTransformUtils';
import { ArenaSessionStatus } from '../../types';
import { useStudentStore } from '../studentStore';

export interface ArenaSlice {
  createArenaSession: (playerIds: string[], numRounds: number) => Promise<void>;
  getNextArenaMatch: () => Promise<void>;
  setArenaMatchWinner: (winnerIds: string[]) => Promise<{
    match: ArenaMatch;
    arena_session: ArenaSession;
  }>;
  getArenaResults: () => Promise<void>;
  resetArena: () => void;
}

export interface ArenaSliceState {
  currentArenaSession: ArenaSession | null;
  currentArenaMatch: ArenaMatch | null;
  loading: boolean;
  error: string | null;
}

type ArenaStateCreator = StateCreator<
  ArenaSliceState,
  [],
  [],
  ArenaSlice
>;

export const createArenaSlice: ArenaStateCreator = (set, get, store) => ({
  createArenaSession: async (playerIds: string[], numRounds: number) => {
    await wrapStoreAction(
      'create arena session',
      set,
      async () => {
        const response = await arenaApi.createSession({ 
          student_ids: playerIds,
          num_rounds: numRounds 
        });
        set({ currentArenaSession: response.data.data });
      }
    );
  },

  getNextArenaMatch: async () => {
    await wrapStoreAction(
      'get next match',
      set,
      async () => {
        const arenaSession = get().currentArenaSession;
        if (!arenaSession) throw new Error('No active arena session');

        const response = await arenaApi.getNextMatch(arenaSession.id);
        const transformedMatch = transformMatchData(response.data.data);
        set({ currentArenaMatch: transformedMatch });
      }
    );
  },

  setArenaMatchWinner: async (winnerIds: string[]) => {
    const result = await wrapStoreAction(
      'set match winner',
      set,
      async () => {
        const match = get().currentArenaMatch;
        if (!match) throw new Error('No active match');

        const response = await arenaApi.setMatchWinner(match.id, winnerIds);
        const { match: updatedMatch, arena_session: updatedArenaSession } = response.data.data;
        const transformedMatch = transformMatchData({ ...updatedMatch, winner_ids: winnerIds });

        set({
          currentArenaSession: updatedArenaSession,
          currentArenaMatch: transformedMatch
        });

        // Refresh the student store so UI sees updated ELO
        await useStudentStore.getState().fetchStudents();

        return {
          match: transformedMatch,
          arena_session: updatedArenaSession
        };
      }
    );
    
    if (!result) {
      throw new Error('Failed to set match winner');
    }
    
    return result;
  },

  getArenaResults: async () => {
    await wrapStoreAction(
      'get arena results',
      set,
      async () => {
        const arenaSession = get().currentArenaSession;
        if (!arenaSession) {
          console.warn('No arena session to fetch results for');
          return;
        }

        const response = await arenaApi.getResults(arenaSession.id);
        const { rankings } = response.data.data;

        if (!rankings || !Array.isArray(rankings)) {
          throw new Error('Invalid rankings data received from server');
        }

        set((state) => ({
          currentArenaSession: state.currentArenaSession
            ? {
                ...state.currentArenaSession,
                participants: rankings,
                status: ArenaSessionStatus.COMPLETED,
              }
            : null,
          currentArenaMatch: null
        }));
      }
    );
  },

  resetArena: () => {
    set({
      currentArenaSession: null,
      currentArenaMatch: null,
      error: null,
      loading: false
    });
  }
});


================================================================================
File: frontend\src\stores\slices\matchSlice.ts
================================================================================

import type { StateCreator } from 'zustand';
import { matchApi } from '../../services/api';
import { wrapStoreAction } from '../../utils/errorUtils';
import type { ArenaMatch } from '../../types/arena';
import { transformMatchData } from '../../utils/matchTransformUtils';

export interface MatchSlice {
  autoCreateMatch: (numPlayers: number, numRounds: number, studentId: string) => Promise<void>;
}

export interface MatchSliceState {
  currentArenaMatch: ArenaMatch | null;
  loading: boolean;
  error: string | null;
}

type MatchStateCreator = StateCreator<
  MatchSliceState,
  [],
  [],
  MatchSlice
>;

export const createMatchSlice: MatchStateCreator = (set, get, store) => ({
  autoCreateMatch: async (numPlayers: number, numRounds: number, studentId: string) => {
    await wrapStoreAction(
      'auto-create match',
      set,
      async () => {
        const response = await matchApi.autoMatch({ 
          num_players: numPlayers,
          num_rounds: numRounds,
          student_id: studentId
        });
        const transformedMatch = transformMatchData(response.data.data);
        set({ currentArenaMatch: transformedMatch });
      }
    );
  }
});


================================================================================
File: frontend\src\theme\index.ts
================================================================================

import { createTheme, MantineTheme } from '@mantine/core';

export const theme = createTheme({
  primaryColor: 'custom',

  colors: {
    custom: [
      '#EEEEEE', // 0 - Lightest
      '#DDDDDD', // 1
      '#CCCCCC', // 2
      '#66C3C8', // 3
      '#33B6BC', // 4
      '#00ADB5', // 5 - Primary accent
      '#009199', // 6
      '#393E46', // 7 - Secondary dark
      '#2C3238', // 8
      '#222831', // 9 - Primary dark
    ],
    dark: [
      '#EEEEEE', // 0 - Light text
      '#DDDDDD', // 1
      '#CCCCCC', // 2
      '#BBBBBB', // 3
      '#393E46', // 4
      '#2C3238', // 5
      '#272B33', // 6
      '#22262D', // 7
      '#1D2026', // 8
      '#222831', // 9 - Darkest background
    ],
  },

  white: '#EEEEEE',
  black: '#222831',
  
  defaultGradient: {
    from: 'custom.5',
    to: 'custom.7',
    deg: 45,
  },

  fontFamily: 'Inter, sans-serif',
  headings: {
    fontFamily: 'Inter, sans-serif',
    sizes: {
      h1: { fontSize: '2.5rem', fontWeight: '800', lineHeight: '1.2' },
      h2: { fontSize: '2rem', fontWeight: '700', lineHeight: '1.3' },
      h3: { fontSize: '1.5rem', fontWeight: '600', lineHeight: '1.4' },
    },
  },

  defaultRadius: 'lg',

  components: {
    Button: {
      defaultProps: {
        size: 'md',
        radius: 'lg',
      },
      styles: (theme: MantineTheme) => ({
        root: {
          fontWeight: '600',
          transition: 'transform 0.2s ease',
          '&:hover': {
            transform: 'translateY(-2px)',
          },
        },
      }),
    },
    Card: {
      defaultProps: {
        p: 'xl',
        shadow: 'md',
        radius: 'lg',
      },
      styles: (theme: MantineTheme) => ({
        root: {
          backgroundColor: theme.colors.custom[7],
          color: theme.colors.custom[0],
          transition: 'transform 0.2s ease, box-shadow 0.2s ease',
          '&:hover': {
            transform: 'translateY(-4px)',
            boxShadow: theme.shadows.lg,
          },
        },
      }),
    },
    AppShell: {
      styles: (theme: MantineTheme) => ({
        main: {
          backgroundColor: theme.colors.custom[9],
        },
        header: {
          background: theme.colors.custom[7],
          borderBottom: 'none',
        },
        navbar: {
          backgroundColor: theme.colors.custom[7],
          border: 'none',
          boxShadow: theme.shadows.sm,
        },
      }),
    },
  },
  // Custom theme properties for the battle arena
  other: {
    battleArena: {
      cardElevation: 3,
      animationDuration: 300,
      spacing: {
        xs: '0.5rem',
        sm: '1rem',
        md: '1.5rem',
        lg: '2rem',
        xl: '3rem',
      },
    },
  },
});

// Type for custom theme to be used with useTheme hook
declare module '@mantine/core' {
  export interface MantineThemeOther {
    battleArena: {
      cardElevation: number;
      animationDuration: number;
      spacing: {
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
      };
    };
  }
}



================================================================================
File: frontend\src\types\arena.ts
================================================================================

import type { Student, Flashcard, Match } from './index';
import { ArenaSessionStatus, MatchStatus } from './index';

export interface ArenaSession {
  id: string;
  status: ArenaSessionStatus;
  num_rounds: number;
  rounds_completed: number;
  participants: Array<{
    student_id: string;
    name: string;
    elo_rating: number;
    wins: number;
    losses: number;
    fights_played: number;
    elo_change: number;
  }>;
}

export interface ArenaMatch {
  id: string;
  arena_id?: string;
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  player1_id: string;
  player2_id: string;
  winner_ids?: string[];
  player1_elo_before: number;
  player2_elo_before: number;
  player1_elo_after?: number;
  player2_elo_after?: number;
  created_at: string;
  updated_at: string;
}

export enum ArenaStep {
  SETUP = 'setup',      // choose pack, players, rounds
  VERSUS = 'versus',    // show "VS" screen
  BATTLE = 'battle',    // show random flashcard
  ROUND_RESULT = 'round_result',
  FINAL_RESULT = 'final_result'
}

export interface ParticipantScore {
  student: Student;
  eloBefore: number;
  eloCurrent: number;
  wins: number;
  losses: number;
  fightsPlayed: number;
  totalEloChange: number;
}

export interface ValidationError {
  pack?: string;
  players?: string;
  rounds?: string;
}

export interface ArenaSetupData {
  selectedPackId: string;
  numRounds: number;
  selectedPlayerIds: string[];
}



================================================================================
File: frontend\src\types\index.ts
================================================================================

export enum DifficultyLevel {
  EASY = "easy",
  MEDIUM = "medium",
  HARD = "hard"
}

export enum MatchStatus {
  PENDING = "pending",
  IN_PROGRESS = "in_progress",
  COMPLETED = "completed",
  CANCELLED = "cancelled"
}

export enum ArenaSessionStatus {
  PENDING = "pending",
  IN_PROGRESS = "in_progress",
  COMPLETED = "completed"
}

export interface Student {
  id: string;
  name: string;
  elo_rating: number;
  wins: number;
  losses: number;
  total_matches: number;
  created_at: string;
  updated_at: string;
  win_rate: number;
  avatar_url?: string;
}

export interface Flashcard {
  id: string;
  question: string;
  answer: string;
  pack_id: string;
  difficulty: DifficultyLevel;
  times_used: number;
  times_correct: number;
  created_at: string;
  updated_at: string;
  success_rate: number;
}

export interface FlashcardPack {
  id: string;
  name: string;
  description?: string;
  created_at: string;
  updated_at: string;
}

export interface MatchParticipant {
  student_id: string;
  elo_before?: number;
  elo_after?: number;
  student?: Student;
}

export interface RoundParticipant {
  student_id: string;
  elo_before?: number;
  elo_change?: number;
  answer?: string;
  student?: Student;
}

export interface Match {
  id: string;
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  winner_ids?: string[];
  created_at: string;
  updated_at: string;
  participants: MatchParticipant[];
  winners?: Student[];
  rounds?: Round[];
}

export interface Round {
  id: string;
  match_id: string;
  flashcard_id: string;
  winner_ids?: string[];
  created_at: string;
  match?: Match;
  flashcard?: Flashcard;
  winners?: Student[];
  participants: RoundParticipant[];
}

// Arena Types
export interface ArenaSession {
  id: string;
  status: ArenaSessionStatus;
  num_rounds: number;
  rounds_completed: number;
  created_at: string;
  updated_at: string;
  participants?: Array<ArenaStudentStats>;
}

export interface ArenaMatch {
  id: string;
  arena_id?: string;
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  player1_id: string;
  player2_id: string;
  winner_ids?: string[];
  player1_elo_before: number;
  player2_elo_before: number;
  player1_elo_after?: number;
  player2_elo_after?: number;
  created_at: string;
  updated_at: string;
}

export interface ArenaStudentStats {
  student_id: string;
  name?: string;
  elo_rating?: number;
  wins?: number;
  losses?: number;
  fights_played?: number;
  elo_change?: number;
  elo_before?: number;
  elo_after?: number;
  student?: Student;
}

// API Request/Response Types
export interface CreateArenaRequest {
  student_ids: string[];
  num_rounds: number;
}

export interface SetMatchWinnerRequest {
  winner_ids: string[];
}

export interface CreateStudentRequest {
  name: string;
  avatar_url?: string; // EXACT field to match the new backend
}

export interface CreateFlashcardRequest {
  question: string;
  answer: string;
  pack_id: string;
  difficulty?: DifficultyLevel;
}

export interface CreateFlashcardPackRequest {
  name: string;
  description?: string;
}

export interface CreateMultiplayerMatchRequest {
  player_ids: string[];
  num_rounds: number;
}

export interface AutoMatchRequest {
  num_players: number;
  num_rounds: number;
  student_id: string;
}

export interface CreateRoundRequest {
  match_id: string;
  flashcard_id: string;
}

export interface RoundWinnerRequest {
  round_id: string;
  winner_ids: string[];
}

// Bulk Operations Types
export interface BulkImportResult {
  total: number;
  successful: number;
  failed: number;
  errors: string[];
}

// Flashcard Statistics Types
export interface FlashcardStats {
  total_uses: number;
  success_rate: number;
  average_winners: number;
  used_in_arenas: number;
}

export interface FlashcardUsageStats {
  id: string;
  question: string;
  usage_count: number;
  success_rate: number;
  used_in_arenas: number;
}

export interface FlashcardArenaStats {
  id: string;
  question: string;
  times_used: number;
  success_rate: number;
}

export interface MatchHistoryItem {
  match_id: string;
  date: string;
  opponent_name: string;
  old_elo: number;
  new_elo: number;
  elo_change: number;
  result: 'win' | 'loss' | 'unknown';
}

// Test Helper Types
export type ArenaParticipantTestData = Pick<ArenaStudentStats, 'student_id' | 'student' | 'elo_before' | 'elo_after' | 'wins' | 'losses'>;

// Achievement Types
export interface Achievement {
  id: string;
  code: string;
  title: string;
  description?: string;
  criteria?: any;
  created_at: string;
  updated_at: string;
}

export interface StudentAchievementResponse {
  id: string;
  student_id: string;
  achievement: Achievement;
  achieved_at: string;
}

// API Response Types
export interface ApiResponse<T> {
  data: T;
  message?: string;
  error?: string;
}



================================================================================
File: frontend\src\utils\errorUtils.ts
================================================================================

type SetErrorState = (state: { error: string | null; loading: boolean }) => void;

export const handleStoreError = (err: unknown): string => {
  if (err instanceof Error) {
    return err.message;
  }
  if (typeof err === 'string') {
    return err;
  }
  return 'An unknown error occurred';
};

export const wrapStoreAction = async <T>(
  operation: string,
  setState: SetErrorState,
  action: () => Promise<T>
): Promise<T> => {
  setState({ loading: true, error: null });
  try {
    const result = await action();
    setState({ loading: false, error: null });
    return result;
  } catch (err) {
    const errorMessage = handleStoreError(err);
    console.error(`Failed to ${operation}:`, err);
    setState({ 
      error: errorMessage,
      loading: false 
    });
    throw new Error(errorMessage);
  }
};


================================================================================
File: frontend\src\utils\matchTransformUtils.ts
================================================================================

import type { ArenaMatch } from '../types/arena';
import { MatchStatus } from '../types';

interface MatchParticipant {
  student_id: string;
  elo_before: number;
  elo_after: number | null;
}

interface RawMatch {
  id: string;
  arena_id?: string;
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  participants: MatchParticipant[];
  winner_ids: string[];
  created_at: string;
  updated_at: string;
}

export const transformMatchData = (match: RawMatch): ArenaMatch => {
  if (!match.participants || match.participants.length !== 2) {
    throw new Error('Invalid match data: Expected exactly 2 participants');
  }

  const transformedMatch: ArenaMatch = {
    id: match.id,
    ...(match.arena_id && { arena_id: match.arena_id }),
    status: match.status,
    num_rounds: match.num_rounds,
    rounds_completed: match.rounds_completed,
    player1_id: match.participants[0].student_id,
    player2_id: match.participants[1].student_id,
    player1_elo_before: match.participants[0].elo_before,
    player2_elo_before: match.participants[1].elo_before,
    player1_elo_after: match.participants[0].elo_after ?? undefined,
    player2_elo_after: match.participants[1].elo_after ?? undefined,
    winner_ids: match.winner_ids || [],
    created_at: match.created_at,
    updated_at: match.updated_at
  };

  return transformedMatch;
};


================================================================================
File: frontend\src\utils\playerUtils.ts
================================================================================

import { Student } from '../types';

interface MatchPlayers {
  player1: Student;
  player2: Student;
}

export const findMatchPlayers = (
  students: Student[],
  player1Id: string,
  player2Id: string
): MatchPlayers | Error => {
  const player1 = students.find(s => s.id === player1Id);
  const player2 = students.find(s => s.id === player2Id);

  if (!player1 || !player2) {
    return new Error('Players not found');
  }

  return { player1, player2 };
};

export const createParticipantData = (
  player: Student,
  eloBefore: number
) => ({
  student_id: player.id,
  student: player,
  elo_before: eloBefore,
});

