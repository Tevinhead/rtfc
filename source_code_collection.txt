
================================================================================
File: compile.py
================================================================================

import os
import fnmatch
import sys
import os

# Add the backend directory to Python path
sys.path.append(os.path.join(os.path.dirname(__file__), 'backend'))
from app.core.logging import get_logger

logger = get_logger(__name__)

def collect_source_code(root_dir, output_file):
    """
    Collects source code files from a directory tree, excluding specified
    directories and file patterns, and writes the collected code to an
    output file.
    """

    # Directories to exclude - These are not relevant for most context or are too large
    exclude_dirs = {
        'node_modules',
        'dist',
        'build',
        '__pycache__',
        'venv',
        '.git',
        'public',
        'assets',
        'logs', 
    }

    # File patterns to include - Focus on core code files
    include_patterns = [
        '*.py',
        '*.tsx',
        '*.ts',
        '*.js',
        '*.jsx',
        '*.css',
        '*.scss',
        '*.html',
    ]

    # Specific files to exclude - These might contain secrets, configs, or are generally not needed for context
    exclude_files = {
        'package.json',
        'package-lock.json',
        'tsconfig.json',
        'vite.config.ts',
        'requirements.txt',
        '.env',
        '.gitignore',
        'README.md',
        'source_code_collection.txt' # Exclude the output file itself
    }

    with open(output_file, 'w', encoding='utf-8') as outfile:
        for root, dirs, files in os.walk(root_dir):
            # Remove excluded directories in-place to prevent os.walk from traversing them
            dirs[:] = [d for d in dirs if d not in exclude_dirs]

            for file in files:
                if file in exclude_files:
                    continue

                # Check if file matches include patterns
                if any(fnmatch.fnmatch(file, pattern) for pattern in include_patterns):
                    file_path = os.path.join(root, file)
                    relative_path = os.path.relpath(file_path, root_dir)

                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            # Write file header with separators
                            outfile.write(f'\n{"="*80}\n')
                            outfile.write(f'File: {relative_path}\n')
                            outfile.write(f'{"="*80}\n\n')

                            # Write file contents
                            outfile.write(infile.read())
                            outfile.write('\n\n')
                    except Exception as e:
                        error_msg = f'Error reading {relative_path}: {str(e)}'
                        logger.error("File read error", 
                                   error=str(e),
                                   file_path=relative_path)
                        outfile.write(f'{error_msg}\n\n')

if __name__ == '__main__':
    root_directory = '.'  # Parent directory
    output_file = 'source_code_collection.txt'

    logger.info("Starting source code collection",
                root_directory=root_directory,
                output_file=output_file)
    
    try:
        collect_source_code(root_directory, output_file)
        logger.info("Source code collection complete",
                   output_file=output_file)
    except Exception as e:
        logger.exception("Source code collection failed",
                        error=str(e))
        raise



================================================================================
File: backend\alter_version_table.py
================================================================================

import asyncio
from app.database import engine
from sqlalchemy import text

async def alter_table():
    async with engine.connect() as conn:
        await conn.execute(text("ALTER TABLE alembic_version ALTER COLUMN version_num TYPE varchar(128);"))
        await conn.commit()
        print("Successfully altered alembic_version table")

if __name__ == "__main__":
    asyncio.run(alter_table())



================================================================================
File: backend\check_and_fix_alembic_version.py
================================================================================

import asyncio
import os
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import text
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Get database URL and ensure it uses the async driver
DATABASE_URL = os.getenv("DATABASE_URL")
if DATABASE_URL and DATABASE_URL.startswith("postgresql://"):
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

# Create an async engine
engine = create_async_engine(DATABASE_URL, echo=True)

async def check_table_structure():
    async with engine.connect() as conn:
        # Query to get column information for matches table
        result = await conn.execute(text("""
            SELECT column_name, data_type, is_nullable
            FROM information_schema.columns
            WHERE table_name = 'matches'
            ORDER BY ordinal_position;
        """))
        columns = result.fetchall()
        print("\nMatches table structure:")
        for col in columns:
            print(f"Column: {col[0]}, Type: {col[1]}, Nullable: {col[2]}")

async def check_and_fix_alembic_version():
    async with engine.connect() as conn:
        # 1) Check what's in alembic_version
        result = await conn.execute(text("SELECT version_num FROM alembic_version"))
        row = result.fetchone()

        if row:
            current_version = row[0]
            print(f"Current alembic_version: {current_version}")
        else:
            print("No version found in alembic_version table.")
            return

        # 2) Force update to the latest revision
        if current_version != "20240130_make_arena_id_nullable":
            # Set it to the latest revision
            new_revision = "20240130_make_arena_id_nullable"
            # First delete any existing rows
            await conn.execute(text("DELETE FROM alembic_version"))
            # Then insert the new version
            await conn.execute(
                text("INSERT INTO alembic_version (version_num) VALUES (:rev)"),
                {"rev": new_revision}
            )
            await conn.commit()
            print(f"Updated alembic_version to {new_revision}.")
        else:
            print("Alembic version is already at latest revision.")

async def main():
    await check_and_fix_alembic_version()
    await check_table_structure()
    await engine.dispose()

if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: backend\check_version.py
================================================================================

from sqlalchemy import create_engine, text
from os import environ
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get database URL from environment
database_url = environ.get('DATABASE_URL')

try:
    # Create engine
    engine = create_engine(database_url.replace('+asyncpg', ''))  # Use sync driver for this script
    
    # Connect and check current version
    with engine.connect() as connection:
        result = connection.execute(text("SELECT version_num FROM alembic_version")).fetchone()
        print(f"Current version in database: {result[0] if result else 'No version found'}")
        
        # Update to a known good revision (20240110_add_arena_battles)
        if result and result[0] == '3f1bd2862147':
            connection.execute(text("UPDATE alembic_version SET version_num = '20240110_add_arena_battles'"))
            connection.commit()
            print("Updated version to 20240110_add_arena_battles")
    
except Exception as e:
    print(f"Error: {e}")



================================================================================
File: backend\fix_alembic.py
================================================================================

from sqlalchemy import create_engine, text
from os import environ
from dotenv import load_dotenv

# Load environment variables from .env file
load_dotenv()

# Get database URL from environment
database_url = environ.get('DATABASE_URL')

try:
    # Create engine
    engine = create_engine(database_url)
    
    # Connect and execute update
    with engine.connect() as connection:
        connection.execute(text("UPDATE alembic_version SET version_num = '20240110_add_arena_battles'"))
        connection.commit()
    
    print("Successfully updated alembic_version table")
    
except Exception as e:
    print(f"Error: {e}")



================================================================================
File: backend\make_nullable.py
================================================================================

from app.database import engine
import asyncio
from sqlalchemy import text

async def make_arena_id_nullable():
    async with engine.connect() as conn:
        await conn.execute(text('ALTER TABLE matches ALTER COLUMN arena_id DROP NOT NULL'))
        await conn.commit()
        print("Successfully made arena_id nullable")

if __name__ == '__main__':
    asyncio.run(make_arena_id_nullable())



================================================================================
File: backend\alembic\env.py
================================================================================

from logging.config import fileConfig
import os
from dotenv import load_dotenv
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config
from alembic import context

# Load environment variables
load_dotenv()

import sys
from pathlib import Path

# Add the parent directory to sys.path
sys.path.append(str(Path(__file__).parent.parent))

# Import models and Base
from app.database import Base
import app.models.student
import app.models.flashcard
import app.models.match

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Set target metadata
target_metadata = Base.metadata

# Get database URL from environment
db_url = os.getenv("DATABASE_URL")
if not db_url:
    raise ValueError("DATABASE_URL must be set")

# Replace postgresql:// with postgresql+asyncpg:// for async SQLAlchemy
if db_url.startswith("postgresql://"):
    db_url = db_url.replace("postgresql://", "postgresql+asyncpg://", 1)

config.set_main_option("sqlalchemy.url", db_url)

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def do_run_migrations(connection: Connection) -> None:
    context.configure(connection=connection, target_metadata=target_metadata)

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """In this scenario we need to create an Engine
    and associate a connection with the context.
    """
    configuration = config.get_section(config.config_ini_section, {})
    configuration["sqlalchemy.url"] = db_url

    connectable = async_engine_from_config(
        configuration,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        await connection.run_sync(do_run_migrations)

    await connectable.dispose()


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    import asyncio
    asyncio.run(run_async_migrations())



================================================================================
File: backend\alembic\versions\0312ea2413c8_remove_email_from_students.py
================================================================================

"""remove_email_from_students

Revision ID: 0312ea2413c8
Revises: 43d5d5646264
Create Date: 2024-12-23 23:21:32.334539

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '0312ea2413c8'
down_revision: Union[str, None] = '43d5d5646264'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    op.drop_column('students', 'email')


def downgrade() -> None:
    op.add_column('students',
        sa.Column('email', sa.String(), nullable=False, unique=True)
    )



================================================================================
File: backend\alembic\versions\20240101_add_match_participants.py
================================================================================

"""add match participants

Revision ID: 20240101_add_match_participants
Revises: 0312ea2413c8
Create Date: 2024-01-01

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240101_add_match_participants'
down_revision = '0312ea2413c8'
branch_labels = None
depends_on = None

def upgrade():
    # Create match_participants table
    op.create_table(
        'match_participants',
        sa.Column('match_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_after', sa.Float(), nullable=True),
        sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('match_id', 'student_id')
    )

    # Create round_participants table
    op.create_table(
        'round_participants',
        sa.Column('round_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_change', sa.Float(), nullable=True),
        sa.Column('answer', sa.String(), nullable=True),
        sa.ForeignKeyConstraint(['round_id'], ['rounds.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('round_id', 'student_id')
    )

def downgrade():
    op.drop_table('round_participants')
    op.drop_table('match_participants')



================================================================================
File: backend\alembic\versions\20240110_add_arena_battles.py
================================================================================

"""add arena battles

Revision ID: 20240110_add_arena_battles
Revises: abcde_add_elo_before_to_matches
Create Date: 2024-01-10

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240110_add_arena_battles'
down_revision = 'abcde_add_elo_before_to_matches'
branch_labels = None
depends_on = None

def upgrade():
    # Create enums if they don't exist
    op.execute("DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'arena_session_status') THEN CREATE TYPE arena_session_status AS ENUM ('pending', 'in_progress', 'completed'); END IF; END $$")
    op.execute("DO $$ BEGIN IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'match_status') THEN CREATE TYPE match_status AS ENUM ('pending', 'in_progress', 'completed'); END IF; END $$")
    
    # Create arena_sessions table
    op.create_table(
        'arena_sessions',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('status', postgresql.ENUM('pending', 'in_progress', 'completed', name='arena_session_status', create_type=False), nullable=False),
        sa.Column('num_rounds', sa.Integer(), nullable=False),
        sa.Column('rounds_completed', sa.Integer(), nullable=False, server_default='0'),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'))
    )
    
    # Create arena_participants table
    op.create_table(
        'arena_participants',
        sa.Column('arena_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('fights_played', sa.Integer(), nullable=False, server_default='0'),
        sa.ForeignKeyConstraint(['arena_id'], ['arena_sessions.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('arena_id', 'student_id')
    )
    
    # Drop old tables if they exist
    op.execute("DROP TABLE IF EXISTS round_participants CASCADE")
    op.execute("DROP TABLE IF EXISTS rounds CASCADE")
    op.execute("DROP TABLE IF EXISTS match_participants CASCADE")
    op.execute("DROP TABLE IF EXISTS matches CASCADE")
    
    # Create new matches table for 1v1 battles
    op.create_table(
        'matches',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('arena_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('round_number', sa.Integer(), nullable=False),
        sa.Column('status', postgresql.ENUM('pending', 'in_progress', 'completed', name='match_status', create_type=False), nullable=False),
        sa.Column('player1_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('player2_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('winner_id', postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column('player1_elo_before', sa.Float(), nullable=False),
        sa.Column('player2_elo_before', sa.Float(), nullable=False),
        sa.Column('player1_elo_after', sa.Float(), nullable=True),
        sa.Column('player2_elo_after', sa.Float(), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.ForeignKeyConstraint(['arena_id'], ['arena_sessions.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['player1_id'], ['students.id']),
        sa.ForeignKeyConstraint(['player2_id'], ['students.id']),
        sa.ForeignKeyConstraint(['winner_id'], ['students.id'])
    )

def downgrade():
    # Drop new tables
    op.drop_table('matches')
    op.drop_table('arena_participants')
    op.drop_table('arena_sessions')
    
    # Drop enums if they exist
    op.execute("DROP TYPE IF EXISTS arena_session_status")
    op.execute("DROP TYPE IF EXISTS match_status")
    
    # Recreate old tables (not implemented for brevity)
    pass



================================================================================
File: backend\alembic\versions\20240127_update_matches.py
================================================================================

"""update matches for multiplayer

Revision ID: 20240127_update_matches
Revises: 20240110_add_arena_battles
Create Date: 2024-01-27

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240127_update_matches'
down_revision = '20240110_add_arena_battles'
branch_labels = None
depends_on = None

def upgrade():
    # Drop old tables and constraints
    op.drop_constraint('matches_player1_id_fkey', 'matches', type_='foreignkey')
    op.drop_constraint('matches_player2_id_fkey', 'matches', type_='foreignkey')
    op.drop_constraint('matches_winner_id_fkey', 'matches', type_='foreignkey')
    
    # Drop old columns from matches
    op.drop_column('matches', 'player1_id')
    op.drop_column('matches', 'player2_id')
    op.drop_column('matches', 'winner_id')
    op.drop_column('matches', 'player1_elo_before')
    op.drop_column('matches', 'player2_elo_before')
    op.drop_column('matches', 'player1_elo_after')
    op.drop_column('matches', 'player2_elo_after')
    op.drop_column('matches', 'round_number')
    
    # Add new columns to matches
    op.add_column('matches', sa.Column('num_rounds', sa.Integer(), nullable=False, server_default='1'))
    op.add_column('matches', sa.Column('rounds_completed', sa.Integer(), nullable=False, server_default='0'))
    
    # Create match_participants table
    op.create_table(
        'match_participants',
        sa.Column('match_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_after', sa.Float(), nullable=True),
        sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('match_id', 'student_id')
    )
    
    # Create rounds table
    op.create_table(
        'rounds',
        sa.Column('id', postgresql.UUID(as_uuid=True), primary_key=True),
        sa.Column('match_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('flashcard_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('round_number', sa.Integer(), nullable=False),
        sa.Column('winner_ids', postgresql.ARRAY(postgresql.UUID(as_uuid=True)), nullable=True),
        sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()')),
        sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['flashcard_id'], ['flashcards.id'])
    )
    
    # Create round_participants table
    op.create_table(
        'round_participants',
        sa.Column('round_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('student_id', postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column('elo_before', sa.Float(), nullable=True),
        sa.Column('elo_change', sa.Float(), nullable=True),
        sa.Column('answer', sa.String(), nullable=True),
        sa.ForeignKeyConstraint(['round_id'], ['rounds.id'], ondelete='CASCADE'),
        sa.ForeignKeyConstraint(['student_id'], ['students.id'], ondelete='CASCADE'),
        sa.PrimaryKeyConstraint('round_id', 'student_id')
    )

def downgrade():
    # Drop new tables
    op.drop_table('round_participants')
    op.drop_table('rounds')
    op.drop_table('match_participants')
    
    # Drop new columns from matches
    op.drop_column('matches', 'num_rounds')
    op.drop_column('matches', 'rounds_completed')
    
    # Add back old columns to matches
    op.add_column('matches', sa.Column('player1_id', postgresql.UUID(as_uuid=True), nullable=False))
    op.add_column('matches', sa.Column('player2_id', postgresql.UUID(as_uuid=True), nullable=False))
    op.add_column('matches', sa.Column('winner_id', postgresql.UUID(as_uuid=True), nullable=True))
    op.add_column('matches', sa.Column('player1_elo_before', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player2_elo_before', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player1_elo_after', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player2_elo_after', sa.Float(), nullable=True))
    
    # Add back foreign key constraints
    op.create_foreign_key('matches_player1_id_fkey', 'matches', 'students', ['player1_id'], ['id'])
    op.create_foreign_key('matches_player2_id_fkey', 'matches', 'students', ['player2_id'], ['id'])
    op.create_foreign_key('matches_winner_id_fkey', 'matches', 'students', ['winner_id'], ['id'])



================================================================================
File: backend\alembic\versions\20240130_make_arena_id_nullable.py
================================================================================

"""make arena id nullable

Revision ID: 20240130_make_arena_id_nullable
Revises: 20240127_update_matches
Create Date: 2024-01-30

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20240130_make_arena_id_nullable'
down_revision = '20240127_update_matches'
branch_labels = None
depends_on = None

def upgrade():
    # Make arena_id nullable
    op.alter_column('matches', 'arena_id',
               existing_type=postgresql.UUID(),
               nullable=True)

def downgrade():
    # Make arena_id non-nullable again
    op.alter_column('matches', 'arena_id',
               existing_type=postgresql.UUID(),
               nullable=False)



================================================================================
File: backend\alembic\versions\20250110_add_match_winner_ids.py
================================================================================

"""add winner_ids array to matches

Revision ID: 20250110_add_match_winner_ids
Revises: abcde_add_elo_before_to_matches
Create Date: 2025-01-10

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = '20250110_add_match_winner_ids'
down_revision = 'abcde_add_elo_before_to_matches'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column(
        'matches',
        sa.Column('winner_ids', postgresql.ARRAY(postgresql.UUID(as_uuid=True)), nullable=True)
    )

def downgrade():
    op.drop_column('matches', 'winner_ids')



================================================================================
File: backend\alembic\versions\20250111_add_avatar_url_to_students.py
================================================================================

"""
Add avatar_url to students

Revision ID: 20250111_add_avatar_url_to_students
Revises: 20250110_add_match_winner_ids
Create Date: 2025-01-11
"""

from alembic import op
import sqlalchemy as sa

# revision identifiers, used by Alembic.
revision = '20250111_add_avatar_url_to_students'
down_revision = '20250110_add_match_winner_ids'
branch_labels = None
depends_on = None

def upgrade():
    op.add_column('students', sa.Column('avatar_url', sa.String(), nullable=True))

def downgrade():
    op.drop_column('students', 'avatar_url')



================================================================================
File: backend\alembic\versions\43d5d5646264_initial_schema.py
================================================================================

"""Initial schema

Revision ID: 43d5d5646264
Revises: 
Create Date: 2024-12-22 14:43:11.278303

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '43d5d5646264'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('flashcard_packs',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('description', sa.String(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('students',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('name', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('elo_rating', sa.Float(), nullable=True),
    sa.Column('wins', sa.Integer(), nullable=True),
    sa.Column('losses', sa.Integer(), nullable=True),
    sa.Column('total_matches', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('email')
    )
    op.create_table('flashcards',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('question', sa.String(), nullable=False),
    sa.Column('answer', sa.String(), nullable=False),
    sa.Column('pack_id', sa.UUID(), nullable=False),
    sa.Column('difficulty', sa.Enum('EASY', 'MEDIUM', 'HARD', name='difficultylevel'), nullable=True),
    sa.Column('times_used', sa.Integer(), nullable=True),
    sa.Column('times_correct', sa.Integer(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['pack_id'], ['flashcard_packs.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('matches',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('player1_id', sa.UUID(), nullable=False),
    sa.Column('player2_id', sa.UUID(), nullable=False),
    sa.Column('winner_id', sa.UUID(), nullable=True),
    sa.Column('status', sa.Enum('PENDING', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED', name='matchstatus'), nullable=True),
    sa.Column('player1_elo_change', sa.Float(), nullable=True),
    sa.Column('player2_elo_change', sa.Float(), nullable=True),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.Column('updated_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['player1_id'], ['students.id'], ),
    sa.ForeignKeyConstraint(['player2_id'], ['students.id'], ),
    sa.ForeignKeyConstraint(['winner_id'], ['students.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_table('rounds',
    sa.Column('id', sa.UUID(), nullable=False),
    sa.Column('match_id', sa.UUID(), nullable=False),
    sa.Column('flashcard_id', sa.UUID(), nullable=False),
    sa.Column('winner_id', sa.UUID(), nullable=True),
    sa.Column('player1_answer', sa.String(), nullable=True),
    sa.Column('player2_answer', sa.String(), nullable=True),
    sa.Column('round_number', sa.String(), nullable=False),
    sa.Column('created_at', sa.DateTime(timezone=True), server_default=sa.text('now()'), nullable=True),
    sa.ForeignKeyConstraint(['flashcard_id'], ['flashcards.id'], ),
    sa.ForeignKeyConstraint(['match_id'], ['matches.id'], ),
    sa.ForeignKeyConstraint(['winner_id'], ['students.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade() -> None:
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('rounds')
    op.drop_table('matches')
    op.drop_table('flashcards')
    op.drop_table('students')
    op.drop_table('flashcard_packs')
    # ### end Alembic commands ###



================================================================================
File: backend\alembic\versions\623fcaf9bd91_merge_multiple_heads.py
================================================================================

"""merge multiple heads

Revision ID: 623fcaf9bd91
Revises: 20240130_make_arena_id_nullable, 20250111_add_avatar_url_to_students
Create Date: 2025-01-10 17:39:17.697032

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '623fcaf9bd91'
down_revision: Union[str, None] = ('20240130_make_arena_id_nullable', '20250111_add_avatar_url_to_students')
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    pass


def downgrade() -> None:
    pass



================================================================================
File: backend\alembic\versions\abcde_add_elo_before_to_matches.py
================================================================================

"""add elo before to matches

Revision ID: abcde_add_elo_before_to_matches
Revises: 20240101_add_match_participants
Create Date: 2024-01-05

"""
from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic
revision = 'abcde_add_elo_before_to_matches'
down_revision = '20240101_add_match_participants'
branch_labels = None
depends_on = None

def upgrade():
    # Add ELO tracking columns to matches
    op.add_column('matches', sa.Column('player1_elo_before', sa.Float(), nullable=True))
    op.add_column('matches', sa.Column('player2_elo_before', sa.Float(), nullable=True))

def downgrade():
    # Remove ELO tracking columns
    op.drop_column('matches', 'player1_elo_before')
    op.drop_column('matches', 'player2_elo_before')



================================================================================
File: backend\app\database.py
================================================================================

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from dotenv import load_dotenv
import os

# Load environment variables
load_dotenv()

# Get database URL from environment variable and convert it to async format
DATABASE_URL = os.getenv("DATABASE_URL")
if DATABASE_URL and DATABASE_URL.startswith("postgresql://"):
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+asyncpg://", 1)

# Create async engine
engine = create_async_engine(DATABASE_URL, echo=True)

# Create async session factory
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

# Create declarative base
Base = declarative_base()

# Dependency to get database session
async def get_db():
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()



================================================================================
File: backend\app\__init__.py
================================================================================

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(
    title="Flashcard Arena API",
    redirect_slashes=True
)

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # Frontend development server
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allow_headers=["Content-Type", "Authorization", "Accept"],
    expose_headers=["Content-Type"],
)

# Import routers
from .routers import flashcards, students, matches, arena, flashcard_stats

# Include routers
app.include_router(flashcards.router, prefix="/api/flashcards", tags=["flashcards"])
app.include_router(students.router, prefix="/api/students", tags=["students"])
app.include_router(matches.router, prefix="/api/matches", tags=["matches"])
app.include_router(arena.router, prefix="/api/arena", tags=["arena"])
app.include_router(flashcard_stats.router, prefix="/api/stats", tags=["statistics"])



================================================================================
File: backend\app\core\logging.py
================================================================================

import logging

def get_logger(name: str) -> logging.Logger:
    """
    Creates and returns a logger with the specified name and basic configuration.
    """
    logger = logging.getLogger(name)
    
    if not logger.handlers:
        handler = logging.StreamHandler()
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        logger.setLevel(logging.INFO)
    
    return logger



================================================================================
File: backend\app\models\arena_schemas.py
================================================================================

from pydantic import BaseModel, conlist
from typing import List, Optional
from uuid import UUID
from .arena_session import ArenaSessionStatus
from .match import MatchStatus

class CreateArenaRequest(BaseModel):
    student_ids: conlist(UUID, min_length=2)  # At least 2 players required
    num_rounds: int

class StudentStatsResponse(BaseModel):
    student_id: UUID
    name: str
    elo_rating: float
    wins: int
    losses: int
    fights_played: int
    elo_change: float  # Total ELO change in this arena session

    class Config:
        from_attributes = True

class ArenaSessionResponse(BaseModel):
    id: UUID
    status: ArenaSessionStatus
    num_rounds: int
    rounds_completed: int
    participants: List[StudentStatsResponse]

    class Config:
        from_attributes = True

class MatchParticipantResponse(BaseModel):
    student_id: UUID
    elo_before: float
    elo_after: Optional[float]

    class Config:
        from_attributes = True

class MatchResponse(BaseModel):
    id: UUID
    status: MatchStatus
    num_rounds: int
    rounds_completed: int
    participants: List[MatchParticipantResponse]

    class Config:
        from_attributes = True

class SetMatchWinnerRequest(BaseModel):
    winner_ids: List[UUID]

class MatchWinnerResponse(BaseModel):
    match: MatchResponse
    arena_session: ArenaSessionResponse

    class Config:
        from_attributes = True



================================================================================
File: backend\app\models\arena_session.py
================================================================================

from sqlalchemy import Column, DateTime, String, Integer, Enum, func, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
import enum
from ..database import Base

class ArenaSessionStatus(enum.Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

class ArenaParticipant(Base):
    __tablename__ = 'arena_participants'
    
    arena_id = Column(UUID(as_uuid=True), ForeignKey('arena_sessions.id'), primary_key=True)
    student_id = Column(UUID(as_uuid=True), ForeignKey('students.id'), primary_key=True)
    fights_played = Column(Integer, default=0)
    
    # relationships
    arena = relationship("ArenaSession", back_populates="participants")
    student = relationship("Student", lazy="selectin")

class ArenaSession(Base):
    __tablename__ = "arena_sessions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    status = Column(
        Enum(ArenaSessionStatus, name="arena_session_status", create_type=False,
             values_callable=lambda x: [e.value for e in x]),
        default=ArenaSessionStatus.PENDING
    )
    num_rounds = Column(Integer, nullable=False)  # Total number of 1v1 fights to complete
    rounds_completed = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    # relationships
    participants = relationship("ArenaParticipant", back_populates="arena", cascade="all, delete-orphan", lazy="selectin")
    matches = relationship("Match", back_populates="arena_session", cascade="all, delete-orphan", lazy="selectin")



================================================================================
File: backend\app\models\flashcard.py
================================================================================

from sqlalchemy import Column, String, Integer, DateTime, ForeignKey, func, Enum
from sqlalchemy.dialects.postgresql import UUID
import uuid
import enum
from ..database import Base

class DifficultyLevel(enum.Enum):
    EASY = "easy"
    MEDIUM = "medium"
    HARD = "hard"

class Flashcard(Base):
    __tablename__ = "flashcards"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    question = Column(String, nullable=False)
    answer = Column(String, nullable=False)
    pack_id = Column(UUID(as_uuid=True), ForeignKey("flashcard_packs.id"), nullable=False)
    difficulty = Column(Enum(DifficultyLevel), default=DifficultyLevel.MEDIUM)
    times_used = Column(Integer, default=0)
    times_correct = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    @property
    def success_rate(self):
        if self.times_used == 0:
            return 0.0
        return (self.times_correct / self.times_used) * 100

    def update_stats(self, correct: bool):
        """Update flashcard statistics after use"""
        self.times_used += 1
        if correct:
            self.times_correct += 1

class FlashcardPack(Base):
    __tablename__ = "flashcard_packs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    description = Column(String)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())



================================================================================
File: backend\app\models\match.py
================================================================================

from sqlalchemy import Column, ForeignKey, DateTime, String, Float, Enum, Integer, func
from sqlalchemy.dialects.postgresql import UUID, ARRAY
from sqlalchemy.orm import relationship
import uuid
import enum
from ..database import Base

class MatchStatus(str, enum.Enum):
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"

class MatchParticipant(Base):
    __tablename__ = "match_participants"

    match_id = Column(UUID(as_uuid=True), ForeignKey('matches.id'), primary_key=True)
    student_id = Column(UUID(as_uuid=True), ForeignKey('students.id'), primary_key=True)
    elo_before = Column(Float)
    elo_after = Column(Float)

    # relationships
    match = relationship("Match", back_populates="participants")
    student = relationship("Student")

class RoundParticipant(Base):
    __tablename__ = "round_participants"

    round_id = Column(UUID(as_uuid=True), ForeignKey('rounds.id'), primary_key=True)
    student_id = Column(UUID(as_uuid=True), ForeignKey('students.id'), primary_key=True)
    elo_before = Column(Float)
    elo_change = Column(Float)
    answer = Column(String)

    # relationships
    round = relationship("Round", back_populates="participants")
    student = relationship("Student")

class Match(Base):
    __tablename__ = "matches"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    arena_id = Column(
        UUID(as_uuid=True),
        ForeignKey("arena_sessions.id", ondelete="CASCADE"),
        nullable=True
    )
    status = Column(
        Enum(MatchStatus, name="match_status", create_type=False, values_callable=lambda x: [e.value for e in x]),
        default=MatchStatus.PENDING
    )  # Must match DB type name exactly
    num_rounds = Column(Integer, nullable=False)
    rounds_completed = Column(Integer, default=0)
    
    # Array of winner IDs (supports multiple winners)
    winner_ids = Column(ARRAY(UUID(as_uuid=True)), nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    # relationships
    participants = relationship("MatchParticipant", back_populates="match", cascade="all, delete-orphan", lazy="selectin")
    rounds = relationship("Round", back_populates="match", cascade="all, delete-orphan")
    arena_session = relationship("ArenaSession", back_populates="matches")

class Round(Base):
    __tablename__ = "rounds"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    match_id = Column(UUID(as_uuid=True), ForeignKey("matches.id"), nullable=False)
    flashcard_id = Column(UUID(as_uuid=True), ForeignKey("flashcards.id"), nullable=False)
    round_number = Column(Integer, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    # Array of winner IDs (supports multiple winners)
    winner_ids = Column(ARRAY(UUID(as_uuid=True)), nullable=True)

    # relationships
    match = relationship("Match", back_populates="rounds")
    flashcard = relationship("Flashcard")
    participants = relationship("RoundParticipant", back_populates="round", cascade="all, delete-orphan")



================================================================================
File: backend\app\models\student.py
================================================================================

from sqlalchemy import Column, Integer, String, Float, DateTime, func
from sqlalchemy.dialects.postgresql import UUID
import uuid
from ..database import Base

class Student(Base):
    __tablename__ = "students"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    avatar_url = Column(String, nullable=True)  # NEW COLUMN for profile pictures
    elo_rating = Column(Float, default=1000.0)  # Starting ELO rating
    wins = Column(Integer, default=0)
    losses = Column(Integer, default=0)
    total_matches = Column(Integer, default=0)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now(), server_default=func.now())

    @property
    def win_rate(self):
        if self.total_matches == 0:
            return 0.0
        return (self.wins / self.total_matches) * 100

    def update_stats(self, won: bool, new_elo: float):
        """Update player statistics after a match"""
        self.elo_rating = new_elo
        self.total_matches += 1
        if won:
            self.wins += 1
        else:
            self.losses += 1



================================================================================
File: backend\app\models\__init__.py
================================================================================

# This file makes the models directory a Python package
from .student import Student
from .flashcard import Flashcard
from .match import Match



================================================================================
File: backend\app\routers\arena.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from typing import List
from uuid import UUID
from ..database import get_db
from ..models.arena_session import ArenaSession, ArenaSessionStatus, ArenaParticipant
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.student import Student
from ..models.arena_schemas import (
    CreateArenaRequest,
    StudentStatsResponse,
    ArenaSessionResponse,
    MatchResponse,
    SetMatchWinnerRequest,
    MatchWinnerResponse
)
from ..services.arena_stats_service import ArenaStatsService
from ..services.arena_match_service import ArenaMatchService

# Services
arena_stats_service = ArenaStatsService()
arena_match_service = ArenaMatchService()

router = APIRouter()

@router.post("", response_model=dict[str, ArenaSessionResponse])
async def create_arena_session(
    request: CreateArenaRequest,
    db: AsyncSession = Depends(get_db)
):
    """Create a new arena session with the specified students"""
    # Verify all students exist
    result = await db.execute(
        select(Student).where(Student.id.in_(request.student_ids))
    )
    students = result.scalars().all()
    if len(students) != len(request.student_ids):
        raise HTTPException(status_code=400, detail="One or more students not found")

    # Create arena session
    arena = ArenaSession(
        status=ArenaSessionStatus.IN_PROGRESS,
        num_rounds=request.num_rounds,
        rounds_completed=0
    )
    db.add(arena)
    await db.flush()  # Get arena.id

    # Add participants
    for student_id in request.student_ids:
        participant = ArenaParticipant(
            arena_id=arena.id,
            student_id=student_id,
            fights_played=0
        )
        db.add(participant)

    await db.commit()
    await db.refresh(arena)

    # Construct proper response with student stats
    participants_list = []
    for participant in arena.participants:
        student = participant.student  # Already loaded due to lazy="selectin"
        participants_list.append(
            StudentStatsResponse(
                student_id=student.id,
                name=student.name,
                elo_rating=student.elo_rating,
                wins=0,  # New arena, no wins yet
                losses=0,  # New arena, no losses yet
                fights_played=0,  # New arena, no fights yet
                elo_change=0.0  # New arena, no ELO changes yet
            )
        )

    response = ArenaSessionResponse(
        id=arena.id,
        status=arena.status,
        num_rounds=arena.num_rounds,
        rounds_completed=arena.rounds_completed,
        participants=participants_list
    )
    
    return {"data": response}

@router.get("/{arena_id}/next-match", response_model=dict[str, MatchResponse])
async def get_next_match(
    arena_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get or create the next match in the arena session"""
    # Get arena session
    arena = await db.get(ArenaSession, arena_id)
    if not arena:
        raise HTTPException(status_code=404, detail="Arena session not found")
    if arena.status != ArenaSessionStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Arena session is not in progress")
    if arena.rounds_completed >= arena.num_rounds:
        raise HTTPException(status_code=400, detail="All rounds completed")

    # Get all arena participants
    result = await db.execute(
        select(ArenaParticipant, Student)
        .join(Student)
        .where(ArenaParticipant.arena_id == arena_id)
    )
    participant_students = result.all()
    if len(participant_students) < 2:
        raise HTTPException(status_code=400, detail="Not enough participants")

    try:
        match = await arena_match_service.create_next_match(
            db, arena_id, participant_students
        )
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    await db.commit()
    # Refresh match with eager loading
    result = await db.execute(
        select(Match)
        .options(selectinload(Match.participants))
        .where(Match.id == match.id)
    )
    match = result.scalar_one()
    match_response = MatchResponse.from_orm(match)
    return {"data": match_response}

@router.patch("/matches/{match_id}/winner", response_model=dict[str, MatchWinnerResponse])
async def set_match_winner(
    match_id: UUID,
    request: SetMatchWinnerRequest,
    db: AsyncSession = Depends(get_db)
):
    """Set the winner of a match and update ELO ratings"""
    # Get match with participants eager loaded
    result = await db.execute(
        select(Match)
        .options(selectinload(Match.participants))
        .where(Match.id == match_id)
    )
    match = result.scalar_one_or_none()
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")

    # Get match participants
    result = await db.execute(
        select(MatchParticipant, Student)
        .join(Student, MatchParticipant.student_id == Student.id)
        .where(MatchParticipant.match_id == match_id)
    )
    participants_with_students = result.all()
    if len(participants_with_students) != 2:
        raise HTTPException(status_code=400, detail="Match must have exactly 2 participants")

    # Validate winners
    participant_dict = {p.student_id: (p, s) for p, s in participants_with_students}
    for winner_id in request.winner_ids:
        if winner_id not in participant_dict:
            raise HTTPException(status_code=400, detail="Winner must be a player in this match")

    # Get arena session
    arena = await db.get(ArenaSession, match.arena_id)
    if not arena:
        raise HTTPException(status_code=404, detail="Arena session not found")

    # Update match and participants
    await arena_match_service.set_match_winner(
        db, match, request.winner_ids, participants_with_students
    )

    # Update arena session
    arena.rounds_completed += 1
    if arena.rounds_completed >= arena.num_rounds:
        arena.status = ArenaSessionStatus.COMPLETED

    await db.commit()
    # Ensure participants are loaded before returning
    await db.refresh(match, ['participants'])
    await db.refresh(arena)

    # Get all arena participants for stats
    result = await db.execute(
        select(ArenaParticipant, Student)
        .join(Student)
        .where(ArenaParticipant.arena_id == arena.id)
    )
    arena_participant_students = result.all()

    # Calculate stats using service
    participants_list = await arena_stats_service.calculate_arena_stats(
        db, arena.id, arena_participant_students
    )

    arena_response = ArenaSessionResponse(
        id=arena.id,
        status=arena.status,
        num_rounds=arena.num_rounds,
        rounds_completed=arena.rounds_completed,
        participants=participants_list
    )

    # Convert match to MatchResponse
    match_response = MatchResponse.from_orm(match)

    return {
        "data": MatchWinnerResponse(
            match=match_response,
            arena_session=arena_response
        )
    }

@router.get("/{arena_id}/results", response_model=dict[str, List[StudentStatsResponse]])
async def get_arena_results(
    arena_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get final results and statistics for an arena session"""
    # Get arena session
    arena = await db.get(ArenaSession, arena_id)
    if not arena:
        raise HTTPException(status_code=404, detail="Arena session not found")

    # Get all participants with their students
    result = await db.execute(
        select(ArenaParticipant, Student)
        .join(Student, ArenaParticipant.student_id == Student.id)
        .where(ArenaParticipant.arena_id == arena_id)
    )
    participant_students = result.all()

    # Calculate stats using service
    stats = await arena_stats_service.calculate_arena_stats(
        db, arena_id, participant_students
    )
    return {"data": stats}



================================================================================
File: backend\app\routers\flashcards.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException, UploadFile, File, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy import delete
from typing import List, Optional, Generic, TypeVar

T = TypeVar('T')
from pydantic import BaseModel, constr, validator
import csv
import io
from datetime import datetime
from uuid import UUID

from ..database import get_db
from ..models.flashcard import Flashcard, FlashcardPack, DifficultyLevel

router = APIRouter(tags=["flashcards"])

# Response schemas
class ApiResponse(BaseModel, Generic[T]):
    data: T

# Pack schemas
class FlashcardPackBase(BaseModel):
    name: constr(min_length=1, max_length=100)

    @validator('name')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class FlashcardPackCreate(FlashcardPackBase):
    pass

class FlashcardPackUpdate(FlashcardPackBase):
    pass

class FlashcardPackResponse(FlashcardPackBase):
    id: UUID
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class FlashcardBase(BaseModel):
    question: constr(min_length=1, max_length=1000)
    answer: constr(min_length=1, max_length=1000)
    difficulty: DifficultyLevel = DifficultyLevel.MEDIUM
    pack_id: UUID

    @validator('question', 'answer')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class FlashcardCreate(FlashcardBase):
    pass

class FlashcardUpdate(FlashcardBase):
    pass

class FlashcardResponse(FlashcardBase):
    id: UUID
    times_used: int
    times_correct: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class FlashcardBulkCreate(BaseModel):
    question: constr(min_length=1, max_length=1000)
    answer: constr(min_length=1, max_length=1000)
    difficulty: Optional[DifficultyLevel] = DifficultyLevel.MEDIUM
    pack_id: UUID

    @validator('question', 'answer')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class BulkImportResponse(BaseModel):
    total: int
    successful: int
    failed: int
    errors: List[str]

class TemplateResponse(BaseModel):
    content: str
    filename: str
    media_type: str

# Pack endpoints
@router.get("/packs", response_model=ApiResponse[List[FlashcardPackResponse]])
async def get_packs(
    db: AsyncSession = Depends(get_db)
):
    """Get all flashcard packs"""
    result = await db.execute(select(FlashcardPack))
    return {"data": result.scalars().all()}

@router.post("/packs", response_model=ApiResponse[FlashcardPackResponse], status_code=status.HTTP_201_CREATED)
async def create_pack(
    pack: FlashcardPackCreate,
    db: AsyncSession = Depends(get_db)
):
    """Create a new flashcard pack"""
    db_pack = FlashcardPack(**pack.dict())
    db.add(db_pack)
    await db.commit()
    await db.refresh(db_pack)
    return {"data": db_pack}

@router.put("/packs/{pack_id}", response_model=ApiResponse[FlashcardPackResponse])
async def update_pack(
    pack_id: UUID,
    pack_update: FlashcardPackUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update a flashcard pack"""
    result = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == pack_id)
    )
    db_pack = result.scalar_one_or_none()
    if not db_pack:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Pack not found"
        )
    
    # Update fields
    for field, value in pack_update.dict().items():
        setattr(db_pack, field, value)
    
    await db.commit()
    await db.refresh(db_pack)
    return {"data": db_pack}

@router.delete("/packs/{pack_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_pack(
    pack_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete a flashcard pack and all its flashcards"""
    result = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == pack_id)
    )
    pack = result.scalar_one_or_none()
    if not pack:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Pack not found"
        )
    
    # Delete all flashcards in the pack
    await db.execute(
        delete(Flashcard).where(Flashcard.pack_id == pack_id)
    )
    
    # Delete the pack
    await db.delete(pack)
    await db.commit()

# Template and export endpoints
@router.post("/template", response_model=ApiResponse[TemplateResponse])
async def get_csv_template():
    """Get a CSV template for bulk flashcard import"""
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(['question', 'answer', 'difficulty', 'pack_id'])
    writer.writerow(['What is 2+2?', '4', 'EASY', 'pack-uuid-here'])
    
    return {"data": {
        "content": output.getvalue(),
        "filename": "flashcard_template.csv",
        "media_type": "text/csv"
    }}

@router.get("/export/{pack_id}", response_model=ApiResponse[TemplateResponse])
async def export_flashcards(
    pack_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Export all flashcards from a pack as CSV"""
    # Verify pack exists
    pack = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == pack_id)
    )
    if not pack.scalar_one_or_none():
        raise HTTPException(status_code=404, detail="Pack not found")
    
    # Get all flashcards in pack
    result = await db.execute(
        select(Flashcard).where(Flashcard.pack_id == pack_id)
    )
    flashcards = result.scalars().all()
    
    # Create CSV
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerow(['question', 'answer', 'difficulty', 'pack_id', 'times_used', 'times_correct'])
    
    for card in flashcards:
        writer.writerow([
            card.question,
            card.answer,
            card.difficulty.name,
            str(card.pack_id),
            card.times_used,
            card.times_correct
        ])
    
    return {"data": {
        "content": output.getvalue(),
        "filename": f"flashcards_pack_{pack_id}.csv",
        "media_type": "text/csv"
    }}

@router.post("/bulk-import", response_model=BulkImportResponse)
async def bulk_import_flashcards(
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db)
):
    """Import multiple flashcards from a CSV file"""
    if not file.filename.endswith('.csv'):
        raise HTTPException(status_code=400, detail="File must be a CSV")
    
    content = await file.read()
    text_content = content.decode('utf-8-sig')
    csv_reader = csv.DictReader(io.StringIO(text_content))
    
    total = 0
    successful = 0
    failed = 0
    errors = []
    flashcards_to_add = []

    try:
        for row in csv_reader:
            total += 1
            try:
                # Validate row data
                flashcard_data = FlashcardBulkCreate(
                    question=row['question'],
                    answer=row['answer'],
                    difficulty=DifficultyLevel[row.get('difficulty', 'MEDIUM').upper()],
                    pack_id=UUID(row['pack_id'])
                )
                
                # Verify pack exists
                pack = await db.execute(
                    select(FlashcardPack).where(FlashcardPack.id == flashcard_data.pack_id)
                )
                if not pack.scalar_one_or_none():
                    raise ValueError(f"Pack with ID {flashcard_data.pack_id} not found")
                
                # Create flashcard model instance
                flashcard = Flashcard(
                    question=flashcard_data.question,
                    answer=flashcard_data.answer,
                    difficulty=flashcard_data.difficulty,
                    pack_id=flashcard_data.pack_id
                )
                flashcards_to_add.append(flashcard)
                successful += 1
                
            except Exception as e:
                failed += 1
                errors.append(f"Row {total}: {str(e)}")
                
        # Bulk insert valid flashcards
        if flashcards_to_add:
            db.add_all(flashcards_to_add)
            await db.commit()
            
    except Exception as e:
        await db.rollback()
        raise HTTPException(status_code=500, detail=str(e))
        
    return {
        "total": total,
        "successful": successful,
        "failed": failed,
        "errors": errors
    }

# Basic CRUD endpoints
@router.get("/pack/{pack_id}", response_model=ApiResponse[List[FlashcardResponse]])
async def get_flashcards_by_pack(
    pack_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get all flashcards in a pack"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.pack_id == pack_id)
    )
    return {"data": result.scalars().all()}

@router.get("/all", response_model=ApiResponse[List[FlashcardResponse]])
async def get_flashcards(
    db: AsyncSession = Depends(get_db)
):
    """Get all flashcards"""
    result = await db.execute(select(Flashcard))
    return {"data": result.scalars().all()}

@router.post("/", response_model=ApiResponse[FlashcardResponse], status_code=status.HTTP_201_CREATED)
async def create_flashcard(
    flashcard: FlashcardCreate,
    db: AsyncSession = Depends(get_db)
):
    """Create a new flashcard"""
    # Verify pack exists
    pack = await db.execute(
        select(FlashcardPack).where(FlashcardPack.id == flashcard.pack_id)
    )
    if not pack.scalar_one_or_none():
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Pack with ID {flashcard.pack_id} not found"
        )
    
    db_flashcard = Flashcard(**flashcard.dict())
    db.add(db_flashcard)
    await db.commit()
    await db.refresh(db_flashcard)
    return {"data": db_flashcard}

@router.get("/{flashcard_id}", response_model=ApiResponse[FlashcardResponse])
async def get_flashcard(
    flashcard_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get a specific flashcard by ID"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.id == flashcard_id)
    )
    flashcard = result.scalar_one_or_none()
    if not flashcard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flashcard not found"
        )
    return {"data": flashcard}

@router.put("/{flashcard_id}", response_model=ApiResponse[FlashcardResponse])
async def update_flashcard(
    flashcard_id: UUID,
    flashcard_update: FlashcardUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update a flashcard"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.id == flashcard_id)
    )
    db_flashcard = result.scalar_one_or_none()
    if not db_flashcard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flashcard not found"
        )
    
    # Update fields
    for field, value in flashcard_update.dict().items():
        setattr(db_flashcard, field, value)
    
    await db.commit()
    await db.refresh(db_flashcard)
    return {"data": db_flashcard}

@router.delete("/{flashcard_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_flashcard(
    flashcard_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete a flashcard"""
    result = await db.execute(
        select(Flashcard).where(Flashcard.id == flashcard_id)
    )
    flashcard = result.scalar_one_or_none()
    if not flashcard:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Flashcard not found"
        )
    
    await db.delete(flashcard)
    await db.commit()



================================================================================
File: backend\app\routers\flashcard_stats.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Dict, Any
from uuid import UUID
from ..database import get_db
from ..services.statistics_service import StatisticsService

router = APIRouter()

@router.get("/flashcards/{flashcard_id}/stats")
async def get_flashcard_stats(
    flashcard_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> Dict[str, Any]:
    """Get comprehensive statistics for a specific flashcard"""
    try:
        stats = await StatisticsService.get_flashcard_stats(str(flashcard_id), db)
        return {"data": stats}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

@router.get("/flashcards/most-used")
async def get_most_used_flashcards(
    limit: int = 10,
    db: AsyncSession = Depends(get_db)
) -> Dict[str, List[Dict[str, Any]]]:
    """Get flashcards sorted by usage frequency"""
    stats = await StatisticsService.get_most_used_flashcards(db, limit)
    return {"data": stats}

@router.get("/arena/{arena_id}/flashcard-stats")
async def get_arena_flashcard_stats(
    arena_id: UUID,
    db: AsyncSession = Depends(get_db)
) -> Dict[str, List[Dict[str, Any]]]:
    """Get statistics for all flashcards used in a specific arena session"""
    try:
        stats = await StatisticsService.get_arena_flashcard_stats(str(arena_id), db)
        return {"data": stats}
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))



================================================================================
File: backend\app\routers\matches.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import List, Optional, Dict
from uuid import UUID
from pydantic import BaseModel, conlist
from ..models.match import Match, Round, MatchStatus, MatchParticipant, RoundParticipant

# Response models
class ParticipantResponse(BaseModel):
    student_id: UUID
    elo_before: Optional[float]
    elo_after: Optional[float]

    class Config:
        from_attributes = True

class MatchResponse(BaseModel):
    id: UUID
    status: MatchStatus
    num_rounds: int
    rounds_completed: int
    winner_id: Optional[UUID]
    participants: List[ParticipantResponse]

    class Config:
        from_attributes = True

class RoundParticipantResponse(BaseModel):
    student_id: UUID
    elo_before: Optional[float]
    elo_change: Optional[float]
    answer: Optional[str]

    class Config:
        from_attributes = True

class RoundResponse(BaseModel):
    id: UUID
    match_id: UUID
    flashcard_id: UUID
    winner_id: Optional[UUID]
    round_number: int
    participants: List[RoundParticipantResponse]

    class Config:
        from_attributes = True

from ..database import get_db
from ..models.student import Student
from ..services.matchmaking_service import MatchmakingService
from ..services.elo_service import EloService

class CreateMultiplayerMatchRequest(BaseModel):
    player_ids: conlist(UUID, min_length=2)  # At least 2 players required
    num_rounds: int

class AutoMatchRequest(BaseModel):
    num_players: int
    num_rounds: int
    student_id: UUID  # The requesting player

class CreateRoundRequest(BaseModel):
    match_id: UUID
    flashcard_id: UUID

class SubmitAnswerRequest(BaseModel):
    player_id: UUID
    answer: str

class SetRoundWinnerRequest(BaseModel):
    winner_ids: List[UUID]  # Support multiple winners

class UpdateStatusRequest(BaseModel):
    status: str  # Use str instead of MatchStatus enum for request validation
    winner_id: Optional[UUID] = None

    def get_status(self) -> MatchStatus:
        """Convert string status to MatchStatus enum"""
        try:
            return MatchStatus[self.status.upper()]
        except KeyError:
            raise HTTPException(
                status_code=400,
                detail=f"Invalid status. Must be one of: {', '.join(s.value for s in MatchStatus)}"
            )

router = APIRouter()
matchmaking_service = MatchmakingService()
elo_service = EloService()

@router.get("")
async def get_matches(db: AsyncSession = Depends(get_db)):
    """Get all matches"""
    result = await db.execute(select(Match))
    matches = result.scalars().all()
    return {"data": matches}

@router.get("/{match_id}", response_model=dict[str, MatchResponse])
async def get_match(match_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get match by ID"""
    match = await db.get(Match, match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    return {"data": match}

@router.post("/multiplayer")
async def create_multiplayer_match(
    request: CreateMultiplayerMatchRequest,
    db: AsyncSession = Depends(get_db)
):
    """Create a new match with multiple players"""
    try:
        match = await matchmaking_service.create_multiplayer_match(
            [str(pid) for pid in request.player_ids],
            request.num_rounds,
            db
        )
        return {"data": match}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/auto-match")
async def auto_create_match(
    request: AutoMatchRequest,
    db: AsyncSession = Depends(get_db)
):
    """Automatically create a match with similarly rated players"""
    try:
        match = await matchmaking_service.auto_find_players_and_create_match(
            request.num_players,
            request.num_rounds,
            str(request.student_id),
            db
        )
        return {"data": match}
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.post("/find")
async def find_or_create_match(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Find an existing match or create a new one with a suitable opponent"""
    try:
        match, created = await matchmaking_service.find_or_create_match(str(student_id), db)
        return {
            "data": match,
            "created": created
        }
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

@router.patch("/{match_id}/status")
async def update_match_status(
    match_id: UUID,
    request: UpdateStatusRequest,
    db: AsyncSession = Depends(get_db)
):
    """Update match status and handle ELO updates if completed"""
    match = await db.get(Match, match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    
    new_status = request.get_status()
    
    # Handle transition to IN_PROGRESS
    if new_status == MatchStatus.IN_PROGRESS:
        if match.status == MatchStatus.COMPLETED:
            raise HTTPException(status_code=400, detail="Cannot restart a completed match")
        match.status = MatchStatus.IN_PROGRESS
    
    # Handle transition to COMPLETED
    elif new_status == MatchStatus.COMPLETED:
        if not request.winner_id:
            raise HTTPException(status_code=400, detail="Winner ID required to complete match")
        
        # Validate winner is part of the match
        if request.winner_id not in [match.player1_id, match.player2_id]:
            raise HTTPException(status_code=400, detail="Winner must be a player in this match")
        
        # Get players to update their stats
        player1 = await db.get(Student, match.player1_id)
        player2 = await db.get(Student, match.player2_id)
        
        # Determine winner and loser
        winner = player1 if request.winner_id == player1.id else player2
        loser = player2 if request.winner_id == player1.id else player1
        
        # Update match status and winner
        match.status = MatchStatus.COMPLETED
        match.winner_id = request.winner_id
        
        # Calculate total ELO changes from rounds
        result = await db.execute(
            select(Round).where(Round.match_id == match_id)
        )
        rounds = result.scalars().all()
        
        total_p1_change = sum(round.player1_elo_change or 0 for round in rounds)
        total_p2_change = sum(round.player2_elo_change or 0 for round in rounds)
        
        # Store total changes in match
        match.player1_elo_change = total_p1_change
        match.player2_elo_change = total_p2_change
        
        # Update match stats
        winner.wins += 1
        winner.total_matches += 1
        loser.losses += 1
        loser.total_matches += 1
    
    # Handle other status changes
    else:
        match.status = new_status
    
    await db.commit()
    await db.refresh(match)
    return {"data": match}

@router.get("/{match_id}/rounds", response_model=dict[str, List[RoundResponse]])
async def get_match_rounds(match_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get all rounds for a match"""
    result = await db.execute(
        select(Round).where(Round.match_id == match_id)
    )
    rounds = result.scalars().all()
    return {"data": rounds}

@router.post("/rounds")
async def create_round(
    request: CreateRoundRequest,
    db: AsyncSession = Depends(get_db)
):
    """Create a new round for a match"""
    # Verify match exists and is in progress
    match = await db.get(Match, request.match_id)
    if not match:
        raise HTTPException(status_code=404, detail="Match not found")
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")
    
    # Get the current round number
    result = await db.execute(
        select(Round).where(Round.match_id == request.match_id).order_by(Round.round_number.desc())
    )
    existing_rounds = result.scalars().all()
    round_number = str(len(existing_rounds) + 1) if existing_rounds else "1"
    
    # Create round
    round = Round(
        match_id=request.match_id,
        flashcard_id=request.flashcard_id,
        round_number=round_number,
        winner_id=None,
        player1_answer=None,
        player2_answer=None
    )
    
    db.add(round)
    await db.commit()
    await db.refresh(round)
    
    return {"data": round}

@router.get("/rounds/{round_id}")
async def get_round(round_id: UUID, db: AsyncSession = Depends(get_db)):
    """Get round by ID"""
    round = await db.get(Round, round_id)
    if not round:
        raise HTTPException(status_code=404, detail="Round not found")
    return {"data": round}

@router.post("/rounds/{round_id}/answer")
async def submit_round_answer(
    round_id: UUID,
    request: SubmitAnswerRequest,
    db: AsyncSession = Depends(get_db)
):
    """Submit an answer for a round"""
    round = await db.get(Round, round_id)
    if not round:
        raise HTTPException(status_code=404, detail="Round not found")
    
    match = await db.get(Match, round.match_id)
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")
    
    # Update player's answer
    if request.player_id == match.player1_id:
        round.player1_answer = request.answer
    elif request.player_id == match.player2_id:
        round.player2_answer = request.answer
    else:
        raise HTTPException(status_code=400, detail="Player is not part of this match")
    
    await db.commit()
    await db.refresh(round)
    
    return {"data": round}

@router.post("/rounds/{round_id}/winner")
async def set_round_winner(
    round_id: UUID,
    request: SetRoundWinnerRequest,
    db: AsyncSession = Depends(get_db)
):
    """Set winners for a round and update ELO ratings"""
    round = await db.get(Round, round_id)
    if not round:
        raise HTTPException(status_code=404, detail="Round not found")
    
    match = await db.get(Match, round.match_id)
    if match.status != MatchStatus.IN_PROGRESS:
        raise HTTPException(status_code=400, detail="Match is not in progress")
    
    # Get all participants
    result = await db.execute(
        select(RoundParticipant).where(RoundParticipant.round_id == round_id)
    )
    participants = result.scalars().all()
    participant_dict = {p.student_id: p for p in participants}
    
    # Validate winners are part of the round
    for winner_id in request.winner_ids:
        if winner_id not in participant_dict:
            raise HTTPException(status_code=400, detail=f"Winner {winner_id} is not part of this round")
    
    # Get all students
    student_ids = [p.student_id for p in participants]
    result = await db.execute(
        select(Student).where(Student.id.in_(student_ids))
    )
    students = {s.id: s for s in result.scalars().all()}
    
    # For each winner, calculate ELO changes against each non-winner
    winners = [participant_dict[wid] for wid in request.winner_ids]
    losers = [p for p in participants if p.student_id not in request.winner_ids]
    
    # Calculate and apply ELO changes
    for winner in winners:
        winner.elo_change = 0
        winner_student = students[winner.student_id]
        
        for loser in losers:
            loser_student = students[loser.student_id]
            winner_change, loser_change = elo_service.calculate_rating_changes(
                winner_student.elo_rating,
                loser_student.elo_rating
            )
            
            # Accumulate changes
            winner.elo_change += winner_change
            loser.elo_change = (loser.elo_change or 0) + loser_change
    
    # Apply changes to student ratings
    for p in participants:
        if p.elo_change:  # Only update if there was a change
            students[p.student_id].elo_rating += p.elo_change
    
    # Update round
    if len(request.winner_ids) == 1:
        round.winner_id = request.winner_ids[0]
    
    # Update match rounds completed
    match.rounds_completed += 1
    if match.rounds_completed >= match.num_rounds:
        match.status = MatchStatus.COMPLETED
        # Optionally set match winner based on most rounds won
        winner_counts = {}
        for r in match.rounds:
            if r.winner_id:
                winner_counts[r.winner_id] = winner_counts.get(r.winner_id, 0) + 1
        if winner_counts:
            match.winner_id = max(winner_counts.items(), key=lambda x: x[1])[0]
    
    await db.commit()
    await db.refresh(round)
    
    return {"data": round}



================================================================================
File: backend\app\routers\students.py
================================================================================

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from typing import List, Generic, TypeVar, Literal
from pydantic import BaseModel, constr, validator, ConfigDict
from datetime import datetime
from uuid import UUID

from ..database import get_db
from ..models.student import Student
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.flashcard import Flashcard

T = TypeVar('T')

class DataResponse(BaseModel, Generic[T]):
    data: T
    model_config = ConfigDict(from_attributes=True)

class MatchHistoryItem(BaseModel):
    match_id: UUID
    date: datetime
    opponent_name: str
    old_elo: float
    new_elo: float
    elo_change: float
    result: Literal["win", "loss", "unknown"]

    model_config = ConfigDict(from_attributes=True)

router = APIRouter(tags=["students"])

class StudentBase(BaseModel):
    name: constr(min_length=1, max_length=100)

    @validator('name')
    def no_empty_strings(cls, v):
        if not v.strip():
            raise ValueError('Cannot be empty string')
        return v.strip()

class StudentCreate(StudentBase):
    avatar_url: str | None = None  # NEW FIELD

class StudentUpdate(StudentBase):
    avatar_url: str | None = None  # NEW FIELD

class StudentResponse(StudentBase):
    id: UUID
    avatar_url: str | None = None
    elo_rating: float
    total_matches: int
    wins: int
    losses: int
    created_at: datetime
    updated_at: datetime
    win_rate: float

    class Config:
        from_attributes = True

    @validator('win_rate', pre=True, always=True)
    def calculate_win_rate(cls, v, values):
        """
        If your Student model calculates win_rate as a fraction (e.g. 0.75),
        you might want to convert to a percentage. Adjust as needed.
        """
        if hasattr(v, '__call__'):
            return 0.0
        # Or if your model already stores it as a percentage, just return v.
        # In some code, the Student model uses `win_rate = (wins / total_matches) * 100`.
        return v / 100 if v is not None else 0.0

@router.post("", response_model=DataResponse[StudentResponse], status_code=status.HTTP_201_CREATED)
async def create_student(
    student: StudentCreate,
    db: AsyncSession = Depends(get_db)
):
    """Create a new student"""
    db_student = Student(**student.dict())
    db.add(db_student)
    await db.commit()

    result = await db.execute(
        select(Student).where(Student.id == db_student.id)
    )
    created_student = result.scalar_one()
    return {"data": created_student}

@router.get("", response_model=DataResponse[List[StudentResponse]])
async def get_students(
    db: AsyncSession = Depends(get_db)
):
    """Get all students"""
    result = await db.execute(select(Student))
    return {"data": result.scalars().all()}

@router.get("/{student_id}", response_model=DataResponse[StudentResponse])
async def get_student(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get a specific student by ID"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    return {"data": student}

@router.put("/{student_id}", response_model=DataResponse[StudentResponse])
async def update_student(
    student_id: UUID,
    student_update: StudentUpdate,
    db: AsyncSession = Depends(get_db)
):
    """Update a student"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    db_student = result.scalar_one_or_none()
    if not db_student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )

    for field, value in student_update.dict().items():
        setattr(db_student, field, value)

    await db.commit()
    await db.refresh(db_student)
    return {"data": db_student}

@router.delete("/{student_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_student(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Delete a student"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )

    await db.delete(student)
    await db.commit()

@router.get("/{student_id}/stats", response_model=DataResponse[StudentResponse])
async def get_student_stats(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """Get a student's updated stats"""
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )
    return {"data": student}

@router.post("/{student_id}/reset", response_model=DataResponse[StudentResponse])
async def reset_student_stats(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Reset the specified student's statistics to default values.
    """
    result = await db.execute(
        select(Student).where(Student.id == student_id)
    )
    student = result.scalar_one_or_none()
    if not student:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Student not found"
        )

    # Reset fields to default values
    student.elo_rating = 1000.0
    student.wins = 0
    student.losses = 0
    student.total_matches = 0

    await db.commit()
    await db.refresh(student)

    return {"data": student}

@router.get("/{student_id}/history", response_model=DataResponse[List[MatchHistoryItem]])
async def get_student_history(
    student_id: UUID,
    db: AsyncSession = Depends(get_db)
):
    """
    Return match history for a student, including ELO changes and results,
    adapting to the new participant-based match schema.
    """
    # 1) Verify student exists
    student = await db.get(Student, student_id)
    if not student:
        raise HTTPException(status_code=404, detail="Student not found")

    # 2) Query all matches in which this student participated
    stmt = (
        select(Match)
        .join(MatchParticipant, Match.id == MatchParticipant.match_id)
        .options(
            # preload the participants -> student relationship
            selectinload(Match.participants).selectinload(MatchParticipant.student)
        )
        .where(MatchParticipant.student_id == student_id)
        .order_by(Match.created_at.desc())
    )
    results = await db.execute(stmt)
    matches = results.scalars().all()

    history_items: List[MatchHistoryItem] = []

    for match in matches:
        # find the participant object for this student
        user_participant = None
        # for a 1v1 match, there's typically exactly 1 "opponent", but for multi-player, there may be multiple
        opponents = []
        for p in match.participants:
            if p.student_id == student_id:
                user_participant = p
            else:
                opponents.append(p)

        if not user_participant:
            # Should not happen if query is correct, but skip if something's off
            continue

        old_elo = user_participant.elo_before or 0.0
        new_elo = user_participant.elo_after or old_elo
        elo_change = new_elo - old_elo

        # Figure out if user is among the winners
        if not match.winner_ids or len(match.winner_ids) == 0:
            result_str = "unknown"
        elif user_participant.student_id in match.winner_ids:
            result_str = "win"
        else:
            result_str = "loss"

        # For "opponent_name", pick the first opponent if any
        opponent_name = "Unknown"
        if len(opponents) > 0 and opponents[0].student:
            opponent_name = opponents[0].student.name

        history_items.append(
            MatchHistoryItem(
                match_id=match.id,
                date=match.created_at,
                opponent_name=opponent_name,
                old_elo=old_elo,
                new_elo=new_elo,
                elo_change=elo_change,
                result=result_str
            )
        )

    return {"data": history_items}



================================================================================
File: backend\app\services\arena_match_service.py
================================================================================

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload
from typing import List, Optional, Tuple
from uuid import UUID
import uuid

from ..models.arena_session import ArenaSession, ArenaSessionStatus, ArenaParticipant
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.student import Student
from ..models.arena_schemas import MatchResponse
from .elo_service import EloService
from .matchmaking_service import MatchmakingService

class ArenaMatchService:
    def __init__(self):
        self.elo_service = EloService()
        self.matchmaking_service = MatchmakingService()

    async def create_next_match(
        self,
        db: AsyncSession,
        arena_id: UUID,
        participant_students: List[Tuple[ArenaParticipant, Student]]
    ) -> Match:
        """Create the next match in an arena session"""
        if len(participant_students) < 2:
            raise ValueError("Not enough participants")

        # Find the participant with least fights to be the initiator
        participant_students.sort(key=lambda ps: ps[0].fights_played)
        initiator_participant, initiator_student = participant_students[0]
        
        # Get potential opponents from current arena participants
        potential_opponents = []
        for participant, student in participant_students[1:]:  # Skip initiator
            potential_opponents.append(student)
        
        # Use matchmaking service to find best opponent
        opponents = await self.matchmaking_service.find_opponents(
            initiator_student, 2, db, potential_opponents
        )
        if not opponents:
            raise ValueError("No suitable opponents found")
            
        # Find the opponent's participant record
        opponent_student = opponents[0]
        opponent_participant = next(
            participant for participant, student in participant_students[1:]
            if str(student.id) == str(opponent_student.id)
        )

        # Create match
        match = Match(
            arena_id=arena_id,
            status=MatchStatus.IN_PROGRESS,
            num_rounds=1  # Each match is one round
        )
        db.add(match)
        await db.flush()

        # Create participants
        mp1 = MatchParticipant(
            match_id=match.id,
            student_id=initiator_student.id,
            elo_before=initiator_student.elo_rating
        )
        mp2 = MatchParticipant(
            match_id=match.id,
            student_id=opponent_student.id,
            elo_before=opponent_student.elo_rating
        )
        db.add_all([mp1, mp2])

        # Increment fights_played
        initiator_participant.fights_played += 1
        opponent_participant.fights_played += 1

        return match

    async def set_match_winner(
        self,
        db: AsyncSession,
        match: Match,
        winner_ids: List[UUID],
        participants_with_students: List[Tuple[MatchParticipant, Student]]
    ) -> None:
        """Set the winner of a match and update ELO ratings"""
        # Convert winner IDs to UUID objects and store on match
        match.winner_ids = [uuid.UUID(str(winner_id)) for winner_id in winner_ids]

        # Update all participants
        for participant, student in participants_with_students:
            is_winner = student.id in winner_ids
            elo_change = 0
            
            # Calculate ELO changes against each opponent
            for other_participant, other_student in participants_with_students:
                if other_participant.student_id != participant.student_id:
                    if is_winner:
                        winner_change, _ = self.elo_service.calculate_rating_changes(
                            student.elo_rating,
                            other_student.elo_rating
                        )
                        elo_change += winner_change
                    else:
                        _, loser_change = self.elo_service.calculate_rating_changes(
                            other_student.elo_rating,
                            student.elo_rating
                        )
                        elo_change += loser_change

            # Update participant and student stats
            participant.elo_after = participant.elo_before + elo_change
            student.update_stats(
                won=is_winner,
                new_elo=student.elo_rating + elo_change
            )

        # Update match status
        match.status = MatchStatus.COMPLETED



================================================================================
File: backend\app\services\arena_stats_service.py
================================================================================

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from ..models.match import Match, MatchStatus, MatchParticipant
from ..models.arena_session import ArenaParticipant
from ..models.student import Student
from ..models.arena_schemas import StudentStatsResponse
from typing import List, Tuple
from uuid import UUID

class ArenaStatsService:
    @staticmethod
    async def calculate_participant_stats(
        db: AsyncSession,
        arena_id: UUID,
        participant: ArenaParticipant,
        student: Student
    ) -> StudentStatsResponse:
        """Calculate stats for a single participant in an arena session"""
        # Get matches where student participated
        result = await db.execute(
            select(Match, MatchParticipant)
            .join(MatchParticipant)
            .where(
                (Match.arena_id == arena_id) &
                (MatchParticipant.student_id == student.id) &
                (Match.status == MatchStatus.COMPLETED)
            )
        )
        matches = result.all()
        
        # Calculate wins, losses and elo change
        wins = 0
        losses = 0
        elo_change = 0
        for match, match_participant in matches:
            if match.status == MatchStatus.COMPLETED:
                elo_change += (match_participant.elo_after or 0) - match_participant.elo_before
                # Count match-level wins/losses
                if match.winner_ids and match_participant.student_id in match.winner_ids:
                    wins += 1
                else:
                    losses += 1

        return StudentStatsResponse(
            student_id=student.id,
            name=student.name,
            elo_rating=student.elo_rating,
            wins=wins,
            losses=losses,
            fights_played=participant.fights_played,
            elo_change=elo_change
        )

    @staticmethod
    async def calculate_arena_stats(
        db: AsyncSession,
        arena_id: UUID,
        participant_students: List[Tuple[ArenaParticipant, Student]]
    ) -> List[StudentStatsResponse]:
        """Calculate stats for all participants in an arena session"""
        stats = []
        for participant, student in participant_students:
            stat = await ArenaStatsService.calculate_participant_stats(
                db, arena_id, participant, student
            )
            stats.append(stat)
        
        # Sort by ELO rating descending
        stats.sort(key=lambda x: x.elo_rating, reverse=True)
        return stats



================================================================================
File: backend\app\services\elo_service.py
================================================================================

from typing import Tuple

class EloService:
    def __init__(self, k_factor: int = 32):
        """
        Initialize ELO service with a k-factor.
        This k_factor (default=32) is typical in standard chess ELO for players
        under a certain rating threshold, though some leagues use a dynamic K.
        """
        self.k_factor = k_factor

    def calculate_expected_score(self, rating_a: float, rating_b: float) -> float:
        """
        Standard ELO expected score formula:
          E(A) = 1 / (1 + 10^((rating_B - rating_A) / 400))
        """
        return 1 / (1 + 10 ** ((rating_b - rating_a) / 400))

    def calculate_new_ratings(
        self, rating_winner: float, rating_loser: float
    ) -> Tuple[int, int]:
        """
        Given the winner's and loser's current ratings, return their new ratings
        after a single game, rounded to the nearest whole number.
        """
        # Calculate expected scores
        expected_winner = self.calculate_expected_score(rating_winner, rating_loser)
        expected_loser = 1.0 - expected_winner  # same as calculate_expected_score(rating_loser, rating_winner)

        # Update ratings
        new_winner_rating = rating_winner + self.k_factor * (1 - expected_winner)
        new_loser_rating = rating_loser + self.k_factor * (0 - expected_loser)

        # Round to nearest integer
        new_winner_rating = round(new_winner_rating)
        new_loser_rating = round(new_loser_rating)

        # Optional minimum rating clamp
        new_winner_rating = max(100, new_winner_rating)
        new_loser_rating = max(100, new_loser_rating)

        return new_winner_rating, new_loser_rating

    def calculate_rating_changes(
        self, rating_winner: float, rating_loser: float
    ) -> Tuple[int, int]:
        """
        Returns (winner_change, loser_change) as integers.
        """
        new_winner_rating, new_loser_rating = self.calculate_new_ratings(
            rating_winner, rating_loser
        )
        winner_change = new_winner_rating - rating_winner
        loser_change = new_loser_rating - rating_loser
        return int(winner_change), int(loser_change)



================================================================================
File: backend\app\services\matchmaking_service.py
================================================================================

from typing import List, Optional, Tuple, Dict
from sqlalchemy import select, and_, or_, func
from sqlalchemy.ext.asyncio import AsyncSession
from ..models.student import Student
from ..models.match import Match, MatchParticipant, MatchStatus
import random
import math
from datetime import datetime, timedelta, timezone

class MatchmakingService:
    def __init__(self, max_rating_diff: int = 300, recent_matches_window: int = 3):
        """
        Initialize matchmaking service
        max_rating_diff: Maximum ELO rating difference allowed for a match
        recent_matches_window: Number of hours to look back for recent matches
        """
        self.max_rating_diff = max_rating_diff
        self.recent_matches_window = recent_matches_window

    async def find_match(
        self, student_id: str, db: AsyncSession
    ) -> Optional[Match]:
        """Find an existing pending match for the student"""
        # Join with match_participants to find matches this student is in
        query = (
            select(Match)
            .join(MatchParticipant)
            .where(
                and_(
                    MatchParticipant.student_id == student_id,
                    Match.status == MatchStatus.PENDING
                )
            )
        )
        result = await db.execute(query)
        return result.scalar_one_or_none()

    async def get_recent_opponents(
        self, student_id: str, db: AsyncSession
    ) -> Dict[str, datetime]:
        """Get a map of recent opponents and when they last played"""
        cutoff_time = datetime.now(timezone.utc) - timedelta(hours=self.recent_matches_window)
        
        # Query recent matches for this student
        query = (
            select(Match, MatchParticipant)
            .join(MatchParticipant)
            .where(
                and_(
                    Match.created_at >= cutoff_time,
                    MatchParticipant.student_id != student_id,
                    Match.id.in_(
                        select(MatchParticipant.match_id)
                        .where(MatchParticipant.student_id == student_id)
                    )
                )
            )
        )
        
        result = await db.execute(query)
        recent_opponents = {}
        
        for match, participant in result:
            opponent_id = str(participant.student_id)
            match_time = match.created_at
            if opponent_id not in recent_opponents or match_time > recent_opponents[opponent_id]:
                recent_opponents[opponent_id] = match_time
                
        return recent_opponents

    async def get_participation_counts(
        self, db: AsyncSession, hours: int = 24
    ) -> Dict[str, int]:
        """Get number of matches played by each student in recent time period"""
        cutoff_time = datetime.now(timezone.utc) - timedelta(hours=hours)
        
        query = (
            select(
                MatchParticipant.student_id,
                func.count(MatchParticipant.match_id).label('match_count')
            )
            .join(Match)
            .where(Match.created_at >= cutoff_time)
            .group_by(MatchParticipant.student_id)
        )
        
        result = await db.execute(query)
        return {str(row.student_id): row.match_count for row in result}

    def calculate_opponent_score(
        self,
        opponent: Student,
        student: Student,
        recent_opponents: Dict[str, datetime],
        participation_counts: Dict[str, int],
        max_participation: int
    ) -> float:
        """Calculate a score for an opponent based on multiple factors"""
        # Base score from ELO difference (0-1, higher is better)
        elo_diff = abs(opponent.elo_rating - student.elo_rating)
        elo_score = 1.0 - (elo_diff / self.max_rating_diff)
        
        # Recent matchup penalty (0-1, higher is better)
        recency_score = 1.0
        if str(opponent.id) in recent_opponents:
            hours_ago = (datetime.now(timezone.utc) - recent_opponents[str(opponent.id)]).total_seconds() / 3600
            recency_score = min(hours_ago / self.recent_matches_window, 1.0)
            
        # Participation balance score (0-1, higher is better)
        participation_score = 1.0
        opponent_matches = participation_counts.get(str(opponent.id), 0)
        if max_participation > 0:
            participation_score = 1.0 - (opponent_matches / max_participation)
            
        # Weighted combination of factors
        # ELO difference is most important (0.5)
        # Recent matchups second most important (0.3)
        # Participation balance least important but still considered (0.2)
        return (0.5 * elo_score) + (0.3 * recency_score) + (0.2 * participation_score)

    async def find_opponents(
        self, student: Student, num_players: int, db: AsyncSession, potential_opponents: Optional[List[Student]] = None
    ) -> List[Student]:
        """
        Find suitable opponents for the student based on multiple factors
        potential_opponents: Optional list of students to choose from. If None, will query all students.
        """
        if potential_opponents is not None:
            # Filter provided opponents by rating range
            opponents = [
                o for o in potential_opponents
                if (o.id != student.id and
                    o.elo_rating >= student.elo_rating - self.max_rating_diff and
                    o.elo_rating <= student.elo_rating + self.max_rating_diff)
            ]
        else:
            # Query all potential opponents within rating range
            query = select(Student).where(
                and_(
                    Student.id != student.id,
                    Student.elo_rating >= student.elo_rating - self.max_rating_diff,
                    Student.elo_rating <= student.elo_rating + self.max_rating_diff
                )
            )
            result = await db.execute(query)
            opponents = result.scalars().all()

        if len(opponents) < num_players - 1:
            return []

        # Get recent matchup data
        recent_opponents = await self.get_recent_opponents(str(student.id), db)
        
        # Get participation data
        participation_counts = await self.get_participation_counts(db)
        max_participation = max(participation_counts.values()) if participation_counts else 0
        
        # Score each opponent
        scored_opponents = [
            (
                opponent,
                self.calculate_opponent_score(
                    opponent,
                    student,
                    recent_opponents,
                    participation_counts,
                    max_participation
                )
            )
            for opponent in opponents
        ]
        
        # Sort by score (highest to lowest)
        scored_opponents.sort(key=lambda x: x[1], reverse=True)
        
        # Take top half of opponents and use weighted random selection
        top_opponents = scored_opponents[:len(scored_opponents) // 2]
        total_score = sum(score for _, score in top_opponents)
        
        selected_opponents = []
        remaining_opponents = top_opponents.copy()
        
        # Select opponents one at a time using weighted random selection
        for _ in range(num_players - 1):
            if not remaining_opponents:
                break
                
            # Calculate selection weights
            weights = [score for _, score in remaining_opponents]
            total = sum(weights)
            if total > 0:
                weights = [w/total for w in weights]
            else:
                weights = [1.0/len(remaining_opponents)] * len(remaining_opponents)
            
            # Select an opponent
            selected_idx = random.choices(range(len(remaining_opponents)), weights=weights)[0]
            selected_opponents.append(remaining_opponents[selected_idx][0])
            remaining_opponents.pop(selected_idx)
            
        return selected_opponents

    async def create_multiplayer_match(
        self,
        player_ids: List[str],
        num_rounds: int,
        db: AsyncSession
    ) -> Match:
        """Create a new match with multiple players"""
        # Get all students and verify they exist
        participants = []
        for pid in player_ids:
            student = await db.get(Student, pid)
            if not student:
                raise ValueError(f"Student {pid} not found")
            participants.append(student)

        # Create the match
        match = Match(
            status=MatchStatus.PENDING,
            num_rounds=num_rounds,
        )
        db.add(match)
        await db.flush()  # Get match.id

        # Create participant records
        for student in participants:
            mp = MatchParticipant(
                match_id=match.id,
                student_id=student.id,
                elo_before=student.elo_rating
            )
            db.add(mp)

        await db.commit()
        await db.refresh(match)
        return match

    async def auto_find_players_and_create_match(
        self,
        num_players: int,
        num_rounds: int,
        student_id: str,
        db: AsyncSession
    ) -> Match:
        """
        Automatically find players with similar ELO and create a match.
        student_id is the requesting player who will be included.
        """
        student = await db.get(Student, student_id)
        if not student:
            raise ValueError("Student not found")

        # Find opponents with similar ratings
        opponents = await self.find_opponents(student, num_players, db)
        if len(opponents) < num_players - 1:
            raise ValueError(f"Could not find {num_players - 1} suitable opponents")

        # Create match with found players plus requesting student
        player_ids = [str(student.id)] + [str(o.id) for o in opponents]
        return await self.create_multiplayer_match(player_ids, num_rounds, db)



================================================================================
File: backend\app\services\statistics_service.py
================================================================================

from typing import List, Dict, Any
from sqlalchemy import select, func, desc
from sqlalchemy.ext.asyncio import AsyncSession
from ..models.student import Student
from ..models.match import Match, MatchStatus, Round, RoundParticipant
from ..models.flashcard import Flashcard
from ..models.arena_session import ArenaSession

class StatisticsService:
    @staticmethod
    async def get_flashcard_stats(flashcard_id: str, db: AsyncSession) -> Dict[str, Any]:
        """Get comprehensive statistics for a flashcard"""
        # Get the flashcard
        flashcard = await db.get(Flashcard, flashcard_id)
        if not flashcard:
            raise ValueError("Flashcard not found")

        # Get rounds where this flashcard was used
        rounds_query = select(Round).where(Round.flashcard_id == flashcard_id)
        result = await db.execute(rounds_query)
        rounds = result.scalars().all()

        total_uses = len(rounds)
        if total_uses == 0:
            return {
                "total_uses": 0,
                "success_rate": 0,
                "average_winners": 0,
                "used_in_arenas": 0
            }

        # Calculate statistics
        total_winners = sum(len(round.winner_ids or []) for round in rounds)
        total_participants = await db.scalar(
            select(func.count(RoundParticipant.student_id))
            .where(RoundParticipant.round_id.in_([r.id for r in rounds]))
        )

        # Get unique arena sessions this flashcard was used in
        unique_arenas = await db.scalar(
            select(func.count(func.distinct(Match.arena_id)))
            .join(Round, Round.match_id == Match.id)
            .where(Round.flashcard_id == flashcard_id)
        )

        return {
            "total_uses": total_uses,
            "success_rate": round((total_winners / total_participants * 100), 1) if total_participants > 0 else 0,
            "average_winners": round(total_winners / total_uses, 2),
            "used_in_arenas": unique_arenas
        }

    @staticmethod
    async def get_most_used_flashcards(db: AsyncSession, limit: int = 10) -> List[Dict[str, Any]]:
        """Get flashcards sorted by usage frequency"""
        query = (
            select(
                Flashcard,
                func.count(Round.id).label('usage_count')
            )
            .join(Round, Round.flashcard_id == Flashcard.id)
            .group_by(Flashcard.id)
            .order_by(desc('usage_count'))
            .limit(limit)
        )
        
        result = await db.execute(query)
        flashcards_with_count = result.all()

        stats = []
        for flashcard, usage_count in flashcards_with_count:
            flashcard_stats = await StatisticsService.get_flashcard_stats(flashcard.id, db)
            stats.append({
                "id": flashcard.id,
                "question": flashcard.question,
                "usage_count": usage_count,
                "success_rate": flashcard_stats["success_rate"],
                "used_in_arenas": flashcard_stats["used_in_arenas"]
            })

        return stats

    @staticmethod
    async def get_arena_flashcard_stats(arena_id: str, db: AsyncSession) -> List[Dict[str, Any]]:
        """Get statistics for all flashcards used in a specific arena session"""
        # Verify arena exists
        arena = await db.get(ArenaSession, arena_id)
        if not arena:
            raise ValueError("Arena session not found")

        # Get all rounds in this arena's matches
        rounds_query = (
            select(Round, Flashcard)
            .join(Match, Match.id == Round.match_id)
            .join(Flashcard, Flashcard.id == Round.flashcard_id)
            .where(Match.arena_id == arena_id)
        )
        
        result = await db.execute(rounds_query)
        rounds_with_flashcards = result.all()

        stats = {}
        for round, flashcard in rounds_with_flashcards:
            if flashcard.id not in stats:
                stats[flashcard.id] = {
                    "id": flashcard.id,
                    "question": flashcard.question,
                    "times_used": 0,
                    "total_winners": 0,
                    "total_participants": 0
                }
            
            stats[flashcard.id]["times_used"] += 1
            stats[flashcard.id]["total_winners"] += len(round.winner_ids or [])
            
            # Count participants
            participant_count = await db.scalar(
                select(func.count(RoundParticipant.student_id))
                .where(RoundParticipant.round_id == round.id)
            )
            stats[flashcard.id]["total_participants"] += participant_count

        # Calculate success rates and format response
        formatted_stats = []
        for flashcard_stats in stats.values():
            success_rate = (
                round(flashcard_stats["total_winners"] / flashcard_stats["total_participants"] * 100, 1)
                if flashcard_stats["total_participants"] > 0
                else 0
            )
            formatted_stats.append({
                "id": flashcard_stats["id"],
                "question": flashcard_stats["question"],
                "times_used": flashcard_stats["times_used"],
                "success_rate": success_rate
            })

        return sorted(formatted_stats, key=lambda x: x["times_used"], reverse=True)

    @staticmethod
    async def get_student_stats(student_id: str, db: AsyncSession) -> Dict[str, Any]:
        """Get comprehensive statistics for a student"""
        # Get the student
        student = await db.get(Student, student_id)
        if not student:
            raise ValueError("Student not found")

        # Get total matches
        matches_query = select(func.count(Match.id)).where(
            ((Match.player1_id == student_id) | (Match.player2_id == student_id)) &
            (Match.status == MatchStatus.COMPLETED)
        )
        total_matches = await db.scalar(matches_query)

        # Get win rate
        wins_query = select(func.count(Match.id)).where(
            (Match.winner_id == student_id) &
            (Match.status == MatchStatus.COMPLETED)
        )
        wins = await db.scalar(wins_query)
        win_rate = (wins / total_matches * 100) if total_matches > 0 else 0

        # Get average ELO change
        elo_changes = []
        matches = await db.execute(
            select(Match).where(
                ((Match.player1_id == student_id) | (Match.player2_id == student_id)) &
                (Match.status == MatchStatus.COMPLETED)
            )
        )
        for match in matches.scalars():
            if match.player1_id == student_id:
                elo_changes.append(match.player1_elo_change or 0)
            else:
                elo_changes.append(match.player2_elo_change or 0)

        avg_elo_change = sum(elo_changes) / len(elo_changes) if elo_changes else 0

        return {
            "total_matches": total_matches,
            "wins": wins,
            "losses": total_matches - wins,
            "win_rate": round(win_rate, 1),
            "current_elo": student.elo_rating,
            "avg_elo_change": round(avg_elo_change, 1)
        }

    @staticmethod
    async def get_leaderboard(db: AsyncSession, limit: int = 10) -> List[Dict[str, Any]]:
        """Get top students by ELO rating"""
        query = select(Student).order_by(desc(Student.elo_rating)).limit(limit)
        result = await db.execute(query)
        students = result.scalars().all()

        leaderboard = []
        for student in students:
            stats = await StatisticsService.get_student_stats(student.id, db)
            leaderboard.append({
                "id": student.id,
                "name": student.name,
                "elo_rating": student.elo_rating,
                "win_rate": stats["win_rate"],
                "total_matches": stats["total_matches"]
            })

        return leaderboard

    @staticmethod
    async def get_match_history(
        student_id: str, db: AsyncSession, limit: int = 10
    ) -> List[Dict[str, Any]]:
        """Get recent match history for a student"""
        query = select(Match).where(
            ((Match.player1_id == student_id) | (Match.player2_id == student_id)) &
            (Match.status == MatchStatus.COMPLETED)
        ).order_by(desc(Match.created_at)).limit(limit)

        result = await db.execute(query)
        matches = result.scalars().all()

        history = []
        for match in matches:
            opponent_id = match.player2_id if match.player1_id == student_id else match.player1_id
            opponent = await db.get(Student, opponent_id)
            
            elo_change = match.player1_elo_change if match.player1_id == student_id else match.player2_elo_change
            
            history.append({
                "match_id": match.id,
                "opponent_name": opponent.name,
                "opponent_rating": opponent.elo_rating,
                "won": match.winner_id == student_id,
                "elo_change": elo_change,
                "date": match.created_at
            })

        return history



================================================================================
File: frontend\src\App.tsx
================================================================================

import React from 'react';
import { MantineProvider } from '@mantine/core';
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { theme } from './theme';
import { Layout } from './components/shared/Layout';
import { StudentsPage } from './pages/StudentsPage';
import { FlashcardsPage } from './pages/FlashcardsPage';
import { ArenaPage } from './pages/ArenaPage';

function App() {
  return (
    <MantineProvider theme={theme} defaultColorScheme="light">
      <BrowserRouter>
        <Layout>
          <Routes>
            <Route path="/students" element={<StudentsPage />} />
            <Route path="/flashcards" element={<FlashcardsPage />} />
            <Route path="/arena" element={<ArenaPage />} />
            <Route path="/" element={<Navigate to="/arena" replace />} />
          </Routes>
        </Layout>
      </BrowserRouter>
    </MantineProvider>
  );
}

export default App;



================================================================================
File: frontend\src\index.tsx
================================================================================

import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import '@mantine/core/styles.css';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(<App />);



================================================================================
File: frontend\src\components\arena\ArenaBattle.tsx
================================================================================

import React, { useCallback, useEffect } from 'react';
import { Stack, Box } from '@mantine/core';
import { ErrorAlert } from '../shared/ErrorAlert';
import { ErrorBoundary } from '../shared/ErrorBoundary';
import { ArenaBattleCard } from './ArenaBattleCard';
import { VersusScreen } from './VersusScreen';
import { ArenaResultScreen } from './ArenaResultScreen';
import { ArenaStep } from '../../types/arena';
import type { Student, Flashcard } from '../../types';
import { useSound } from '../../hooks/useSound';

interface ArenaBattleProps {
  step: ArenaStep;
  currentFlashcard: Flashcard | null;
  currentMatch: {
    player1_id: string;
    player2_id: string;
    player1_elo_before: number;
    player2_elo_before: number;
  } | null;
  arenaSession: {
    rounds_completed: number;
    num_rounds: number;
    participants: any[];
  } | null;
  students: Student[];
  onVersusReady: () => void;
  onSelectWinner: (winnerIds: string[]) => void;
  onReset: () => void;
  isLoading: boolean;
}

export const ArenaBattle: React.FC<ArenaBattleProps> = ({
  step,
  currentFlashcard,
  currentMatch,
  arenaSession,
  students,
  onVersusReady,
  onSelectWinner,
  onReset,
  isLoading,
}) => {
  // Destructure the sound functions
  const {
    playBattleSound,
    stopBattleSound,
    playVsSound,
    playResultSound,
  } = useSound();

  const canPickWinner = step !== ArenaStep.VERSUS && !isLoading;

  /**
   * Manage sounds based on arena step changes
   */
  useEffect(() => {
    switch (step) {
      case ArenaStep.VERSUS:
        // Stop any leftover battle sound
        stopBattleSound();
        // Play the vs screen sound once
        playVsSound();
        break;
      case ArenaStep.BATTLE:
        // Start the looping battle sound
        playBattleSound();
        break;
      case ArenaStep.FINAL_RESULT:
        // Stop battle sound if it's still playing
        stopBattleSound();
        // Play the result screen sound once
        playResultSound();
        break;
      default:
        // In other steps (SETUP, ROUND_RESULT, etc.), no battle sound is needed
        stopBattleSound();
        break;
    }
    // Cleanup: if we unmount while battle-sound might be playing
    return () => {
      stopBattleSound();
    };
  }, [step, playBattleSound, stopBattleSound, playVsSound, playResultSound]);


  const handleVersusAnimationDone = useCallback(() => {
    onVersusReady();
  }, [onVersusReady]);

  const renderVersusScreen = () => {
    if (step !== ArenaStep.VERSUS) return null;
    if (!currentMatch) {
      return <ErrorAlert error="Match data not found" onRetry={onReset} />;
    }

    const player1 = students.find(s => s.id === currentMatch.player1_id);
    const player2 = students.find(s => s.id === currentMatch.player2_id);

    if (!player1 || !player2) {
      return <ErrorAlert error="Players not found" onRetry={onReset} />;
    }

    return (
      <ErrorBoundary fallback={<ErrorAlert error="Failed to display versus screen" onRetry={onReset} />}>
        <VersusScreen
          participants={[
            {
              student_id: player1.id,
              student: player1,
              elo_before: currentMatch.player1_elo_before,
            },
            {
              student_id: player2.id,
              student: player2,
              elo_before: currentMatch.player2_elo_before,
            },
          ]}
          onAnimationComplete={handleVersusAnimationDone}
        />
      </ErrorBoundary>
    );
  };

  const renderBattleScreen = () => {
    if (step !== ArenaStep.BATTLE) return null;
    if (!currentMatch || !currentFlashcard) {
      return <ErrorAlert error="Battle data not found" onRetry={onReset} />;
    }

    const player1 = students.find(s => s.id === currentMatch.player1_id);
    const player2 = students.find(s => s.id === currentMatch.player2_id);

    if (!player1 || !player2) {
      return <ErrorAlert error="Players not found" onRetry={onReset} />;
    }

    return (
      <ErrorBoundary fallback={<ErrorAlert error="Failed to display battle" onRetry={onReset} />}>
        <Stack align="center" gap="xl" style={{ width: '100%', minHeight: '70vh' }}>
          <ArenaBattleCard
            flashcard={currentFlashcard}
            player1={player1}
            player2={player2}
            roundsCompleted={arenaSession?.rounds_completed || 0}
            totalRounds={arenaSession?.num_rounds || 0}
            onSelectWinner={onSelectWinner}
            player1ELO={currentMatch.player1_elo_before}
            player2ELO={currentMatch.player2_elo_before}
            isLoading={isLoading}
            canPickWinner={canPickWinner}
          />
        </Stack>
      </ErrorBoundary>
    );
  };

  const renderFinalResult = () => {
    if (step !== ArenaStep.FINAL_RESULT) return null;
    if (!arenaSession) {
      return <ErrorAlert error="Session data not found" onRetry={onReset} />;
    }

    return (
      <ErrorBoundary fallback={<ErrorAlert error="Failed to display results" onRetry={onReset} />}>
        <Stack gap="md">
          <ArenaResultScreen
            results={arenaSession.participants}
            onFinish={onReset}
          />
        </Stack>
      </ErrorBoundary>
    );
  };

  return (
    <Box data-testid="arena-battle" style={{ width: '100%', position: 'relative' }}>
      {renderVersusScreen()}
      {renderBattleScreen()}
      {renderFinalResult()}
    </Box>
  );
};



================================================================================
File: frontend\src\components\arena\ArenaBattleCard.tsx
================================================================================

import React from 'react';
import { Stack, Group } from '@mantine/core';
import { Student, Flashcard } from '../../types';
import {
  BattleProgress,
  FlashcardDisplay,
  PlayerProfile,
  WinnerSelection,
} from './battle-card';

interface ArenaBattleCardProps {
  flashcard: Flashcard;
  player1: Student;
  player2: Student;
  roundsCompleted: number;
  totalRounds: number;
  onSelectWinner: (winnerIds: string[]) => void;
  player1ELO: number;
  player2ELO: number;
  isLoading?: boolean;
  canPickWinner: boolean;
}

export const ArenaBattleCard: React.FC<ArenaBattleCardProps> = ({
  flashcard,
  player1,
  player2,
  roundsCompleted,
  totalRounds,
  onSelectWinner,
  player1ELO,
  player2ELO,
  isLoading = false,
  canPickWinner,
}) => {
  return (
    <Stack style={{ width: '100%', maxWidth: '95%', margin: '0 auto' }} gap="md">
      <BattleProgress
        roundsCompleted={roundsCompleted}
        totalRounds={totalRounds}
      />

      <FlashcardDisplay flashcard={flashcard} />

      <Group justify="apart" mb="xl">
        <PlayerProfile
          player={player1}
          elo={player1ELO}
          colorGradient={{ from: '#4dabf7', to: '#228be6' }}
        />
        <PlayerProfile
          player={player2}
          elo={player2ELO}
          colorGradient={{ from: '#ff6b6b', to: '#fa5252' }}
        />
      </Group>

      <WinnerSelection
        player1={player1}
        player2={player2}
        onSelectWinner={onSelectWinner}
        isLoading={isLoading}
        canPickWinner={canPickWinner}
      />
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\ArenaResultScreen.tsx
================================================================================

import React from 'react';
import { motion } from 'framer-motion';
import { Card, Text, Stack, Button, Group, Badge, Grid, Table } from '@mantine/core';
import { IconTrophy, IconArrowUp, IconArrowDown, IconConfetti } from '@tabler/icons-react';

interface StudentStats {
  student_id: string;
  name: string;
  elo_rating: number;
  wins: number;
  losses: number;
  fights_played: number;
  elo_change: number;
}

interface ArenaResultScreenProps {
  results: StudentStats[];
  onFinish: () => void;
}

const RankBadge: React.FC<{ rank: number }> = ({ rank }) => {
  const color = rank === 1 ? 'yellow' : rank === 2 ? 'gray' : rank === 3 ? 'orange' : 'blue';
  const icon = rank <= 3 ? <IconTrophy size={16} /> : null;

  return (
    <Badge
      size="lg"
      color={color}
      variant={rank <= 3 ? 'filled' : 'light'}
      leftSection={icon}
    >
      #{rank}
    </Badge>
  );
};

export const ArenaResultScreen: React.FC<ArenaResultScreenProps> = ({
  results,
  onFinish
}) => {
  // Sort results by ELO rating descending
  const sortedResults = React.useMemo(() => {
    return [...results].sort((a, b) => b.elo_rating - a.elo_rating);
  }, [results]);

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.85 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.85 }}
      transition={{
        type: 'spring',
        stiffness: 100,
        damping: 15,
      }}
      style={{
        width: '100%',
        maxWidth: '95%',
        margin: '0 auto',
        padding: '2rem',
      }}
    >
      <Card
        shadow="lg"
        p="xl"
        radius="md"
        withBorder
        style={{
          background: 'linear-gradient(45deg, #F8FFAE, #43C6AC)',
          position: 'relative',
          overflow: 'hidden',
        }}
      >
        {/* Confetti Icon in BG */}
        <motion.div
          initial={{ rotate: 0 }}
          animate={{ rotate: 360 }}
          transition={{
            duration: 20,
            repeat: Infinity,
            ease: 'linear',
          }}
          style={{
            position: 'absolute',
            top: '-50px',
            right: '-50px',
            opacity: 0.2,
          }}
        >
          <IconConfetti size={200} />
        </motion.div>

        <Stack align="center" gap="xl">
          {/* Title */}
          <motion.div
            initial={{ y: -40, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{
              type: 'spring',
              stiffness: 300,
              damping: 15,
            }}
          >
            <Text
              size="xl"
              fw={900}
              style={{
                fontSize: '3rem',
                textAlign: 'center',
                color: '#fff',
                textShadow: '0 0 20px rgba(0,0,0,0.4)',
              }}
            >
              Arena Complete!
            </Text>
          </motion.div>

          {/* Top 3 Podium */}
          <Grid gutter="xl" style={{ width: '100%' }}>
            {sortedResults.slice(0, 3).map((student, index) => (
              <Grid.Col key={student.student_id} span={4}>
                <Card
                  shadow="md"
                  p="lg"
                  radius="md"
                  withBorder
                  style={{
                    background: 'rgba(255,255,255,0.8)',
                    backdropFilter: 'blur(4px)',
                  }}
                >
                  <Stack align="center" gap="md">
                    <RankBadge rank={index + 1} />
                    <Text size="xl" fw={700}>
                      {student.name}
                    </Text>
                    <Badge size="lg" variant="filled" color="blue">
                      {student.elo_rating} ELO
                    </Badge>
                    <Group>
                      <Badge color="green">Wins: {student.wins}</Badge>
                      <Badge color="red">Losses: {student.losses}</Badge>
                    </Group>
                    <Text
                      size="lg"
                      c={student.elo_change >= 0 ? 'green' : 'red'}
                      fw={700}
                    >
                      {student.elo_change > 0 ? '+' : ''}
                      {Math.round(student.elo_change)} ELO
                    </Text>
                  </Stack>
                </Card>
              </Grid.Col>
            ))}
          </Grid>

          {/* Full Results Table */}
          <Card
            shadow="sm"
            p="lg"
            radius="md"
            withBorder
            style={{ width: '100%', background: 'rgba(255,255,255,0.9)' }}
          >
            <Text size="lg" fw={700} mb="md">
              Final Rankings
            </Text>
            <Table striped highlightOnHover>
              <thead>
                <tr>
                  <th>Rank</th>
                  <th>Name</th>
                  <th>W/L</th>
                  <th>Fights</th>
                  <th>Final ELO</th>
                  <th>ELO Change</th>
                </tr>
              </thead>
              <tbody>
                {sortedResults.map((student, index) => {
                  const isPositive = student.elo_change >= 0;
                  return (
                    <tr key={student.student_id}>
                      <td>
                        <RankBadge rank={index + 1} />
                      </td>
                      <td>{student.name}</td>
                      <td>
                        <Group gap="xs">
                          <Text c="green">{student.wins}</Text>
                          <Text>/</Text>
                          <Text c="red">{student.losses}</Text>
                        </Group>
                      </td>
                      <td>{student.fights_played}</td>
                      <td>{student.elo_rating}</td>
                      <td>
                        <Group gap="xs">
                          {isPositive ? (
                            <IconArrowUp size={16} color="green" />
                          ) : (
                            <IconArrowDown size={16} color="red" />
                          )}
                          <Text c={isPositive ? 'green' : 'red'} fw={500}>
                            {isPositive ? '+' : ''}
                            {Math.round(student.elo_change)}
                          </Text>
                        </Group>
                      </td>
                    </tr>
                  );
                })}
              </tbody>
            </Table>
          </Card>

          {/* Finish Button */}
          <motion.div
            initial={{ opacity: 0, y: 30 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 1 }}
          >
            <Button
              size="lg"
              variant="gradient"
              gradient={{ from: 'blue', to: 'cyan' }}
              onClick={onFinish}
            >
              Return to Arena
            </Button>
          </motion.div>
        </Stack>
      </Card>
    </motion.div>
  );
};



================================================================================
File: frontend\src\components\arena\ArenaSetup.tsx
================================================================================

import React, { useCallback, useState, useEffect } from 'react';
import {
  Stack,
  Title,
  Select,
  NumberInput,
  Button,
  Text,
  SimpleGrid,
  Card,
  Avatar,
  Group,
  Badge,
  Box,
  Alert,
  MantineTheme,
} from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import { useArenaSetup } from '../../hooks/useArenaSetup';
import { useStudentStore } from '../../stores';
import { Student } from '../../types';

interface ArenaSetupProps {
  onStart: (packId: string, playerIds: string[], rounds: number) => void;
  isLoading?: boolean;
}

export const ArenaSetup: React.FC<ArenaSetupProps> = ({ onStart, isLoading = false }) => {
  const {
    selectedPackId,
    numRounds,
    selectedPlayerIds: oldSelectedIds,
    validationErrors,
    packSelectData,
    handlePackChange,
    handleRoundsChange,
    validateSetup,
    getSetupData,
    resetSetup,
  } = useArenaSetup();

  const { students, fetchStudents } = useStudentStore();
  const [selectedPlayerIds, setSelectedPlayerIds] = useState<string[]>([]);

  useEffect(() => {
    fetchStudents();
  }, [fetchStudents]);

  const toggleStudent = useCallback(
    (id: string) => {
      setSelectedPlayerIds((prev) =>
        prev.includes(id) ? prev.filter((sid) => sid !== id) : [...prev, id]
      );
    },
    [setSelectedPlayerIds]
  );

  const handleStartClick = () => {
    const data = getSetupData();
    if (!data.selectedPackId) {
      return;
    }
    if (selectedPlayerIds.length < 2) {
      window.alert('Please select at least 2 players for the Arena.');
      return;
    }
    if (numRounds < 1 || numRounds > 20) {
      window.alert('Rounds must be between 1 and 20');
      return;
    }

    onStart(data.selectedPackId, selectedPlayerIds, numRounds);
  };

  return (
    <Stack gap="md" data-testid="arena-setup">
      <Title order={2}>Flashcard Battle Setup</Title>

      <Select
        label="Select a Flashcard Pack"
        placeholder="Pick one"
        data={packSelectData}
        value={selectedPackId}
        onChange={handlePackChange}
        error={validationErrors.pack}
        required
      />

      <NumberInput
        label="Number of Rounds"
        min={1}
        max={20}
        value={numRounds}
        onChange={handleRoundsChange}
        error={validationErrors.rounds}
        required
      />

      <Box>
        <Text fw={500} mb="xs">
          Select Players (at least 2)
        </Text>
        {students.length === 0 ? (
          <Alert icon={<IconAlertCircle size={16} />} color="yellow">
            No students found. Please add some students first.
          </Alert>
        ) : (
          <SimpleGrid
            cols={3}
            style={{
              [`@media (max-width: 62.5em)`]: {
                gridTemplateColumns: 'repeat(2, 1fr)',
              },
              [`@media (max-width: 37.5em)`]: {
                gridTemplateColumns: 'repeat(1, 1fr)',
              },
            }}
          >
            {students.map((student: Student) => {
              const isSelected = selectedPlayerIds.includes(student.id);
              return (
                <Card
                  key={student.id}
                  onClick={() => toggleStudent(student.id)}
                  shadow={isSelected ? 'md' : 'sm'}
                  withBorder
                  styles={(theme: MantineTheme) => ({
                    root: {
                      cursor: 'pointer',
                      borderColor: isSelected ? theme.colors.teal[6] : undefined,
                      backgroundColor: isSelected
                        ? `${theme.colors.teal[0]}80`  // 50% opacity
                        : 'white',
                      transition: 'all 0.2s ease',
                      '&:hover': {
                        transform: 'translateY(-2px)',
                        boxShadow: isSelected ? 'md' : 'lg',
                      },
                    }
                  })}
                >
                  <Group>
                    <Avatar
                      radius="xl"
                      size={50}
                      src={student.avatar_url}
                      alt={student.name}
                    >
                      {(!student.avatar_url && student.name) ? student.name.charAt(0) : ''}
                    </Avatar>
                    <Stack gap={4}>
                      <Text fw={600}>{student.name}</Text>
                      <Badge color="teal" variant="light">
                        ELO: {student.elo_rating}
                      </Badge>
                    </Stack>
                  </Group>
                </Card>
              );
            })}
          </SimpleGrid>
        )}
      </Box>

      <Button 
        onClick={handleStartClick}
        variant="filled"
        color="teal"
        loading={isLoading}
        data-testid="start-arena-button"
      >
        Start Arena
      </Button>
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\BattleCard.tsx
================================================================================

import React from 'react';
import DOMPurify from 'dompurify';
import { motion, AnimatePresence } from 'framer-motion';
import {
  Card,
  Text,
  Stack,
  Button,
  Group,
  Progress,
  Badge,
  useMantineTheme,
  Box,
  Checkbox,
  TextInput,
} from '@mantine/core';
import { IconBolt } from '@tabler/icons-react';
import { Flashcard, RoundParticipant } from '../../types';
import { useSound } from '../../hooks/useSound';

interface BattleCardProps {
  flashcard: Flashcard;
  participants: RoundParticipant[];
  currentRound: number;
  totalRounds: number;
  onSubmitAnswer: (playerId: string, answer: string) => void;
  onSelectWinners: (winnerIds: string[]) => void;
}

export const BattleCard: React.FC<BattleCardProps> = ({
  flashcard,
  participants,
  currentRound,
  totalRounds,
  onSubmitAnswer,
  onSelectWinners,
}) => {
  const theme = useMantineTheme();
  const { playSound } = useSound();

  // Card flip states
  const [isFlipped, setIsFlipped] = React.useState(false);
  const [selectedWinners, setSelectedWinners] = React.useState<string[]>([]);
  const [answers, setAnswers] = React.useState<Record<string, string>>({});

  // Reset states when flashcard changes
  React.useEffect(() => {
    setIsFlipped(false);
    setSelectedWinners([]);
    setAnswers({});
  }, [flashcard]);

  // Force re-render of card content when flashcard changes
  const cardKey = React.useMemo(() => 
    `card-${flashcard.id}-${isFlipped ? 'back' : 'front'}`, 
    [flashcard.id, isFlipped]
  );

  // Handle answer submission for a participant
  const handleAnswerSubmit = (playerId: string, answer: string) => {
    setAnswers(prev => ({ ...prev, [playerId]: answer }));
    onSubmitAnswer(playerId, answer);
  };

  // Handle winner selection
  const handleWinnerToggle = (playerId: string) => {
    setSelectedWinners(prev => {
      const isSelected = prev.includes(playerId);
      if (isSelected) {
        return prev.filter(id => id !== playerId);
      } else {
        return [...prev, playerId];
      }
    });
  };

  // Submit winners
  const handleSubmitWinners = React.useCallback(() => {
    if (selectedWinners.length > 0) {
      playSound('correct');
      onSelectWinners(selectedWinners);
    }
  }, [selectedWinners, playSound, onSelectWinners]);

  // Flip the card to show/hide answer
  const handleFlip = React.useCallback(() => {
    playSound('flip');
    setIsFlipped((prev) => !prev);
  }, [playSound]);

  // Sanitize HTML content
  const sanitizedQuestion = React.useMemo(() => {
    try {
      const sanitized = DOMPurify.sanitize(flashcard.question || '');
      return sanitized || '<p>No question available</p>';
    } catch (error) {
      console.error('Error sanitizing question:', error);
      return '<p>Error displaying question</p>';
    }
  }, [flashcard.question]);

  const sanitizedAnswer = React.useMemo(() => {
    try {
      const sanitized = DOMPurify.sanitize(flashcard.answer || '');
      return sanitized || '<p>No answer available</p>';
    } catch (error) {
      console.error('Error sanitizing answer:', error);
      return '<p>Error displaying answer</p>';
    }
  }, [flashcard.answer]);

  // Difficulty color
  const difficultyColor =
    flashcard.difficulty === 'easy'
      ? 'green'
      : flashcard.difficulty === 'medium'
      ? 'yellow'
      : 'red';

  // Enhanced framer-motion variants for flipping
  const cardVariants = {
    hidden: {
      opacity: 0,
      rotateY: -180,
      scale: 0.95,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 20,
      },
    },
    visible: {
      opacity: 1,
      rotateY: 0,
      scale: 1,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
        mass: 1,
        delay: 0.1,
      },
    },
    exit: {
      opacity: 0,
      rotateY: 180,
      scale: 0.95,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 20,
      },
    },
  };

  // Variants for staggered answer section reveal
  const containerVariants = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.1,
        delayChildren: 0.2,
      },
    },
  };

  const itemVariants = {
    hidden: { opacity: 0, y: 20 },
    visible: {
      opacity: 1,
      y: 0,
      transition: {
        type: "spring",
        stiffness: 100,
        damping: 15,
      },
    },
  };

  // Progress bar animation variants
  const progressVariants = {
    initial: { scaleX: 0, originX: 0 },
    animate: { 
      scaleX: 1,
      transition: {
        type: "spring",
        stiffness: 60,
        damping: 15
      }
    }
  };

  return (
    <Stack style={{ width: '100%', maxWidth: '800px', margin: '0 auto' }} gap="md">
      {/* Match/round overview */}
      <Card shadow="sm" p="md" radius="md" withBorder>
        <motion.div
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{
            type: "spring",
            stiffness: 100,
            damping: 15,
          }}
        >
          <Group justify="space-between" mb="xs">
            {participants.map((participant, index) => (
              <motion.div
                key={participant.student_id}
                initial={{ opacity: 0, x: -20 }}
                animate={{ opacity: 1, x: 0 }}
                transition={{
                  type: "spring",
                  stiffness: 100,
                  damping: 15,
                  delay: index * 0.1,
                }}
              >
                <Group>
                  <Text fw={500}>{participant.student?.name}</Text>
                  <Badge color="blue">{participant.elo_before} ELO</Badge>
                </Group>
              </motion.div>
            ))}
          </Group>
          <Group justify="space-between" mb="xs">
            <Text size="sm" fw={500}>
              Round {currentRound}/{totalRounds}
            </Text>
            <Badge
              color={difficultyColor}
              variant="light"
              leftSection={<IconBolt size={14} />}
            >
              {flashcard.difficulty.toUpperCase()}
            </Badge>
          </Group>
          <motion.div
            initial="initial"
            animate="animate"
            variants={progressVariants}
          >
            <Progress
              value={(currentRound / totalRounds) * 100}
              size="xl"
              radius="xl"
            />
          </motion.div>
        </motion.div>
      </Card>

      {/* The flipping card itself */}
      <Box style={{
        perspective: 1000,
        position: 'relative',
        width: '100%',
        height: '300px',
      }}>
        <AnimatePresence mode="sync" initial={false}>
          {/* FRONT SIDE (the question) */}
          {!isFlipped && (
            <motion.div
              key={`${cardKey}-front`}
              initial="hidden"
              animate="visible"
              exit="exit"
              variants={cardVariants}
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                backgroundColor: theme.white,
                border: `1px solid ${theme.colors.gray[3]}`,
                borderRadius: theme.radius.md,
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                padding: theme.spacing.xl,
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
              }}
            >
              <Text
                ta="center"
                fw={700}
                size="xl"
                mb="md"
                dangerouslySetInnerHTML={{ __html: sanitizedQuestion }}
                style={{ overflowY: 'auto', maxHeight: '180px' }}
              />
              <Button
                mt="auto"
                variant="gradient"
                gradient={{ from: 'blue', to: 'cyan' }}
                onClick={handleFlip}
                style={{ transform: 'translateZ(50px)' }}
              >
                Flip to See Answer
              </Button>
            </motion.div>
          )}

          {/* BACK SIDE (the answer) */}
          {isFlipped && (
            <motion.div
              key={`${cardKey}-back`}
              initial="hidden"
              animate="visible"
              exit="exit"
              variants={cardVariants}
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)',
                backgroundColor: theme.white,
                border: `1px solid ${theme.colors.gray[3]}`,
                borderRadius: theme.radius.md,
                display: 'flex',
                flexDirection: 'column',
                justifyContent: 'center',
                padding: theme.spacing.xl,
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)',
              }}
            >
              <Text
                ta="center"
                fw={700}
                size="xl"
                mb="md"
                dangerouslySetInnerHTML={{ __html: sanitizedAnswer }}
                style={{ overflowY: 'auto', maxHeight: '180px' }}
              />
              <Button
                mt="auto"
                variant="gradient"
                gradient={{ from: 'orange', to: 'red' }}
                onClick={handleFlip}
                style={{ transform: 'translateZ(50px)' }}
              >
                Flip Back to Question
              </Button>
            </motion.div>
          )}
        </AnimatePresence>
      </Box>

      {/* Answer submission */}
      <motion.div
        initial="hidden"
        animate="visible"
        variants={containerVariants}
      >
        <Card shadow="sm" p="md" radius="md" withBorder>
          <Stack gap="md">
            <Text fw={500}>Submit Answers</Text>
            {participants.map((participant) => (
              <motion.div key={participant.student_id} variants={itemVariants}>
                <Group grow>
                  <TextInput
                    label={participant.student?.name}
                    placeholder="Enter answer..."
                    value={answers[participant.student_id] || ''}
                    onChange={(e) => handleAnswerSubmit(participant.student_id, e.target.value)}
                    disabled={!!participant.answer}
                  />
                  <Checkbox
                    label="Winner"
                    checked={selectedWinners.includes(participant.student_id)}
                    onChange={() => handleWinnerToggle(participant.student_id)}
                    disabled={!participant.answer}
                  />
                </Group>
              </motion.div>
            ))}
            <motion.div variants={itemVariants}>
              <Button
                color="blue"
                onClick={handleSubmitWinners}
                disabled={selectedWinners.length === 0}
              >
                Submit Winners
              </Button>
            </motion.div>
          </Stack>
        </Card>
      </motion.div>
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\ResultScreen.tsx
================================================================================

import React from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { Card, Text, Stack, Button, Group, Badge, Grid } from '@mantine/core';
import { Match, MatchParticipant } from '../../types';

interface ResultScreenProps {
  match: Match;
  onContinue: () => void;
}

interface ParticipantStatsProps {
  participant: MatchParticipant;
  roundWins: number;
  isWinner: boolean;
}

const ParticipantStats: React.FC<ParticipantStatsProps> = ({
  participant,
  roundWins,
  isWinner,
}) => {
  const eloChange = (participant.elo_after || 0) - (participant.elo_before || 0);

  return (
    <motion.div
      initial={{ opacity: 0, y: 50 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{
        type: "spring",
        stiffness: 100,
        damping: 15,
      }}
    >
      <motion.div
        whileHover={{ 
          scale: 1.02,
          rotateY: 5,
          transition: { type: "spring", stiffness: 400, damping: 10 }
        }}
      >
        <Card 
          shadow="sm" 
          p="lg" 
          radius="md" 
          withBorder 
          style={{ 
            height: '100%',
            transform: "perspective(1000px)",
            transformStyle: "preserve-3d",
            background: isWinner ? 
              'linear-gradient(45deg, rgba(255,215,0,0.1), rgba(255,255,255,0.1))' : 
              undefined
          }}
        >
          <Stack align="center" gap="md">
            <motion.div
              animate={isWinner ? {
                y: [0, -10, 0],
                scale: [1, 1.1, 1],
              } : {}}
              transition={{
                duration: 2,
                repeat: Infinity,
                repeatType: 'reverse',
                ease: "easeInOut"
              }}
            >
              <Text 
                size="xl" 
                fw={700}
                style={{
                  textShadow: isWinner ? '0 0 10px rgba(255,215,0,0.5)' : undefined
                }}
              >
                {participant.student?.name}
              </Text>
            </motion.div>

            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{
                type: "spring",
                stiffness: 200,
                damping: 15,
                delay: 0.2
              }}
            >
              <Badge 
                size="xl" 
                color={isWinner ? 'green' : 'red'}
                style={{
                  transform: "translateZ(20px)",
                  boxShadow: isWinner ? '0 0 20px rgba(0,255,0,0.3)' : undefined
                }}
              >
                {isWinner ? 'Winner!' : 'Defeated'}
              </Badge>
            </motion.div>
            
            {/* ELO Change */}
            <motion.div
              initial={{ scale: 0 }}
              animate={{ scale: 1 }}
              transition={{
                type: "spring",
                stiffness: 200,
                damping: 15,
                delay: 0.4
              }}
            >
              <motion.div
                animate={isWinner ? {
                  scale: [1, 1.2, 1],
                  rotate: [0, 5, 0, -5, 0]
                } : {}}
                transition={{
                  duration: 2,
                  repeat: Infinity,
                  repeatType: 'reverse'
                }}
              >
                <Text 
                  size="lg" 
                  c={eloChange >= 0 ? 'green' : 'red'}
                  fw={700}
                  style={{
                    textShadow: `0 0 10px ${eloChange >= 0 ? 'rgba(0,255,0,0.3)' : 'rgba(255,0,0,0.3)'}`
                  }}
                >
                  {eloChange > 0 ? '+' : ''}{Math.round(eloChange * 10) / 10} ELO
                </Text>
              </motion.div>
            </motion.div>

            {/* Rating Change */}
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{
                type: "spring",
                stiffness: 100,
                damping: 15,
                delay: 0.6
              }}
            >
              <Group>
                <Text size="md" c="dimmed">
                  {participant.elo_before} 
                </Text>
                <Text 
                  size="md" 
                  fw={700}
                  style={{
                    color: isWinner ? '#FFD700' : undefined,
                    textShadow: isWinner ? '0 0 10px rgba(255,215,0,0.5)' : undefined
                  }}
                >
                  {participant.elo_after}
                </Text>
              </Group>
            </motion.div>

            {/* Round Wins */}
            <motion.div
              initial={{ opacity: 0, x: 20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{
                type: "spring",
                stiffness: 100,
                damping: 15,
                delay: 0.8
              }}
            >
              <Text size="md">
                Rounds Won: {roundWins}
              </Text>
            </motion.div>

            {/* Winner Effects */}
            {isWinner && (
              <motion.div
                initial={{ scale: 0 }}
                animate={{ scale: [0, 1.2, 1] }}
                transition={{
                  type: "spring",
                  stiffness: 200,
                  damping: 10,
                  delay: 1
                }}
                style={{
                  position: 'absolute',
                  top: -20,
                  right: -20,
                  width: 40,
                  height: 40,
                  background: 'linear-gradient(45deg, #FFD700, #FFA500)',
                  borderRadius: '50%',
                  boxShadow: '0 0 20px rgba(255,215,0,0.5)',
                  zIndex: -1
                }}
              />
            )}
          </Stack>
        </Card>
      </motion.div>
    </motion.div>
  );
};

export const ResultScreen: React.FC<ResultScreenProps> = ({
  match,
  onContinue
}) => {
  // Calculate round wins for each participant
  const roundWins = React.useMemo(() => {
    const wins: Record<string, number> = {};
    match.rounds?.forEach(round => {
      if (round.winner_ids && round.winner_ids.length > 0) {
        round.winner_ids.forEach(winnerId => {
          wins[winnerId] = (wins[winnerId] || 0) + 1;
        });
      }
    });
    return wins;
  }, [match.rounds]);

  // Sort participants by round wins (descending)
  const sortedParticipants = React.useMemo(() => {
    return [...match.participants].sort((a, b) => {
      const aWins = roundWins[a.student_id] || 0;
      const bWins = roundWins[b.student_id] || 0;
      return bWins - aWins;
    });
  }, [match.participants, roundWins]);

  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.8 }}
      transition={{
        type: "spring",
        stiffness: 100,
        damping: 15
      }}
      style={{
        width: '100%',
        maxWidth: '1200px',
        margin: '0 auto',
        padding: '2rem'
      }}
    >
      <Card 
        shadow="lg" 
        p="xl" 
        radius="md" 
        withBorder
        style={{
          transform: "perspective(1000px)",
          transformStyle: "preserve-3d",
          background: 'linear-gradient(45deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05))'
        }}
      >
        <Stack align="center" gap="xl">
          {/* Title */}
          <motion.div
            initial={{ y: -50, opacity: 0 }}
            animate={{ y: 0, opacity: 1 }}
            transition={{
              type: 'spring',
              stiffness: 200,
              damping: 15
            }}
          >
            <motion.div
              animate={{
                scale: [1, 1.1, 1],
                rotate: [0, 2, 0, -2, 0]
              }}
              transition={{
                duration: 4,
                repeat: Infinity,
                repeatType: 'reverse',
                ease: "easeInOut"
              }}
            >
              <Text
                size="xl"
                fw={900}
                variant="gradient"
                gradient={{ from: 'gold', to: 'yellow', deg: 45 }}
                ta="center"
                style={{ 
                  fontSize: '3rem',
                  textShadow: '0 0 20px rgba(255,215,0,0.5)',
                  letterSpacing: '0.1em'
                }}
              >
                Match Complete!
              </Text>
            </motion.div>
          </motion.div>

          {/* Match Stats */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{
              type: "spring",
              stiffness: 100,
              damping: 15,
              delay: 0.2
            }}
          >
            <Group justify="center" gap="md">
              <Text size="lg" fw={500}>
                Rounds: {match.rounds_completed}/{match.num_rounds}
              </Text>
            </Group>
          </motion.div>

          {/* Participants Grid */}
          <Grid gutter="xl" style={{ width: '100%' }}>
            {sortedParticipants.map((participant, index) => (
              <Grid.Col 
                key={participant.student_id} 
                span={12 / Math.min(sortedParticipants.length, 3)}
              >
                <ParticipantStats
                  participant={participant}
                  roundWins={roundWins[participant.student_id] || 0}
                  isWinner={match.winner_ids?.includes(participant.student_id) ?? false}
                />
              </Grid.Col>
            ))}
          </Grid>

          {/* Continue Button */}
          <motion.div
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{
              type: "spring",
              stiffness: 100,
              damping: 15,
              delay: 1
            }}
          >
            <motion.div
              whileHover={{ 
                scale: 1.05,
                transition: { type: "spring", stiffness: 400, damping: 10 }
              }}
              whileTap={{ scale: 0.95 }}
            >
              <Button
                size="lg"
                variant="gradient"
                gradient={{ from: 'blue', to: 'cyan' }}
                onClick={onContinue}
                style={{
                  transform: "translateZ(20px)",
                  boxShadow: '0 4px 15px rgba(0,0,0,0.2)'
                }}
              >
                Continue
              </Button>
            </motion.div>
          </motion.div>
        </Stack>
      </Card>
    </motion.div>
  );
};



================================================================================
File: frontend\src\components\arena\VersusScreen.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { Text, Avatar, Grid, Box, Group, rem } from '@mantine/core';
import { MatchParticipant } from '../../types';

interface VersusScreenProps {
  participants?: MatchParticipant[];
  onAnimationComplete: () => void;
}

export const VersusScreen: React.FC<VersusScreenProps> = ({
  participants,
  onAnimationComplete,
}) => {
  const [animDone, setAnimDone] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      onAnimationComplete();
    }, 2500); // 2.5 seconds
    return () => {
      clearTimeout(timer);
    };
  }, [onAnimationComplete]);

  if (!participants || participants.length === 0) {
    return <Box>No participants available</Box>;
  }

  const vsVariants = {
    initial: { scale: 0, opacity: 0, y: 20 },
    animate: {
      scale: 1,
      opacity: 1,
      y: 0,
      transition: {
        duration: 0.6,
        ease: "easeOut"
      }
    }
  };

  const glowVariants = {
    animate: {
      opacity: [0.5, 1, 0.5],
      scale: [1, 1.1, 1],
      transition: {
        duration: 2,
        repeat: Infinity,
        ease: "easeInOut"
      }
    }
  };

  return (
    <Box
      data-testid="versus-screen"
      style={{
        position: 'relative',
        width: '100%',
        minHeight: '80vh',
        background: 'linear-gradient(135deg, #1a237e 0%, #311b92 50%, #4a148c 100%)',
        borderRadius: '16px',
        padding: '3rem',
        overflow: 'hidden',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        boxShadow: '0 8px 32px rgba(0, 0, 0, 0.3)'
      }}
    >
      {/* Background Effect */}
      <Box
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          background: 'radial-gradient(circle at 50% 50%, rgba(255,255,255,0.1) 0%, transparent 60%)',
          pointerEvents: 'none'
        }}
      />

      <Grid
        justify="center"
        align="center"
        style={{
          width: '100%',
          position: 'relative',
          zIndex: 1,
        }}
      >
        {/* VS TEXT */}
        <Box
          style={{
            position: 'absolute',
            left: '50%',
            top: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: 10,
          }}
        >
          <motion.div
            variants={glowVariants}
            animate="animate"
            style={{
              position: 'absolute',
              left: '50%',
              top: '50%',
              transform: 'translate(-50%, -50%)',
              width: '30vw',
              height: '30vw',
              maxHeight: '200px',
              maxWidth: '200px',
              background: 'radial-gradient(circle, rgba(255,215,0,0.2) 0%, transparent 70%)',
              borderRadius: '50%',
              filter: 'blur(20px)',
            }}
          />
          <motion.div
            variants={vsVariants}
            initial="initial"
            animate="animate"
            style={{
              position: 'relative',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
            }}
          >
            <Text
              fw={900}
              style={{
                fontSize: 'clamp(6rem, 20vw, 10rem)',
                color: '#FFD700',
                textShadow: '0 0 30px rgba(255,215,0,0.5), 0 0 60px rgba(255,215,0,0.3), 0 0 90px rgba(255,215,0,0.2)',
                letterSpacing: '8px',
                transform: 'translateY(-50%)',
              }}
            >
              VS
            </Text>
          </motion.div>
        </Box>

        {participants.map((participant, index) => {
          if (!participant.student) return null;
          const isLeft = index === 0;
          const xStart = isLeft ? -200 : 200;

          return (
            <Grid.Col key={participant.student_id} span={6}>
              <motion.div initial={{
                x: xStart,
                opacity: 0
              }} animate={{
                x: 0,
                opacity: 1
              }} transition={{
                type: 'spring',
                stiffness: 60,
                damping: 12,
                delay: 0.2 + index * 0.3
              }} style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                height: '100%',
                padding: '0 2rem'
              }}>
                <Box style={{
                  padding: '2rem',
                  borderRadius: '24px',
                  background: 'rgba(255, 255, 255, 0.1)',
                  boxShadow: '0 12px 40px rgba(0, 0, 0, 0.4)',
                  backdropFilter: 'blur(12px)',
                  textAlign: 'center',
                  width: '100%',
                  display: 'flex',
                  flexDirection: 'column',
                  alignItems: 'center',
                  gap: '1.5rem',
                  border: '2px solid rgba(255, 255, 255, 0.15)',
                  transform: 'translateY(0)',
                  transition: 'transform 0.3s ease',
                  '&:hover': {
                    transform: 'translateY(-5px)'
                  }
                }}>
                  <Avatar src={participant.student.avatar_url || undefined} alt={participant.student.name} size={140} radius={70} style={{
                    margin: '0 auto',
                    border: '4px solid rgba(255, 255, 255, 0.9)',
                    boxShadow: '0 0 30px rgba(0,0,0,0.4), 0 0 60px rgba(255,255,255,0.1)'
                  }}>
                    {(!participant.student.avatar_url && participant.student.name)
                      ? participant.student.name.charAt(0)
                      : ''}
                  </Avatar>
                  <Text fw={700} style={{
                    color: 'white',
                    textShadow: '0 2px 4px rgba(0,0,0,0.4)',
                    textAlign: 'center',
                    width: '100%',
                    fontSize: 'clamp(28px, 5vw, 40px)',
                    letterSpacing: '0.5px',
                    overflow: 'hidden',
                    textOverflow: 'ellipsis',
                    whiteSpace: 'nowrap'
                  }}>
                    {participant.student.name}
                  </Text>

                  <Group justify="center">
                    <Text
                      size="28px"
                      fw={700}
                      style={{
                        color: '#FFD700',
                        textShadow: '0 2px 4px rgba(0,0,0,0.5), 0 0 20px rgba(255,215,0,0.3)',
                        letterSpacing: '2px'
                      }}
                    >
                      {participant.elo_before || 1000} ELO
                    </Text>
                  </Group>
                </Box>
              </motion.div>
            </Grid.Col>
          );
        })}
      </Grid>
    </Box>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\BattleProgress.tsx
================================================================================

import React from 'react';
import { Card, Text, Progress } from '@mantine/core';

interface BattleProgressProps {
  roundsCompleted: number;
  totalRounds: number;
}

export const BattleProgress: React.FC<BattleProgressProps> = ({
  roundsCompleted,
  totalRounds,
}) => {
  return (
    <Card shadow="sm" p="md" radius="md" withBorder>
      <Text size="lg" fw={700} ta="center" mb="md">
        Battle {roundsCompleted + 1} of {totalRounds}
      </Text>
      <Progress
        value={((roundsCompleted + 1) / totalRounds) * 100}
        size="xl"
        radius="xl"
        mb="md"
      />
    </Card>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\FlashcardDisplay.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { Card, Text, Stack, Group, Box, Tooltip, ActionIcon } from '@mantine/core';
import { motion } from 'framer-motion';
import { IconRefresh } from '@tabler/icons-react';
import { Flashcard } from '../../../types';

interface FlashcardDisplayProps {
  flashcard: Flashcard;
}

export const FlashcardDisplay: React.FC<FlashcardDisplayProps> = ({
  flashcard,
}) => {
  const [isFlipped, setIsFlipped] = useState(false);

  const handleFlip = useCallback(() => {
    setIsFlipped((prev) => !prev);
  }, []);

  const getFontSize = useCallback((text: string) => {
    const length = text.length;
    if (length > 200) return '32px';
    if (length > 100) return '48px';
    if (length > 50) return '64px';
    return '96px';
  }, []);

  const sharedTextStyle = {
    flexGrow: 1,
    wordBreak: 'break-word' as const,
    maxHeight: '100%',
    overflowY: 'auto' as const,
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    padding: '0.5rem',
    lineHeight: 1.2,
  };

  return (
    <Box
      style={{
        perspective: '1000px',
        width: '100%',
        maxHeight: '420px',
        height: 'auto',
        minHeight: '300px',
        position: 'relative',
        padding: '1rem',
      }}
    >
      <motion.div
        style={{
          width: '100%',
          height: '100%',
          position: 'absolute',
          transformStyle: 'preserve-3d',
          transition: 'transform 0.8s ease',
          transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)',
        }}
      >
        {/* Front side: question */}
        <motion.div
          style={{
            width: '100%',
            height: '100%',
            position: 'absolute',
            backfaceVisibility: 'hidden',
          }}
        >
          <Card
            shadow="lg"
            p="md"
            radius="md"
            withBorder
            style={{
              width: '100%',
              height: '100%',
              background: 'linear-gradient(135deg, #FEE140 0%, #FA709A 100%)',
              color: '#333',
              boxSizing: 'border-box',
            }}
          >
            <Stack gap="xs" style={{ height: '100%' }}>
              <Text
                size={getFontSize(flashcard.question)}
                fw={800}
                ta="center"
                style={sharedTextStyle}
              >
                {flashcard.question}
              </Text>
              <Group justify="center">
                <Tooltip label="Flip to see Answer" withArrow>
                  <ActionIcon variant="light" onClick={handleFlip}>
                    <IconRefresh size={20} />
                  </ActionIcon>
                </Tooltip>
              </Group>
            </Stack>
          </Card>
        </motion.div>

        {/* Back side: answer */}
        <motion.div
          style={{
            width: '100%',
            height: '100%',
            position: 'absolute',
            backfaceVisibility: 'hidden',
            transform: 'rotateY(180deg)',
          }}
        >
          <Card
            shadow="lg"
            p="xl"
            radius="md"
            withBorder
            style={{
              width: '100%',
              height: '100%',
              background: 'linear-gradient(135deg, #A1FFCE 0%, #FAFFD1 100%)',
              color: '#333',
              boxSizing: 'border-box',
            }}
          >
            <Stack gap="md" style={{ height: '100%' }}>
              <Text
                size={getFontSize(flashcard.answer)}
                fw={800}
                ta="center"
                style={sharedTextStyle}
              >
                {flashcard.answer}
              </Text>
              <Group justify="center">
                <Tooltip label="Flip to see Question" withArrow>
                  <ActionIcon variant="light" onClick={handleFlip}>
                    <IconRefresh size={20} />
                  </ActionIcon>
                </Tooltip>
              </Group>
            </Stack>
          </Card>
        </motion.div>
      </motion.div>
    </Box>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\index.ts
================================================================================

export { BattleProgress } from './BattleProgress';
export { FlashcardDisplay } from './FlashcardDisplay';
export { PlayerProfile } from './PlayerProfile';
export { WinnerSelection } from './WinnerSelection';



================================================================================
File: frontend\src\components\arena\battle-card\PlayerProfile.tsx
================================================================================

import React from 'react';
import { Stack, Avatar, Text, Badge, Box } from '@mantine/core';
import { motion } from 'framer-motion';
import { Student } from '../../../types';

interface PlayerProfileProps {
  player: Student;
  elo: number;
  colorGradient: { from: string; to: string };
}

export const PlayerProfile: React.FC<PlayerProfileProps> = ({
  player,
  elo,
  colorGradient,
}) => {
  return (
    <Stack align="center" gap="xs" style={{ flex: 1 }}>
      <Box
        style={{
          position: 'relative',
          padding: '4px',
          borderRadius: '50%',
          background: `linear-gradient(45deg, ${colorGradient.from}, ${colorGradient.to})`,
          boxShadow: `0 0 10px rgba(${colorGradient.from === '#4dabf7' ? '77, 171, 247' : '255, 107, 107'}, 0.3)`,
        }}
      >
        <motion.div
          animate={{
            scale: [1, 1.05, 1],
            rotate: [0, 2, -2, 0],
          }}
          transition={{
            duration: 2,
            repeat: Infinity,
            repeatType: 'reverse',
          }}
        >
          <Avatar
            src={player.avatar_url || undefined}
            alt={player.name}
            radius="xl"
            size={64}
            style={{
              border: '2px solid #fff',
              boxShadow: `0 0 10px rgba(${colorGradient.from === '#4dabf7' ? '77, 171, 247' : '255, 107, 107'}, 0.2)`,
            }}
          >
            {(!player.avatar_url && player.name) ? player.name.charAt(0) : ''}
          </Avatar>
        </motion.div>
      </Box>
      <Text
        size="xl"
        fw={700}
        style={{
          background: `linear-gradient(45deg, ${colorGradient.from}, ${colorGradient.to})`,
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
        }}
      >
        {player.name}
      </Text>
      <Badge
        size="lg"
        variant="gradient"
        gradient={colorGradient}
      >
        <Text size="md" fw={600}>
          {elo} ELO
        </Text>
      </Badge>
      <Text size="sm" color="dimmed">
        W: {player.wins} L: {player.losses}
      </Text>
    </Stack>
  );
};



================================================================================
File: frontend\src\components\arena\battle-card\WinnerSelection.tsx
================================================================================

import React from 'react';
import { Card, Text, Group, Button } from '@mantine/core';
import { motion } from 'framer-motion';
import { IconSword, IconTrophy } from '@tabler/icons-react';
import { Badge } from '@mantine/core';
import { Student } from '../../../types';

interface WinnerSelectionProps {
  player1: Student;
  player2: Student;
  onSelectWinner: (winnerIds: string[]) => void;
  isLoading?: boolean;
  canPickWinner: boolean;
}

export const WinnerSelection: React.FC<WinnerSelectionProps> = ({
  player1,
  player2,
  onSelectWinner,
  isLoading = false,
  canPickWinner,
}) => {
  return (
    <Card shadow="sm" p="md" radius="md" withBorder>
      <Group justify="center" mb="xl">
        <motion.div
          animate={{
            scale: [1, 1.1, 1],
            rotate: [0, 5, -5, 0],
          }}
          transition={{
            duration: 1.5,
            repeat: Infinity,
            repeatType: 'reverse',
          }}
        >
          <Badge
            size="xl"
            variant="gradient"
            gradient={{ from: 'orange', to: 'red' }}
            style={{
              padding: '1.2rem',
              boxShadow: '0 0 15px rgba(255, 107, 107, 0.3)',
            }}
          >
            <IconSword size={28} />
          </Badge>
        </motion.div>
      </Group>

      <Text
        ta="center"
        fw={700}
        mb="md"
        size="xl"
        style={{
          background: 'linear-gradient(45deg, #ff6b6b, #4dabf7)',
          WebkitBackgroundClip: 'text',
          WebkitTextFillColor: 'transparent',
          textShadow: '0 0 20px rgba(0,0,0,0.1)',
        }}
      >
        Pick the Winner
      </Text>
      <Group grow>
        <Button
          variant="gradient"
          gradient={{ from: '#4dabf7', to: '#228be6' }}
          data-testid={`select-winner-${player1.id}`}
          onClick={() => onSelectWinner([player1.id])}
          disabled={!canPickWinner || isLoading}
          size="md"
          leftSection={<IconTrophy size={20} />}
        >
          {player1.name}
        </Button>
        <Button
          variant="gradient"
          gradient={{ from: '#ff6b6b', to: '#fa5252' }}
          data-testid={`select-winner-${player2.id}`}
          onClick={() => onSelectWinner([player2.id])}
          disabled={!canPickWinner || isLoading}
          size="lg"
          leftSection={<IconTrophy size={20} />}
        >
          {player2.name}
        </Button>
      </Group>
    </Card>
  );
};



================================================================================
File: frontend\src\components\flashcards\FlashcardControls.tsx
================================================================================

import React, { useCallback, useMemo } from 'react';
import {
  Group,
  TextInput,
  Select,
  SegmentedControl,
  ActionIcon,
  Text,
  Popover,
} from '@mantine/core';
import {
  IconSearch,
  IconFilter,
  IconKeyboard,
  IconLayoutGrid,
  IconLayoutList,
} from '@tabler/icons-react';
import { DifficultyLevel } from '../../types';
import { ViewMode, AdvancedFilters } from '../../hooks/useFlashcardFilters';

interface FlashcardControlsProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
  difficultyFilter: string;
  onDifficultyChange: (value: string) => void;
  viewMode: ViewMode;
  onViewModeChange: (value: ViewMode) => void;
  advancedFilters: AdvancedFilters;
  onShowAdvancedFilters: () => void;
  onShowKeyboardShortcuts: () => void;
}

export const FlashcardControls = React.memo(function FlashcardControls({
  searchQuery,
  onSearchChange,
  difficultyFilter,
  onDifficultyChange,
  viewMode,
  onViewModeChange,
  advancedFilters,
  onShowAdvancedFilters,
  onShowKeyboardShortcuts,
}: FlashcardControlsProps) {
  const handleSearchChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    onSearchChange(e.currentTarget.value);
  }, [onSearchChange]);

  const handleDifficultyChange = useCallback((value: string | null) => {
    onDifficultyChange(value || 'all');
  }, [onDifficultyChange]);

  const handleViewModeChange = useCallback((value: string) => {
    onViewModeChange(value as ViewMode);
  }, [onViewModeChange]);

  const difficultyOptions = useMemo(() => [
    { value: 'all', label: 'All Difficulties' },
    { value: DifficultyLevel.EASY, label: 'Easy' },
    { value: DifficultyLevel.MEDIUM, label: 'Medium' },
    { value: DifficultyLevel.HARD, label: 'Hard' },
  ], []);

  const viewModeOptions = useMemo(() => [
    {
      value: 'grid',
      label: (
        <Group gap={4}>
          <IconLayoutGrid size={16} />
          <Text size="sm">Grid</Text>
        </Group>
      ),
    },
    {
      value: 'list',
      label: (
        <Group gap={4}>
          <IconLayoutList size={16} />
          <Text size="sm">List</Text>
        </Group>
      ),
    },
  ], []);

  const isFiltersActive = useMemo(() => 
    advancedFilters.dateRange[0] || 
    advancedFilters.successRateRange[0] !== 0 || 
    advancedFilters.usageRange[0] !== 0,
    [advancedFilters]
  );

  return (
    <Group justify="space-between" mb="md">
      <Group>
        <TextInput
          name="search"
          placeholder="Search flashcards..."
          value={searchQuery}
          onChange={handleSearchChange}
          leftSection={<IconSearch size={16} />}
          style={{ width: 300 }}
        />
        
        <Popover width={200} position="bottom" withArrow shadow="md">
          <Popover.Target>
            <ActionIcon
              variant="light"
              size="lg"
              onClick={onShowAdvancedFilters}
              aria-label="Advanced filters"
            >
              <IconFilter size={20} />
            </ActionIcon>
          </Popover.Target>
          <Popover.Dropdown>
            <Text size="sm">
              {isFiltersActive ? 'Filters active' : 'No filters active'}
            </Text>
          </Popover.Dropdown>
        </Popover>
      </Group>
      
      <Group>
        <ActionIcon
          variant="light"
          size="lg"
          onClick={onShowKeyboardShortcuts}
          aria-label="Keyboard shortcuts"
        >
          <IconKeyboard size={20} />
        </ActionIcon>
        
        <Select
          value={difficultyFilter}
          onChange={handleDifficultyChange}
          data={difficultyOptions}
          style={{ width: 150 }}
        />

        <SegmentedControl
          value={viewMode}
          onChange={handleViewModeChange}
          data={viewModeOptions}
        />
      </Group>
    </Group>
  );
});



================================================================================
File: frontend\src\components\flashcards\FlashcardEditor.tsx
================================================================================

import React, { useCallback, useState } from 'react';
import {
  Box,
  Button,
  Group,
  Paper,
  Select,
  Stack,
  Text,
  Textarea,
  rem,
} from '@mantine/core';
import { motion } from 'framer-motion';
import { IconDeviceFloppy, IconX } from '@tabler/icons-react';
import { DifficultyLevel, Flashcard } from '../../types';
import { useFlashcardStore } from '../../stores/flashcardStore';

interface FlashcardEditorProps {
  packId: string;
  flashcard?: Flashcard;
  onClose: () => void;
}

export function FlashcardEditor({
  packId,
  flashcard,
  onClose,
}: FlashcardEditorProps) {
  const { addFlashcard, updateFlashcard, loading, error } = useFlashcardStore();

  const [question, setQuestion] = useState<string>(flashcard?.question || '');
  const [answer, setAnswer] = useState<string>(flashcard?.answer || '');
  const [difficulty, setDifficulty] = useState<DifficultyLevel>(
    flashcard?.difficulty || DifficultyLevel.MEDIUM
  );

  const handleSave = useCallback(async () => {
    if (!question.trim() || !answer.trim()) {
      return;
    }

    const payload = {
      question,
      answer,
      pack_id: packId,
      difficulty,
    };

    try {
      if (flashcard?.id) {
        await updateFlashcard(flashcard.id, payload);
      } else {
        await addFlashcard(payload);
      }
      onClose();
    } catch (err) {
      console.error('Failed to save flashcard:', err);
    }
  }, [question, answer, difficulty, packId, flashcard, onClose, addFlashcard, updateFlashcard]);

  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      exit={{ opacity: 0, y: 20 }}
      transition={{ duration: 0.2 }}
    >
      <Paper p="xl" radius="md" withBorder>
        <Stack gap="lg">
          <Box>
            <Text fw={500} size="sm" mb="xs">
              Question
            </Text>
            <Textarea
              placeholder="Type the question here..."
              minRows={6}
              autosize
              styles={{
                input: {
                  fontSize: rem(14),
                  lineHeight: 1.5,
                },
              }}
              value={question}
              onChange={(e) => setQuestion(e.currentTarget.value)}
            />
          </Box>

          <Box>
            <Text fw={500} size="sm" mb="xs">
              Answer
            </Text>
            <Textarea
              placeholder="Type the answer here..."
              minRows={6}
              autosize
              styles={{
                input: {
                  fontSize: rem(14),
                  lineHeight: 1.5,
                },
              }}
              value={answer}
              onChange={(e) => setAnswer(e.currentTarget.value)}
            />
          </Box>

          <Select
            label="Difficulty"
            value={difficulty}
            onChange={(val) => {
              if (val) {
                setDifficulty(val as DifficultyLevel);
              }
            }}
            data={[
              { value: DifficultyLevel.EASY, label: 'Easy' },
              { value: DifficultyLevel.MEDIUM, label: 'Medium' },
              { value: DifficultyLevel.HARD, label: 'Hard' },
            ]}
          />

          {error && (
            <Text color="red" size="sm">
              {error}
            </Text>
          )}

          <Group justify="flex-end" gap="sm">
            <Button
              variant="light"
              color="gray"
              onClick={onClose}
              leftSection={<IconX size={16} />}
            >
              Cancel
            </Button>
            <Button
              onClick={handleSave}
              loading={loading}
              leftSection={<IconDeviceFloppy size={16} />}
            >
              Save Flashcard
            </Button>
          </Group>
        </Stack>
      </Paper>
    </motion.div>
  );
}



================================================================================
File: frontend\src\components\flashcards\FlashcardForm.tsx
================================================================================

import React, { useCallback, useMemo } from 'react';
import { Modal } from '@mantine/core';
import { FlashcardEditor } from './FlashcardEditor';
import { Flashcard } from '../../types';

interface FlashcardFormProps {
  packId: string;
  flashcard?: Flashcard;
  opened: boolean;
  onClose: () => void;
}

export const FlashcardForm = React.memo(function FlashcardForm({ 
  packId, 
  flashcard, 
  opened, 
  onClose 
}: FlashcardFormProps) {
  const handleClose = useCallback(() => {
    onClose();
  }, [onClose]);

  const modalTitle = useMemo(() => 
    flashcard ? 'Edit Flashcard' : 'Create New Flashcard',
    [flashcard]
  );
  return (
    <Modal
      opened={opened}
      onClose={handleClose}
      title={modalTitle}
      size="xl"
    >
      <FlashcardEditor
        packId={packId}
        flashcard={flashcard}
        onClose={handleClose}
      />
    </Modal>
  );
});



================================================================================
File: frontend\src\components\flashcards\FlashcardGrid.tsx
================================================================================

import React, { useCallback, useMemo, useState } from 'react';
import {
  Grid,
  Card,
  Text,
  Group,
  ActionIcon,
  Progress,
  Tooltip,
  Stack,
  Box,
  Badge,
  rem,
} from '@mantine/core';
import { IconChartBar, IconEdit, IconRefresh } from '@tabler/icons-react';
import { motion, AnimatePresence } from 'framer-motion';
import { Flashcard, DifficultyLevel } from '../../types';

const DIFFICULTY_COLORS = {
  [DifficultyLevel.EASY]: 'green',
  [DifficultyLevel.MEDIUM]: 'yellow',
  [DifficultyLevel.HARD]: 'red',
};

interface FlashcardGridProps {
  flashcards: Flashcard[];
  onEdit: (flashcard: Flashcard) => void;
}

export const FlashcardGrid = React.memo(function FlashcardGrid({
  flashcards,
  onEdit,
}: FlashcardGridProps) {
  const [flippedCards, setFlippedCards] = useState<{ [id: string]: boolean }>({});

  const handleFlip = useCallback((id: string) => {
    setFlippedCards((prev) => ({
      ...prev,
      [id]: !prev[id],
    }));
  }, []);

  const handleEdit = useCallback(
    (card: Flashcard) => {
      onEdit(card);
    },
    [onEdit]
  );

  const cardVariants = {
    hidden: { opacity: 0 },
    visible: { opacity: 1 },
  };

  const renderFlashcard = (card: Flashcard) => {
    const { id, question, answer, difficulty, success_rate, times_used } = card;
    const isFlipped = flippedCards[id] === true;

    const successRatePercentage = (success_rate * 100).toFixed(1);
    const progressColor =
      success_rate > 0.7 ? 'green' : success_rate > 0.4 ? 'yellow' : 'red';

    return (
      <Grid.Col key={id} span={{ base: 12, sm: 6, md: 4 }}>
        <Box
          style={{
            perspective: '1000px',
            width: '100%',
            height: '400px',
            position: 'relative',
          }}
        >
          <motion.div
            style={{
              width: '100%',
              height: '100%',
              position: 'absolute',
              transformStyle: 'preserve-3d',
              transition: 'transform 0.8s ease',
              transform: isFlipped ? 'rotateY(180deg)' : 'rotateY(0deg)',
            }}
          >
            <motion.div
              key={`${id}-front`}
              variants={cardVariants}
              initial="hidden"
              animate="visible"
              exit="hidden"
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                borderRadius: rem(8),
                overflow: 'hidden',
              }}
            >
              <Card
                shadow="sm"
                padding="lg"
                radius="md"
                withBorder
                style={{ height: '100%', boxSizing: 'border-box' }}
              >
                <Stack gap="md" style={{ height: '100%' }}>
                  <Group justify="space-between">
                    <Badge color={DIFFICULTY_COLORS[difficulty]}>
                      {difficulty}
                    </Badge>
                    <ActionIcon variant="light" onClick={() => handleEdit(card)}>
                      <IconEdit size={16} />
                    </ActionIcon>
                  </Group>

                  <Stack justify="center" style={{ flex: 1 }}>
                    <Text size="lg" fw={700} ta="center" lineClamp={3}>
                      {question}
                    </Text>
                  </Stack>

                  <Tooltip label="Success Rate" position="bottom">
                    <Group gap="xs">
                      <IconChartBar size={16} />
                      <Text size="sm">{successRatePercentage}%</Text>
                      <Progress
                        value={Number(successRatePercentage)}
                        color={progressColor}
                        size="sm"
                        style={{ flex: 1 }}
                      />
                    </Group>
                  </Tooltip>
                  <Text size="xs" color="dimmed">
                    Used {times_used} times
                  </Text>

                  <ActionIcon
                    variant="default"
                    onClick={() => handleFlip(id)}
                    style={{ marginTop: 'auto' }}
                  >
                    <IconRefresh size={16} />
                  </ActionIcon>
                </Stack>
              </Card>
            </motion.div>

            <motion.div
              key={`${id}-back`}
              variants={cardVariants}
              initial="hidden"
              animate="visible"
              exit="hidden"
              style={{
                width: '100%',
                height: '100%',
                position: 'absolute',
                backfaceVisibility: 'hidden',
                transform: 'rotateY(180deg)',
                borderRadius: rem(8),
                overflow: 'hidden',
              }}
            >
              <Card
                shadow="sm"
                padding="lg"
                radius="md"
                withBorder
                style={{
                  height: '100%',
                  boxSizing: 'border-box',
                  backgroundColor: '#fffbee',
                }}
              >
                <Stack gap="md" style={{ height: '100%' }}>
                  <Group justify="space-between">
                    <Badge color={DIFFICULTY_COLORS[difficulty]}>
                      {difficulty}
                    </Badge>
                    <ActionIcon variant="light" onClick={() => handleEdit(card)}>
                      <IconEdit size={16} />
                    </ActionIcon>
                  </Group>

                  <Stack justify="center" style={{ flex: 1 }}>
                    <Text size="lg" fw={700} ta="center" lineClamp={6}>
                      {answer}
                    </Text>
                  </Stack>

                  <ActionIcon
                    variant="default"
                    onClick={() => handleFlip(id)}
                    style={{ marginTop: 'auto' }}
                  >
                    <IconRefresh size={16} />
                  </ActionIcon>
                </Stack>
              </Card>
            </motion.div>
          </motion.div>
        </Box>
      </Grid.Col>
    );
  };

  const renderedCards = useMemo(
    () => flashcards.map(renderFlashcard),
    [flashcards, flippedCards, renderFlashcard]
  );

  return <Grid>{renderedCards}</Grid>;
});



================================================================================
File: frontend\src\components\flashcards\FlashcardList.tsx
================================================================================

import React, { useState, useEffect } from 'react';
import { Stack, Text, Box, TextInput, SegmentedControl, Button, Select, Flex } from '@mantine/core';
import { LoadingOverlay } from '../shared/LoadingOverlay';
import { ErrorBoundary } from '../shared/ErrorBoundary';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { Flashcard, DifficultyLevel } from '../../types';
import { FlashcardForm } from './FlashcardForm';
import { FlashcardGrid } from './FlashcardGrid';
import { FlashcardTable } from './FlashcardTable';
import { useFlashcardFilters, ViewMode } from '../../hooks/useFlashcardFilters';

export function FlashcardList() {
  const { flashcards, loading, error, fetchFlashcards } = useFlashcardStore();
  const { packs, fetchPacks } = usePackStore();
  const [viewMode, setViewMode] = useState<ViewMode>('grid');
  const [selectedFlashcard, setSelectedFlashcard] = useState<Flashcard | undefined>();
  const [isEditModalOpen, setIsEditModalOpen] = useState(false);
  const [selectedPackId, setSelectedPackId] = useState<string>('');

  const {
    searchQuery,
    setSearchQuery,
    difficultyFilter,
    setDifficultyFilter,
    sort,
    handleSortChange,
    filteredAndSortedFlashcards,
  } = useFlashcardFilters(flashcards);

  useEffect(() => {
    Promise.all([fetchFlashcards(), fetchPacks()]);
  }, [fetchFlashcards, fetchPacks]);

  useEffect(() => {
    // Set initial pack selection when packs are loaded
    if (packs.length > 0 && !selectedPackId) {
      setSelectedPackId(packs[0].id);
    }
  }, [packs, selectedPackId]);

  // Memoize handlers to prevent recreation on every render
  const handleEdit = React.useCallback((flashcard: Flashcard) => {
    setSelectedFlashcard(flashcard);
    setIsEditModalOpen(true);
  }, []);

  const handleCreate = React.useCallback(() => {
    setSelectedFlashcard(undefined);
    setIsEditModalOpen(true);
  }, []);

  // Memoize view mode change handler
  const handleViewModeChange = React.useCallback((value: string) => {
    setViewMode(value as ViewMode);
  }, []);

  // Memoize pack selection handler
  const handlePackSelect = React.useCallback((value: string | null) => {
    if (value) setSelectedPackId(value);
  }, []);

  // Memoize modal close handler
  const handleModalClose = React.useCallback(() => {
    setIsEditModalOpen(false);
    setSelectedFlashcard(undefined);
  }, []);

  // Memoize difficulty filter handler
  const handleDifficultyChange = React.useCallback((value: string | null) => {
    if (value) setDifficultyFilter(value as DifficultyLevel | 'all');
  }, [setDifficultyFilter]);

  return (
    <ErrorBoundary>
      <Stack gap="lg">
        {error && (
          <Text c="red" ta="center" size="lg">
            Error loading flashcards: {error}
          </Text>
        )}

        <Flex gap="md" align="center">
          <Select
            label="Flashcard Pack"
            placeholder="Select a pack"
            value={selectedPackId}
            onChange={handlePackSelect}
            data={packs.map(pack => ({
              value: pack.id,
              label: pack.name
            }))}
            style={{ minWidth: 200 }}
          />
          <TextInput
            placeholder="Search flashcards..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)} // Keep inline since it's a simple event handler
            style={{ flex: 1 }}
          />
          <Select
            value={difficultyFilter}
            onChange={handleDifficultyChange}
            data={[
              { value: 'all', label: 'All Difficulties' },
              { value: DifficultyLevel.EASY, label: 'Easy' },
              { value: DifficultyLevel.MEDIUM, label: 'Medium' },
              { value: DifficultyLevel.HARD, label: 'Hard' }
            ]}
          />
          <SegmentedControl
            value={viewMode}
            onChange={handleViewModeChange}
            data={[
              { label: 'Grid', value: 'grid' },
              { label: 'List', value: 'list' }
            ]}
          />
          <Button onClick={handleCreate}>Create Flashcard</Button>
        </Flex>

        <Box pos="relative" mih={400}>
          <LoadingOverlay visible={loading} />
          {viewMode === 'grid' ? (
            <FlashcardGrid
              flashcards={filteredAndSortedFlashcards}
              onEdit={handleEdit}
            />
          ) : (
            <FlashcardTable
              flashcards={filteredAndSortedFlashcards}
              onEdit={handleEdit}
              sort={sort}
              onSortChange={handleSortChange}
            />
          )}
        </Box>

        <FlashcardForm
          flashcard={selectedFlashcard}
          packId={selectedPackId}
          opened={isEditModalOpen}
          onClose={handleModalClose}
        />
      </Stack>
    </ErrorBoundary>
  );
}



================================================================================
File: frontend\src\components\flashcards\FlashcardPacks.tsx
================================================================================

import React, { useEffect, useState, useCallback, useMemo } from 'react';
import { 
  Grid, 
  Card, 
  Text, 
  Button, 
  Group,
  Badge,
  ActionIcon,
  Tooltip
} from '@mantine/core';
import { motion } from 'framer-motion';
import { IconPlus, IconEdit, IconTrash, IconCards, IconSquarePlus } from '@tabler/icons-react';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { FlashcardPack, Flashcard } from '../../types';
import { FlashcardForm } from './FlashcardForm';
import { DeleteConfirmationModal, PackFormModal } from './modals/FlashcardModals';

export function FlashcardPacks() {
  const { flashcards, fetchFlashcards } = useFlashcardStore();
  const { packs, loading, error, fetchPacks, addPack, updatePack, deletePack } = usePackStore();
  const [packFormOpen, setPackFormOpen] = useState(false);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [flashcardModalOpen, setFlashcardModalOpen] = useState(false);
  const [selectedPack, setSelectedPack] = useState<FlashcardPack | null>(null);
  const [selectedFlashcard, setSelectedFlashcard] = useState<Flashcard | null>(null);

  useEffect(() => {
    fetchPacks();
    fetchFlashcards();
  }, [fetchPacks, fetchFlashcards]);

  // Memoize handlers
  const handlePackSubmit = useCallback(async (name: string) => {
    if (selectedPack) {
      await updatePack(selectedPack.id, { name });
    } else {
      await addPack({ name });
    }
    setPackFormOpen(false);
    setSelectedPack(null);
  }, [selectedPack, updatePack, addPack]);

  const handleDeletePack = useCallback(async () => {
    if (!selectedPack) return;
    await deletePack(selectedPack.id);
    setDeleteModalOpen(false);
    setSelectedPack(null);
  }, [selectedPack, deletePack]);

  const openEditModal = useCallback((pack: FlashcardPack) => {
    setSelectedPack(pack);
    setPackFormOpen(true);
  }, []);

  const openCreateModal = useCallback(() => {
    setSelectedPack(null);
    setPackFormOpen(true);
  }, []);

  const openDeleteModal = useCallback((pack: FlashcardPack) => {
    setSelectedPack(pack);
    setDeleteModalOpen(true);
  }, []);

  const openFlashcardModal = useCallback((pack: FlashcardPack, flashcard?: Flashcard) => {
    setSelectedPack(pack);
    setSelectedFlashcard(flashcard || null);
    setFlashcardModalOpen(true);
  }, []);

  const closePackForm = useCallback(() => {
    setPackFormOpen(false);
    setSelectedPack(null);
  }, []);

  const closeDeleteModal = useCallback(() => {
    setDeleteModalOpen(false);
    setSelectedPack(null);
  }, []);

  const closeFlashcardModal = useCallback(() => {
    setFlashcardModalOpen(false);
    setSelectedPack(null);
    setSelectedFlashcard(null);
  }, []);

  // Memoize helper functions
  const getPackFlashcardCount = useCallback((packId: string) => {
    return flashcards.filter(f => f.pack_id === packId).length;
  }, [flashcards]);

  // Memoize pack data transformations
  const packData = useMemo(() => packs.map((pack: FlashcardPack) => ({
    ...pack,
    flashcardCount: getPackFlashcardCount(pack.id),
    createdDate: new Date(pack.created_at).toLocaleDateString()
  })), [packs, getPackFlashcardCount]);

  return (
    <>
      <Group justify="space-between" mb="xl">
        <Text size="xl" fw={700}>Flashcard Packs</Text>
        <Button
          leftSection={<IconPlus size={20} />}
          onClick={openCreateModal}
          variant="filled"
        >
          Create Pack
        </Button>
      </Group>

      {error && (
        <Text c="red" ta="center" size="lg" mb="xl">
          Error loading flashcard packs: {error}
        </Text>
      )}

      <Grid>
        {packData.map((pack) => (
          <Grid.Col key={pack.id} span={{ base: 12, sm: 6, md: 4 }}>
            <motion.div
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              whileHover={{ scale: 1.02 }}
              transition={{ duration: 0.2 }}
              style={{ height: '100%' }}
            >
              <Card shadow="sm" h="100%">
                <Group justify="space-between" mb="xs">
                  <Text fw={600} size="lg">{pack.name}</Text>
                  <Badge variant="light" color="blue">
                    <Group gap="xs">
                      <IconCards size={14} />
                      <Text size="xs">{pack.flashcardCount} cards</Text>
                    </Group>
                  </Badge>
                </Group>

                <Text size="sm" c="dimmed" mb="md" lineClamp={2}>
                  {pack.description || 'No description provided'}
                </Text>

                <Group mt="auto" justify="space-between">
                  <Text size="xs" c="dimmed">
                    Created: {pack.createdDate}
                  </Text>
                  <Group gap="xs">
                    <Tooltip label="Add Flashcard">
                      <ActionIcon 
                        variant="light" 
                        color="green"
                        onClick={() => openFlashcardModal(pack)}
                      >
                        <IconSquarePlus size={18} />
                      </ActionIcon>
                    </Tooltip>
                    <Tooltip label="Edit Pack">
                      <ActionIcon 
                        variant="light" 
                        color="blue"
                        onClick={() => openEditModal(pack)}
                      >
                        <IconEdit size={18} />
                      </ActionIcon>
                    </Tooltip>
                    <Tooltip label="Delete Pack">
                      <ActionIcon 
                        variant="light" 
                        color="red"
                        onClick={() => openDeleteModal(pack)}
                      >
                        <IconTrash size={18} />
                      </ActionIcon>
                    </Tooltip>
                  </Group>
                </Group>
              </Card>
            </motion.div>
          </Grid.Col>
        ))}
      </Grid>

      {/* Modals */}
      <PackFormModal
        opened={packFormOpen}
        onClose={closePackForm}
        onSubmit={handlePackSubmit}
        initialName={selectedPack?.name}
        loading={loading}
        mode={selectedPack ? 'edit' : 'create'}
      />

      <DeleteConfirmationModal
        opened={deleteModalOpen}
        onClose={closeDeleteModal}
        onConfirm={handleDeletePack}
        itemType="pack"
        itemName={selectedPack?.name}
        loading={loading}
      />

      {selectedPack && (
        <FlashcardForm
          packId={selectedPack.id}
          flashcard={selectedFlashcard || undefined}
          opened={flashcardModalOpen}
          onClose={closeFlashcardModal}
        />
      )}
    </>
  );
}



================================================================================
File: frontend\src\components\flashcards\FlashcardTable.tsx
================================================================================

import React, { useCallback, useMemo } from 'react';
import {
  Table,
  Badge,
  Text,
  ActionIcon,
  Progress,
  Group,
} from '@mantine/core';
import { IconEdit, IconArrowUp, IconArrowDown } from '@tabler/icons-react';
import { Flashcard, DifficultyLevel } from '../../types';
import { SortField, SortConfig } from '../../hooks/useFlashcardFilters';

// Memoize constant objects
const DIFFICULTY_COLORS = {
  [DifficultyLevel.EASY]: 'green',
  [DifficultyLevel.MEDIUM]: 'yellow',
  [DifficultyLevel.HARD]: 'red',
} as const;

interface FlashcardTableProps {
  flashcards: Flashcard[];
  onEdit: (flashcard: Flashcard) => void;
  sort: SortConfig;
  onSortChange: (field: SortField) => void;
}

export function FlashcardTable({ 
  flashcards, 
  onEdit, 
  sort, 
  onSortChange 
}: FlashcardTableProps) {
  // Memoize handlers
  const handleEdit = useCallback((card: Flashcard) => {
    onEdit(card);
  }, [onEdit]);

  const handleSortChange = useCallback((field: SortField) => {
    onSortChange(field);
  }, [onSortChange]);

  // Memoize sort icon renderer
  const renderSortIcon = useCallback((field: SortField) => {
    if (sort.field !== field) {
      return null;
    }
    const Icon = sort.order === 'asc' ? IconArrowUp : IconArrowDown;
    return <Icon size={14} />;
  }, [sort.field, sort.order]);

  // Memoize column headers with sort functionality
  const columnHeaders = useMemo(() => ({
    difficulty: (
      <Group gap={4} onClick={() => handleSortChange('difficulty')} style={{ cursor: 'pointer' }}>
        Difficulty {renderSortIcon('difficulty')}
      </Group>
    ),
    successRate: (
      <Group gap={4} onClick={() => handleSortChange('success_rate')} style={{ cursor: 'pointer' }}>
        Success Rate {renderSortIcon('success_rate')}
      </Group>
    )
  }), [handleSortChange, renderSortIcon]);

  // Memoize row rendering function
  const renderRow = useCallback((card: Flashcard) => {
    const successRatePercentage = (card.success_rate * 100).toFixed(1);
    const successRateColor = card.success_rate > 0.7 ? 'green' : card.success_rate > 0.4 ? 'yellow' : 'red';

    return (
      <Table.Tr key={card.id}>
        <Table.Td>
          <Badge color={DIFFICULTY_COLORS[card.difficulty]}>
            {card.difficulty}
          </Badge>
        </Table.Td>
        <Table.Td>
          <Text lineClamp={2}>{card.question}</Text>
        </Table.Td>
        <Table.Td>
          <Text lineClamp={2}>{card.answer}</Text>
        </Table.Td>
        <Table.Td>
          <Group gap="xs">
            <Text size="sm">{successRatePercentage}%</Text>
            <Progress
              value={card.success_rate * 100}
              color={successRateColor}
              size="sm"
              w={60}
            />
          </Group>
        </Table.Td>
        <Table.Td>
          <ActionIcon
            variant="light"
            onClick={() => handleEdit(card)}
          >
            <IconEdit size={16} />
          </ActionIcon>
        </Table.Td>
      </Table.Tr>
    );
  }, [handleEdit]);

  // Memoize rows
  const tableRows = useMemo(() => 
    flashcards.map(card => renderRow(card)),
    [flashcards, renderRow]
  );

  return (
    <Table striped highlightOnHover>
      <Table.Thead>
        <Table.Tr>
          <Table.Th>{columnHeaders.difficulty}</Table.Th>
          <Table.Th>Question</Table.Th>
          <Table.Th>Answer</Table.Th>
          <Table.Th>{columnHeaders.successRate}</Table.Th>
          <Table.Th>Actions</Table.Th>
        </Table.Tr>
      </Table.Thead>
      <Table.Tbody>
        {tableRows}
      </Table.Tbody>
    </Table>
  );
}



================================================================================
File: frontend\src\components\flashcards\modals\FlashcardModals.tsx
================================================================================

import React, { useState, useCallback } from 'react';
import {
  Modal,
  Text,
  Stack,
  Group,
  Button,
  Box,
  Progress,
  Divider,
  RangeSlider,
  Kbd,
  FileInput,
  Alert,
  Select,
  TextInput,
} from '@mantine/core';
import { DatePickerInput } from '@mantine/dates';
import { IconChartBar, IconUpload, IconDownload, IconAlertCircle, IconTrash } from '@tabler/icons-react';
import { StatsCard } from '../../shared/StatsCard';
import { Flashcard, FlashcardPack, BulkImportResult } from '../../../types';
import { AdvancedFilters, INITIAL_FILTERS } from '../../../hooks/useFlashcardFilters';
import { flashcardApi } from '../../../services/api';

interface StatsModalProps {
  opened: boolean;
  onClose: () => void;
  flashcard: Flashcard | null;
}

export function StatsModal({ opened, onClose, flashcard }: StatsModalProps) {
  return (
    <Modal
      opened={opened && !!flashcard}
      onClose={onClose}
      title={<Text fw={700}>Flashcard Statistics</Text>}
      size="lg"
    >
      {flashcard && (
        <Stack gap="md">
          <Group grow>
            <StatsCard
              title="Success Rate"
              value={`${(flashcard.success_rate * 100).toFixed(1)}%`}
              icon={<IconChartBar size={20} />}
            />
            <StatsCard
              title="Times Used"
              value={flashcard.times_used.toString()}
              icon={<IconChartBar size={20} />}
            />
          </Group>
          
          <Divider />
          
          <Box>
            <Text fw={500} mb="xs">Performance Trend</Text>
            <Box>
              <Progress
                value={(flashcard.times_correct / flashcard.times_used) * 100}
                color="green"
                size="xl"
              />
              <Group mt="xs" justify="space-between">
                <Text size="sm" c="green">Correct: {flashcard.times_correct}</Text>
                <Text size="sm" c="red">
                  Incorrect: {flashcard.times_used - flashcard.times_correct}
                </Text>
              </Group>
            </Box>
          </Box>

          <Group>
            <Text size="sm">Created: {new Date(flashcard.created_at).toLocaleDateString()}</Text>
            <Text size="sm">Last Updated: {new Date(flashcard.updated_at).toLocaleDateString()}</Text>
          </Group>
        </Stack>
      )}
    </Modal>
  );
}

interface AdvancedFiltersModalProps {
  opened: boolean;
  onClose: () => void;
  filters: AdvancedFilters;
  onFiltersChange: (filters: AdvancedFilters) => void;
}

export function AdvancedFiltersModal({
  opened,
  onClose,
  filters,
  onFiltersChange,
}: AdvancedFiltersModalProps) {
  // Memoize handlers
  const handleDateRangeChange = useCallback((value: [Date | null, Date | null]) => {
    onFiltersChange({ ...filters, dateRange: value });
  }, [filters, onFiltersChange]);

  const handleSuccessRateChange = useCallback((value: [number, number]) => {
    onFiltersChange({ ...filters, successRateRange: value });
  }, [filters, onFiltersChange]);

  const handleUsageRangeChange = useCallback((value: [number, number]) => {
    onFiltersChange({ ...filters, usageRange: value });
  }, [filters, onFiltersChange]);

  const handleReset = useCallback(() => {
    onFiltersChange(INITIAL_FILTERS);
  }, [onFiltersChange]);

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Advanced Filters</Text>}
      size="lg"
    >
      <Stack gap="md">
        <Box>
          <Text fw={500} mb="xs">Date Range</Text>
          <DatePickerInput
            type="range"
            value={filters.dateRange}
            onChange={handleDateRangeChange}
            clearable
          />
        </Box>

        <Box>
          <Text fw={500} mb="xs">Success Rate Range (%)</Text>
          <RangeSlider
            value={filters.successRateRange}
            onChange={handleSuccessRateChange}
            min={0}
            max={100}
            step={5}
            marks={[
              { value: 0, label: '0%' },
              { value: 50, label: '50%' },
              { value: 100, label: '100%' }
            ]}
          />
        </Box>

        <Box>
          <Text fw={500} mb="xs">Usage Count Range</Text>
          <RangeSlider
            value={filters.usageRange}
            onChange={handleUsageRangeChange}
            min={0}
            max={100}
            step={5}
            marks={[
              { value: 0, label: '0' },
              { value: 50, label: '50' },
              { value: 100, label: '100+' }
            ]}
          />
        </Box>

        <Group justify="flex-end">
          <Button variant="light" onClick={handleReset}>
            Reset Filters
          </Button>
          <Button onClick={onClose}>
            Apply Filters
          </Button>
        </Group>
      </Stack>
    </Modal>
  );
}

interface KeyboardShortcutsModalProps {
  opened: boolean;
  onClose: () => void;
}

export function KeyboardShortcutsModal({ opened, onClose }: KeyboardShortcutsModalProps) {
  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Keyboard Shortcuts</Text>}
    >
      <Stack gap="md">
        <Group>
          <Kbd>g</Kbd>
          <Text>Switch to grid view</Text>
        </Group>
        <Group>
          <Kbd>l</Kbd>
          <Text>Switch to list view</Text>
        </Group>
        <Group>
          <Kbd>/</Kbd>
          <Text>Focus search</Text>
        </Group>
        <Group>
          <Kbd>f</Kbd>
          <Text>Open advanced filters</Text>
        </Group>
        <Group>
          <Kbd>?</Kbd>
          <Text>Show this help</Text>
        </Group>
        <Group>
          <Kbd>esc</Kbd>
          <Text>Close any open modal</Text>
        </Group>
      </Stack>
    </Modal>
  );
}

interface BulkOperationsModalProps {
  opened: boolean;
  onClose: () => void;
  packs: FlashcardPack[];
  onImportComplete?: () => void;
}

interface DeleteConfirmationModalProps {
  opened: boolean;
  onClose: () => void;
  onConfirm: () => void;
  itemType: 'flashcard' | 'pack';
  itemName?: string;
  loading?: boolean;
}

export function DeleteConfirmationModal({
  opened,
  onClose,
  onConfirm,
  itemType,
  itemName,
  loading = false,
}: DeleteConfirmationModalProps) {
  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Delete {itemType}</Text>}
      size="sm"
    >
      <Stack gap="md">
        <Text>
          Are you sure you want to delete this {itemType}
          {itemName ? ` "${itemName}"` : ''}? This action cannot be undone.
          {itemType === 'pack' && ' All flashcards in this pack will also be deleted.'}
        </Text>

        <Group justify="flex-end">
          <Button variant="light" onClick={onClose} disabled={loading}>
            Cancel
          </Button>
          <Button 
            color="red" 
            leftSection={<IconTrash size={20} />}
            onClick={onConfirm}
            loading={loading}
          >
            Delete
          </Button>
        </Group>
      </Stack>
    </Modal>
  );
}

interface PackFormModalProps {
  opened: boolean;
  onClose: () => void;
  onSubmit: (name: string) => void;
  initialName?: string;
  loading?: boolean;
  mode: 'create' | 'edit';
}

export function PackFormModal({
  opened,
  onClose,
  onSubmit,
  initialName = '',
  loading = false,
  mode,
}: PackFormModalProps) {
  const [name, setName] = useState(initialName);

  // Memoize handlers
  const handleSubmit = useCallback((e: React.FormEvent) => {
    e.preventDefault();
    if (name.trim()) {
      onSubmit(name.trim());
    }
  }, [name, onSubmit]);

  const handleNameChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setName(e.target.value);
  }, []);

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>{mode === 'create' ? 'Create New Pack' : 'Edit Pack'}</Text>}
      size="sm"
    >
      <form onSubmit={handleSubmit}>
        <Stack gap="md">
          <TextInput
            label="Pack Name"
            value={name}
            onChange={handleNameChange}
            placeholder="Enter pack name"
            required
            data-autofocus
          />

          <Group justify="flex-end">
            <Button variant="light" onClick={onClose} disabled={loading}>
              Cancel
            </Button>
            <Button type="submit" loading={loading}>
              {mode === 'create' ? 'Create Pack' : 'Save Changes'}
            </Button>
          </Group>
        </Stack>
      </form>
    </Modal>
  );
}

export function BulkOperationsModal({
  opened,
  onClose,
  packs,
  onImportComplete,
}: BulkOperationsModalProps) {
  const [selectedPack, setSelectedPack] = useState<string | null>(null);
  const [file, setFile] = useState<File | null>(null);
  const [importing, setImporting] = useState(false);
  const [importResult, setImportResult] = useState<(BulkImportResult & { success: boolean }) | null>(null);

  // Memoize handlers
  const handleDownloadTemplate = useCallback(async () => {
    try {
      const response = await flashcardApi.getImportTemplate();
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', 'flashcard_template.csv');
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      console.error('Failed to download template:', error);
    }
  }, []);

  const handleExport = useCallback(async () => {
    if (!selectedPack) return;

    try {
      const response = await flashcardApi.exportPack(selectedPack);
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `flashcards_pack_${selectedPack}.csv`);
      document.body.appendChild(link);
      link.click();
      link.remove();
    } catch (error) {
      console.error('Failed to export flashcards:', error);
    }
  }, [selectedPack]);

  const handleImport = useCallback(async () => {
    if (!file) return;

    setImporting(true);
    setImportResult(null);

    try {
      const response = await flashcardApi.bulkImport(file);
      const importResult: BulkImportResult & { success: boolean } = {
        ...response.data.data,
        success: response.data.data.successful > 0
      };
      setImportResult(importResult);
      if (onImportComplete) {
        onImportComplete();
      }
    } catch (error) {
      console.error('Failed to import flashcards:', error);
      setImportResult({
        success: false,
        total: 0,
        successful: 0,
        failed: 0,
        errors: ['Failed to import flashcards. Please try again.'],
      });
    } finally {
      setImporting(false);
    }
  }, [file, onImportComplete]);

  const handlePackSelect = useCallback((value: string | null) => {
    setSelectedPack(value);
  }, []);

  const handleFileChange = useCallback((file: File | null) => {
    setFile(file);
  }, []);

  return (
    <Modal
      opened={opened}
      onClose={onClose}
      title={<Text fw={700}>Bulk Operations</Text>}
      size="lg"
    >
      <Stack gap="md">
        <Box>
          <Text fw={500} mb="xs">Import Flashcards</Text>
          <Stack gap="sm">
            <Button
              leftSection={<IconDownload size={20} />}
              variant="light"
              onClick={handleDownloadTemplate}
            >
              Download Import Template
            </Button>
            <FileInput
              label="Upload CSV File"
              placeholder="Choose file"
              accept=".csv"
              value={file}
              onChange={handleFileChange}
              leftSection={<IconUpload size={20} />}
            />
            <Button
              onClick={handleImport}
              loading={importing}
              disabled={!file}
            >
              Import Flashcards
            </Button>
          </Stack>
        </Box>

        {importResult && (
          <Alert
            color={importResult.success ? 'green' : 'red'}
            title={importResult.success ? 'Import Successful' : 'Import Failed'}
            icon={<IconAlertCircle />}
          >
            <Text>Total processed: {importResult.total}</Text>
            <Text>Successfully imported: {importResult.successful}</Text>
            <Text>Failed: {importResult.failed}</Text>
            {importResult.errors.length > 0 && (
              <Box mt="xs">
                <Text fw={500}>Errors:</Text>
                <Stack gap="xs">
                  {importResult.errors.map((error, index) => (
                    <Text key={index} size="sm" c="red">
                      {error}
                    </Text>
                  ))}
                </Stack>
              </Box>
            )}
          </Alert>
        )}

        <Divider />

        <Box>
          <Text fw={500} mb="xs">Export Flashcards</Text>
          <Stack gap="sm">
            <Select
              label="Select Pack to Export"
              placeholder="Choose a pack"
              data={packs.map(pack => ({
                value: pack.id,
                label: pack.name,
              }))}
              value={selectedPack}
              onChange={handlePackSelect}
            />
            <Button
              leftSection={<IconDownload size={20} />}
              onClick={handleExport}
              disabled={!selectedPack}
            >
              Export Pack
            </Button>
          </Stack>
        </Box>
      </Stack>
    </Modal>
  );
}



================================================================================
File: frontend\src\components\shared\ErrorAlert.tsx
================================================================================

import React from 'react';
import { Stack, Alert, Text, Button } from '@mantine/core';
import { IconAlertCircle, IconRefresh } from '@tabler/icons-react';

interface ErrorAlertProps { 
  error: string; 
  onRetry?: () => void;
  withRetry?: boolean;
}

export const ErrorAlert: React.FC<ErrorAlertProps> = ({ 
  error, 
  onRetry, 
  withRetry = true 
}) => (
  <Alert 
    icon={<IconAlertCircle size={16} />} 
    title="Error" 
    color="red"
    variant="filled"
  >
    <Stack gap="sm">
      <Text>{error}</Text>
      {withRetry && onRetry && (
        <Button 
          variant="white" 
          color="red" 
          size="xs" 
          leftSection={<IconRefresh size={14} />}
          onClick={onRetry}
        >
          Retry
        </Button>
      )}
    </Stack>
  </Alert>
);



================================================================================
File: frontend\src\components\shared\ErrorBoundary.tsx
================================================================================

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { Container, Title, Text, Button, Stack, Paper } from '@mantine/core';
import { IconAlertTriangle } from '@tabler/icons-react';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
}

export class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
    errorInfo: null
  };

  public static getDerivedStateFromError(error: Error): State {
    return {
      hasError: true,
      error,
      errorInfo: null
    };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
    this.setState({
      error,
      errorInfo
    });
  }

  private handleReset = () => {
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null
    });
  };

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <Container size="sm" py="xl">
          <Paper p="xl" radius="md" withBorder>
            <Stack align="center" gap="md">
              <IconAlertTriangle size={48} stroke={1.5} color="red" />
              <Title order={2} ta="center" c="red.7">Something went wrong</Title>
              <Text c="dimmed" size="sm" ta="center" maw={400} mx="auto">
                {this.state.error?.message || 'An unexpected error occurred'}
              </Text>
              {process.env.NODE_ENV === 'development' && this.state.errorInfo && (
                <Paper withBorder p="xs" bg="gray.0" style={{ maxHeight: '200px', overflow: 'auto', width: '100%' }}>
                  <pre style={{ margin: 0, fontSize: '12px' }}>
                    <code>
                      {this.state.errorInfo.componentStack}
                    </code>
                  </pre>
                </Paper>
              )}
              <Button onClick={this.handleReset} variant="light" color="red" leftSection={<IconAlertTriangle size={16} />}>
                Try Again
              </Button>
            </Stack>
          </Paper>
        </Container>
      );
    }

    return this.props.children;
  }
}



================================================================================
File: frontend\src\components\shared\Layout.tsx
================================================================================

import React from 'react';
import { Container, Paper } from '@mantine/core';
import { Navigation } from './Navigation';

interface LayoutProps {
  children: React.ReactNode;
}

export function Layout({ children }: LayoutProps) {
  return (
    <Navigation>
      <Container size="xl" py="xl">
        <Paper shadow="xs" p="md" radius="md">
          {children}
        </Paper>
      </Container>
    </Navigation>
  );
}



================================================================================
File: frontend\src\components\shared\LoadingOverlay.tsx
================================================================================

import React from 'react';
import { Center, Loader, Text, Stack, Box, MantineSize } from '@mantine/core';
import { motion, AnimatePresence } from 'framer-motion';

interface LoadingOverlayProps {
  visible: boolean;
  message?: string;
  size?: MantineSize;
  overlay?: boolean;
  loaderSize?: number;
  blur?: boolean;
}

export function LoadingOverlay({
  visible,
  message = 'Loading...',
  size = 'md',
  overlay = false,
  loaderSize = 36,
  blur = true
}: LoadingOverlayProps) {
  const MotionStack = motion(Stack) as any; // Type assertion needed for framer-motion

  return (
    <AnimatePresence>
      {visible && (
        <Box
          pos={overlay ? 'absolute' : 'relative'}
          top={0}
          left={0}
          right={0}
          bottom={0}
          style={{
            backgroundColor: overlay ? 'rgba(255, 255, 255, 0.8)' : 'transparent',
            backdropFilter: overlay && blur ? 'blur(2px)' : 'none',
            zIndex: 1000,
            minHeight: overlay ? '100%' : '200px',
          }}
        >
          <Center h="100%">
            <MotionStack
              align="center"
              gap="sm"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -20 }}
              transition={{ duration: 0.2 }}
            >
              <Loader size={loaderSize} />
              {message && (
                <Text size={size} c="dimmed" ta="center">
                  {message}
                </Text>
              )}
            </MotionStack>
          </Center>
        </Box>
      )}
    </AnimatePresence>
  );
}



================================================================================
File: frontend\src\components\shared\Navigation.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { 
  AppShell,
  Text,
  Burger,
  Group,
  UnstyledButton,
  ThemeIcon,
  Box
} from '@mantine/core';
import { Link, useLocation } from 'react-router-dom';

interface NavItemProps {
  icon: JSX.Element;
  label: string;
  path: string;
  active: boolean;
  onClick?: () => void;
}

const NavItem = ({ icon, label, path, active, onClick }: NavItemProps) => (
  <UnstyledButton
    component={Link}
    to={path}
    onClick={onClick}
    style={{
      display: 'block',
      width: '100%',
      padding: '8px',
      borderRadius: '4px',
      backgroundColor: active ? 'var(--mantine-color-blue-light)' : 'transparent',
      '&:hover': {
        backgroundColor: active 
          ? 'var(--mantine-color-blue-light)' 
          : 'var(--mantine-color-gray-0)',
      },
    }}
  >
    <Group>
      <ThemeIcon 
        variant={active ? "filled" : "light"} 
        size={30}
        color={active ? "blue" : "gray"}
      >
        {icon}
      </ThemeIcon>
      <Text 
        size="sm" 
        c={active ? "blue" : "dark"}
        fw={active ? 600 : 400}
      >
        {label}
      </Text>
    </Group>
  </UnstyledButton>
);

export function Navigation({ children }: { children: React.ReactNode }) {
  const [opened, setOpened] = useState(false);
  const location = useLocation();

  const toggleOpened = useCallback(() => {
    setOpened(o => !o);
  }, []);

  const handleNavItemClick = useCallback(() => {
    setOpened(false);
  }, []);

  const navItems = useMemo(() => [
    { label: 'Students', icon: '', path: '/students' },
    { label: 'Flashcards', icon: '', path: '/flashcards' },
    { label: 'Battle Arena', icon: '', path: '/arena' },
  ], []);

  return (
    <AppShell
      header={{ height: { base: 50, md: 70 } }}
      navbar={{
        width: { sm: 200, lg: 300 },
        breakpoint: 'sm',
        collapsed: { mobile: !opened }
      }}
      padding="md"
    >
      <AppShell.Header p="md">
        <Group h="100%" px="md">
          <Burger
            opened={opened}
            onClick={toggleOpened}
            hiddenFrom="sm"
            size="sm"
          />
          <Text 
            component={Link} 
            to="/" 
            size="lg" 
            fw={700}
            style={{ 
              textDecoration: 'none', 
              color: 'inherit' 
            }}
          >
            Flashcard Battle Arena
          </Text>
        </Group>
      </AppShell.Header>

      <AppShell.Navbar p="md">
        <Box>
          {navItems.map((item) => (
            <NavItem
              key={item.label}
              icon={<Text>{item.icon}</Text>}
              label={item.label}
              path={item.path}
              active={location.pathname === item.path}
              onClick={handleNavItemClick}
            />
          ))}
        </Box>
      </AppShell.Navbar>

      <AppShell.Main>
        {children}
      </AppShell.Main>
    </AppShell>
  );
}



================================================================================
File: frontend\src\components\shared\StatsCard.tsx
================================================================================

import React, { ReactNode } from 'react';
import { Paper, Text, Group, ThemeIcon } from '@mantine/core';

interface StatsCardProps {
  title: string;
  value: string | number;
  icon: ReactNode;
  description?: string;
}

export function StatsCard({ title, value, icon, description }: StatsCardProps) {
  return (
    <Paper withBorder radius="md" p="md">
      <Group justify="space-between">
        <div>
          <Text size="xs" c="dimmed" tt="uppercase" fw={700}>
            {title}
          </Text>
          <Text fw={700} size="xl">
            {value}
          </Text>
          {description && (
            <Text size="xs" c="dimmed" mt={4}>
              {description}
            </Text>
          )}
        </div>
        <ThemeIcon
          size={48}
          radius="md"
          variant="light"
        >
          {icon}
        </ThemeIcon>
      </Group>
    </Paper>
  );
}



================================================================================
File: frontend\src\components\students\StudentCard.tsx
================================================================================

import React, { useMemo } from 'react';
import { Card, Text, Group, Stack, Button, Avatar, Box } from '@mantine/core';
import { StatsCard } from '../shared/StatsCard';
import { Student } from '../../types';

interface StudentCardProps {
  student: Student;
  onViewStats?: () => void;
  onSelectForBattle?: () => void;
  onEdit?: () => void;
  onDelete?: () => void;
  onReset?: () => void;
  isSelected?: boolean;
}

export const StudentCard = React.memo(function StudentCard({
  student,
  onViewStats,
  onSelectForBattle,
  onEdit,
  onDelete,
  onReset,
  isSelected = false
}: StudentCardProps) {
  const winRateDisplay = useMemo(() => {
    return `${(student.win_rate * 100).toFixed(1)}%`;
  }, [student.win_rate]);

  const recordDisplay = useMemo(() => {
    return `${student.wins}W - ${student.losses}L`;
  }, [student.wins, student.losses]);

  return (
    <Card
      withBorder
      radius="md"
      p="md"
      style={{
        border: isSelected ? '2px solid #40a9ff' : '1px solid #e9ecef',
        transition: 'all 0.2s ease',
        '&:hover': {
          transform: 'translateY(-2px)',
          boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
        }
      }}
    >
      <Stack>
        <Group justify="space-between" align="flex-start">
          <Group gap="xs">
            <Box
              style={{
                position: 'relative',
                padding: '4px',
                borderRadius: '50%',
                background: 'linear-gradient(45deg, #4dabf7, #228be6)',
                boxShadow: '0 0 10px rgba(77, 171, 247, 0.3)'
              }}
            >
              <Avatar
                src={student.avatar_url || undefined}
                alt={student.name}
                radius="xl"
                size={60}
                style={{
                  border: '2px solid #fff',
                  transition: 'transform 0.2s ease',
                  '&:hover': {
                    transform: 'scale(1.05)'
                  }
                }}
              >
                {(!student.avatar_url && student.name) ? student.name.charAt(0) : ''}
              </Avatar>
            </Box>
            <div>
              <Text 
                size="lg" 
                fw={700}
                style={{
                  background: 'linear-gradient(45deg, #4dabf7, #228be6)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: 'transparent'
                }}
              >
                {student.name}
              </Text>
            </div>
          </Group>

          <Group>
            <Group>
              {onEdit && (
                <Button variant="light" onClick={onEdit} color="blue">
                  Edit
                </Button>
              )}
              {onDelete && (
                <Button variant="light" onClick={onDelete} color="red">
                  Delete
                </Button>
              )}
              {onReset && (
                <Button variant="light" onClick={onReset} color="yellow">
                  Reset Stats
                </Button>
              )}
            </Group>
            {onSelectForBattle && (
              <Button
                variant="light"
                color={isSelected ? 'green' : 'blue'}
                onClick={onSelectForBattle}
                disabled={isSelected}
              >
                {isSelected ? 'Selected' : 'Select for Battle'}
              </Button>
            )}
          </Group>
        </Group>

        <Group grow>
          <StatsCard
            title="ELO Rating"
            value={student.elo_rating}
            icon=""
            description="Current ranking points"
          />
          <StatsCard
            title="Win Rate"
            value={winRateDisplay}
            icon=""
            description={recordDisplay}
          />
        </Group>

        {onViewStats && (
          <Button variant="subtle" onClick={onViewStats} fullWidth>
            View Detailed Stats
          </Button>
        )}
      </Stack>
    </Card>
  );
});



================================================================================
File: frontend\src\components\students\StudentForm.tsx
================================================================================

import React, { useCallback, useMemo, useState } from 'react';
import { TextInput, Stack, Button, Group, Box, Text, Avatar } from '@mantine/core';
import { useForm } from '@mantine/form';
import { motion } from 'framer-motion';
import { Student } from '../../types';

interface StudentFormProps {
  student?: Student | null;
  onSubmit: (values: { name: string; avatar_url?: string }) => void;
  onCancel: () => void;
}

export function StudentForm({ student, onSubmit, onCancel }: StudentFormProps) {
  const [isPreviewHovered, setIsPreviewHovered] = useState(false);

  // Memoize validation function
  const validateName = useCallback((value: string) => {
    return !value ? 'Name is required' : null;
  }, []);

  // Memoize form configuration
  const formConfig = useMemo(() => ({
    initialValues: {
      name: student?.name || '',
      avatar_url: student?.avatar_url || '',
    },
    validate: {
      name: validateName,
    },
  }), [student?.name, student?.avatar_url, validateName]);

  const form = useForm(formConfig);

  // Memoize form submission handler
  const handleSubmit = useCallback((values: { name: string; avatar_url?: string }) => {
    onSubmit(values);
  }, [onSubmit]);

  const currentAvatarUrl = form.values.avatar_url;
  const currentName = form.values.name;

  return (
    <form onSubmit={form.onSubmit(handleSubmit)}>
      <Stack gap="xl">
        {/* Avatar Preview */}
        <Box
          style={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            gap: '1rem'
          }}
        >
          <Text 
            size="sm" 
            fw={500}
            style={{
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent'
            }}
          >
            Avatar Preview
          </Text>
          <Box
            style={{
              position: 'relative',
              padding: '4px',
              borderRadius: '50%',
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              boxShadow: '0 0 10px rgba(77, 171, 247, 0.3)',
              cursor: 'pointer'
            }}
            onMouseEnter={() => setIsPreviewHovered(true)}
            onMouseLeave={() => setIsPreviewHovered(false)}
          >
            <motion.div
              animate={isPreviewHovered ? {
                scale: 1.05,
                rotate: [-3, 3, -3]
              } : {
                scale: 1,
                rotate: 0
              }}
              transition={{
                duration: 0.3
              }}
            >
              <Avatar
                src={currentAvatarUrl || undefined}
                alt={currentName}
                radius="xl"
                size={120}
                style={{
                  border: '2px solid #fff',
                  boxShadow: '0 0 10px rgba(77, 171, 247, 0.2)'
                }}
              >
                {(!currentAvatarUrl && currentName) ? currentName.charAt(0) : ''}
              </Avatar>
            </motion.div>
          </Box>
        </Box>

        <TextInput
          label="Name"
          placeholder="Enter student name"
          required
          styles={{
            label: {
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 500
            }
          }}
          {...form.getInputProps('name')}
        />
        <TextInput
          label="Avatar URL"
          placeholder="https://example.com/photo.jpg"
          styles={{
            label: {
              background: 'linear-gradient(45deg, #4dabf7, #228be6)',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
              fontWeight: 500
            }
          }}
          {...form.getInputProps('avatar_url')}
        />
        <Group justify="flex-end" mt="md">
          <Button 
            variant="light" 
            onClick={onCancel}
            style={{
              transition: 'all 0.2s ease'
            }}
          >
            Cancel
          </Button>
          <Button 
            type="submit"
            variant="gradient"
            gradient={{ from: '#4dabf7', to: '#228be6' }}
            style={{
              transition: 'all 0.2s ease'
            }}
          >
            {student ? 'Update' : 'Add'} Student
          </Button>
        </Group>
      </Stack>
    </form>
  );
}



================================================================================
File: frontend\src\components\students\StudentList.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { Grid, TextInput, Group, Modal, Stack, Alert } from '@mantine/core';
import { StudentCard } from './StudentCard';
import { StudentStats } from './StudentStats';
import { Student } from '../../types';
import { LoadingOverlay } from '../shared/LoadingOverlay';

interface StudentListProps {
  students?: Student[];
  onSelectForBattle?: (student: Student) => void;
  onEdit?: (student: Student) => void;
  onDelete?: (student: Student) => void;
  onReset?: (student: Student) => void;
  loading?: boolean;
  error?: string | null;
  selectedStudents?: Student[];
}

export function StudentList({ 
  students = [], 
  onSelectForBattle, 
  onEdit,
  onDelete,
  loading = false,
  error = null,
  selectedStudents = [],
  onReset
}: StudentListProps) {
  const [searchQuery, setSearchQuery] = useState('');
  const [selectedStudent, setSelectedStudent] = useState<Student | null>(null);

  // Memoize handlers
  const handleSearchChange = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    setSearchQuery(event.currentTarget.value);
  }, []);

  const handleViewStats = useCallback((student: Student) => {
    setSelectedStudent(student);
  }, []);

  const handleCloseStats = useCallback(() => {
    setSelectedStudent(null);
  }, []);

  const handleBattleSelect = useCallback((student: Student) => {
    if (onSelectForBattle) {
      onSelectForBattle(student);
    }
  }, [onSelectForBattle]);

  const handleEdit = useCallback((student: Student) => {
    if (onEdit) {
      onEdit(student);
    }
  }, [onEdit]);

  // Memoize filtered students
  const filteredStudents = useMemo(() => {
    const query = searchQuery.toLowerCase();
    return students.filter(student =>
      student.name.toLowerCase().includes(query)
    );
  }, [students, searchQuery]);

  return (
    <Stack gap="md">
      {loading && <LoadingOverlay visible={true} />}

      {error && (
        <Alert color="red" title="Error">
          {error}
        </Alert>
      )}

      {!loading && !error && (
        <>
          <Group justify="space-between">
            <TextInput
              placeholder="Search students..."
              value={searchQuery}
              onChange={handleSearchChange}
              style={{ flex: 1 }}
            />
          </Group>

          <Grid>
            {filteredStudents.map((student) => (
              <Grid.Col key={student.id} span={{ base: 12, sm: 6, lg: 4 }}>
                <StudentCard
                  student={student}
                  onViewStats={() => handleViewStats(student)}
                  onSelectForBattle={onSelectForBattle ? () => handleBattleSelect(student) : undefined}
                  onEdit={onEdit ? () => handleEdit(student) : undefined}
                  onDelete={onDelete ? () => onDelete(student) : undefined}
                  onReset={onReset ? () => onReset(student) : undefined}
                  isSelected={selectedStudents.some(s => s.id === student.id)}
                />
              </Grid.Col>
            ))}
          </Grid>

          <Modal
            opened={!!selectedStudent}
            onClose={handleCloseStats}
            title={selectedStudent?.name + "'s Statistics"}
            size="xl"
          >
            {selectedStudent && (
              <StudentStats
                student={selectedStudent}
              />
            )}
          </Modal>
        </>
      )}
    </Stack>
  );
}



================================================================================
File: frontend\src\components\students\StudentStats.tsx
================================================================================

import React, { useEffect, useMemo } from 'react';
import { Card, Text, Stack, Grid, Table, Center, Avatar, Group, Box } from '@mantine/core';
import { motion } from 'framer-motion';
import { LineChart } from '@mantine/charts';
import { StatsCard } from '../shared/StatsCard';
import { Student } from '../../types';
import { useStudentStore } from '../../stores';

interface StudentStatsProps {
  student: Student;
}

export const StudentStats = React.memo(function StudentStats({ student }: StudentStatsProps) {
  const { studentHistory, fetchStudentHistory } = useStudentStore();
  const historyData = useMemo(
    () => studentHistory[student.id] || [],
    [studentHistory, student.id]
  );

  useEffect(() => {
    void fetchStudentHistory(student.id);
  }, [student.id, fetchStudentHistory]);

  const eloTimeline = useMemo(() => {
    return historyData.map((mh) => ({
      date: new Date(mh.date).toLocaleDateString(),
      elo: mh.new_elo,
    }));
  }, [historyData]);

  const winRateDisplay = useMemo(
    () => `${(student.win_rate * 100).toFixed(1)}%`,
    [student.win_rate]
  );

  const recordDisplay = useMemo(
    () => `${student.wins}W - ${student.losses}L`,
    [student.wins, student.losses]
  );

  return (
    <Stack gap="lg">
      {/* AVATAR & NAME */}
      <Group gap="md" align="center" mb="xl">
        <Box
          style={{
            position: 'relative',
            padding: '4px',
            borderRadius: '50%',
            background: 'linear-gradient(45deg, #4dabf7, #228be6)',
            boxShadow: '0 0 10px rgba(77, 171, 247, 0.3)'
          }}
        >
          <motion.div
            animate={{
              scale: [1, 1.05, 1],
              rotate: [0, 2, -2, 0]
            }}
            transition={{
              duration: 2,
              repeat: Infinity,
              repeatType: "reverse"
            }}
          >
            <Avatar
              src={student.avatar_url || undefined}
              alt={student.name}
              radius="xl"
              size={90}
              style={{
                border: '2px solid #fff',
                boxShadow: '0 0 10px rgba(77, 171, 247, 0.2)'
              }}
            >
              {(!student.avatar_url && student.name) ? student.name.charAt(0) : ''}
            </Avatar>
          </motion.div>
        </Box>
        <Text 
          size="xl" 
          fw={700}
          style={{
            background: 'linear-gradient(45deg, #4dabf7, #228be6)',
            WebkitBackgroundClip: 'text',
            WebkitTextFillColor: 'transparent'
          }}
        >
          {student.name}
        </Text>
      </Group>

      <Grid>
        <Grid.Col span={4}>
          <StatsCard
            title="Total Matches"
            value={student.total_matches}
            icon=""
            description="Career battles"
          />
        </Grid.Col>
        <Grid.Col span={4}>
          <StatsCard
            title="Win Rate"
            value={winRateDisplay}
            icon=""
            description={recordDisplay}
          />
        </Grid.Col>
        <Grid.Col span={4}>
          <StatsCard
            title="ELO Rating"
            value={student.elo_rating}
            icon=""
            description="Current ranking"
          />
        </Grid.Col>
      </Grid>

      <Card withBorder radius="md" p="md">
        <Text size="lg" fw={700} mb="md">
          ELO Timeline
        </Text>
        {eloTimeline.length < 2 ? (
          <Center>
            <Text size="sm" color="dimmed">
              Not enough data to show chart
            </Text>
          </Center>
        ) : (
          <LineChart
            data={eloTimeline}
            dataKey="date"
            series={[{ name: 'elo', color: 'blue' }]}
            w="100%"
            h={300}
          />
        )}
      </Card>

      <Card withBorder radius="md" p="md">
        <Text size="lg" fw={700} mb="md">
          Match History
        </Text>
        {historyData.length === 0 ? (
          <Text size="sm" color="dimmed">
            No match history yet.
          </Text>
        ) : (
          <Table striped highlightOnHover>
            <thead>
              <tr>
                <th>Date</th>
                <th>Opponent</th>
                <th>Result</th>
                <th>Old ELO</th>
                <th>Change</th>
                <th>New ELO</th>
              </tr>
            </thead>
            <tbody>
              {historyData.map((mh) => (
                <tr key={mh.match_id}>
                  <td>{new Date(mh.date).toLocaleDateString()}</td>
                  <td>{mh.opponent_name}</td>
                  <td style={{ color: mh.result === 'win' ? 'green' : 'red' }}>
                    {mh.result.toUpperCase()}
                  </td>
                  <td>{mh.old_elo.toFixed(1)}</td>
                  <td>
                    {mh.elo_change > 0
                      ? `+${mh.elo_change}`
                      : mh.elo_change}
                  </td>
                  <td>{mh.new_elo.toFixed(1)}</td>
                </tr>
              ))}
            </tbody>
          </Table>
        )}
      </Card>
    </Stack>
  );
});



================================================================================
File: frontend\src\hooks\useArenaBattle.ts
================================================================================

import { useState } from 'react';
import { useBattleStore } from '../stores';
import { useFlashcardStore } from '../stores/flashcardStore';
import type { Flashcard } from '../types';
import { ArenaStep } from '../types/arena';

export const useArenaBattle = () => {
  const { flashcards } = useFlashcardStore();
  const { 
    currentArenaSession,
    currentArenaMatch,
    createArenaSession,
    getNextArenaMatch,
    setArenaMatchWinner,
    getArenaResults
  } = useBattleStore();

  const [currentFlashcard, setCurrentFlashcard] = useState<Flashcard | null>(null);
  const [arenaStep, setArenaStep] = useState<ArenaStep>(ArenaStep.SETUP);
  const [isLoading, setIsLoading] = useState(false);

  const getRandomFlashcard = (): Flashcard | null => {
    if (!flashcards || flashcards.length === 0) return null;
    const randomIndex = Math.floor(Math.random() * flashcards.length);
    return flashcards[randomIndex];
  };

  const startBattle = async (playerIds: string[], rounds: number) => {
    setIsLoading(true);
    try {
      // Create arena session with selected players
      await createArenaSession(playerIds, rounds);

      // Get first match
      await getNextArenaMatch();

      // Set random flashcard
      const flashcard = getRandomFlashcard();
      if (!flashcard) throw new Error('No flashcards available');
      setCurrentFlashcard(flashcard);

      // Move to VS screen
      setArenaStep(ArenaStep.VERSUS);
    } catch (error) {
      console.error('Failed to start battle:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const handleVersusReady = () => {
    setArenaStep(ArenaStep.BATTLE);
  };

  const handleSelectWinner = async (winnerIds: string[]) => {
    if (isLoading) return; // Prevent double submission
    setIsLoading(true);
    try {
      const result = await setArenaMatchWinner(winnerIds);
      const { arena_session: updatedSession } = result;

      // If session is completed or all rounds are done, get final results
      if (updatedSession.status === 'completed' || 
          updatedSession.rounds_completed === updatedSession.num_rounds) {
        await getArenaResults();
        setArenaStep(ArenaStep.FINAL_RESULT);
        return;
      }

      // Otherwise, get next match and continue
      await getNextArenaMatch();
      const flashcard = getRandomFlashcard();
      if (!flashcard) {
        console.error('No flashcards available');
        return;
      }
      setCurrentFlashcard(flashcard);
      setArenaStep(ArenaStep.VERSUS);
    } catch (error) {
      console.error('Failed to process winner:', error);
      // Don't throw, just log the error and return
      return;
    } finally {
      setIsLoading(false);
    }
  };

  const resetBattle = () => {
    setArenaStep(ArenaStep.SETUP);
    setCurrentFlashcard(null);
  };

  return {
    // State
    currentFlashcard,
    arenaStep,
    isLoading,
    currentArenaSession,
    currentArenaMatch,

    // Methods
    startBattle,
    handleVersusReady,
    handleSelectWinner,
    resetBattle,
    setArenaStep
  };
};



================================================================================
File: frontend\src\hooks\useArenaSetup.ts
================================================================================

import { useState, useMemo } from 'react';
import { useStudentStore, useFlashcardStore } from '../stores';
import { usePackStore } from '../stores/packStore';
import type { ValidationError, ArenaSetupData } from '../types/arena';

export const useArenaSetup = () => {
  const { students } = useStudentStore();
  const { packs } = usePackStore();

  // Setup state
  const [selectedPackId, setSelectedPackId] = useState<string>('');
  const [numRounds, setNumRounds] = useState(3);
  const [selectedPlayerIds, setSelectedPlayerIds] = useState<string[]>([]);
  const [validationErrors, setValidationErrors] = useState<ValidationError>({});

  // Computed values
  const studentSelectData = useMemo(() => {
    return students.map((s) => ({
      value: s.id,
      label: `${s.name} (ELO: ${s.elo_rating})`,
    }));
  }, [students]);

  const packSelectData = useMemo(() => {
    return packs.map((p) => ({
      value: p.id,
      label: p.name || 'Untitled Pack',
    }));
  }, [packs]);

  const validateSetup = (): boolean => {
    const errors: ValidationError = {};

    if (!selectedPackId) {
      errors.pack = 'Please select a flashcard pack';
    }

    if (selectedPlayerIds.length < 2) {
      errors.players = 'Please select at least 2 players';
    }

    if (numRounds < 1 || numRounds > 20) {
      errors.rounds = 'Number of rounds must be between 1 and 20';
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const { getByPack } = useFlashcardStore();

  const handlePackChange = async (value: string | null) => {
    const packId = value || '';
    setSelectedPackId(packId);
    setValidationErrors({});
    
    if (packId) {
      await getByPack(packId);
    }
  };

  const handleRoundsChange = (value: string | number) => {
    const numValue = typeof value === 'string' ? parseInt(value, 10) : value;
    setNumRounds(Number.isFinite(numValue) ? numValue : 1);
    setValidationErrors({});
  };

  const handlePlayersChange = (value: string[]) => {
    setSelectedPlayerIds(value);
    setValidationErrors({});
  };

  const getSetupData = (): ArenaSetupData => ({
    selectedPackId,
    numRounds,
    selectedPlayerIds
  });

  const resetSetup = () => {
    setSelectedPackId('');
    setSelectedPlayerIds([]);
    setNumRounds(3);
    setValidationErrors({});
  };

  return {
    // State
    selectedPackId,
    numRounds,
    selectedPlayerIds,
    validationErrors,
    
    // Computed
    studentSelectData,
    packSelectData,
    
    // Methods
    validateSetup,
    handlePackChange,
    handleRoundsChange,
    handlePlayersChange,
    getSetupData,
    resetSetup
  };
};



================================================================================
File: frontend\src\hooks\useFlashcardFilters.ts
================================================================================

import { useState, useMemo } from 'react';
import { Flashcard } from '../types';

export type SortField = 'difficulty' | 'success_rate' | 'created_at' | 'times_used';
export type SortOrder = 'asc' | 'desc';
export type ViewMode = 'grid' | 'list';

export interface SortConfig {
  field: SortField;
  order: SortOrder;
}

export interface AdvancedFilters {
  dateRange: [Date | null, Date | null];
  successRateRange: [number, number];
  usageRange: [number, number];
}

export const INITIAL_FILTERS: AdvancedFilters = {
  dateRange: [null, null],
  successRateRange: [0, 100],
  usageRange: [0, 100],
};

export function useFlashcardFilters(flashcards: Flashcard[]) {
  const [searchQuery, setSearchQuery] = useState('');
  const [difficultyFilter, setDifficultyFilter] = useState<string>('all');
  const [sort, setSort] = useState<SortConfig>({ field: 'created_at', order: 'desc' });
  const [advancedFilters, setAdvancedFilters] = useState<AdvancedFilters>(INITIAL_FILTERS);

  const filteredAndSortedFlashcards = useMemo(() => {
    let result = [...flashcards];

    // Apply all filters
    result = result.filter(card => {
      // Text search
      if (searchQuery) {
        const query = searchQuery.toLowerCase();
        if (!card.question.toLowerCase().includes(query) &&
            !card.answer.toLowerCase().includes(query)) {
          return false;
        }
      }

      // Difficulty filter
      if (difficultyFilter !== 'all' && card.difficulty !== difficultyFilter) {
        return false;
      }

      // Advanced filters
      const cardDate = new Date(card.created_at);
      if (advancedFilters.dateRange[0] && cardDate < advancedFilters.dateRange[0]) return false;
      if (advancedFilters.dateRange[1] && cardDate > advancedFilters.dateRange[1]) return false;

      const successRate = card.success_rate * 100;
      if (successRate < advancedFilters.successRateRange[0] || 
          successRate > advancedFilters.successRateRange[1]) return false;

      if (card.times_used < advancedFilters.usageRange[0] || 
          card.times_used > advancedFilters.usageRange[1]) return false;

      return true;
    });

    // Apply sorting
    result.sort((a, b) => {
      let comparison = 0;
      switch (sort.field) {
        case 'difficulty':
          comparison = a.difficulty.localeCompare(b.difficulty);
          break;
        case 'success_rate':
          comparison = a.success_rate - b.success_rate;
          break;
        case 'created_at':
          comparison = new Date(a.created_at).getTime() - new Date(b.created_at).getTime();
          break;
        case 'times_used':
          comparison = a.times_used - b.times_used;
          break;
      }
      return sort.order === 'asc' ? comparison : -comparison;
    });

    return result;
  }, [flashcards, searchQuery, difficultyFilter, sort, advancedFilters]);

  const handleSortChange = (field: SortField) => {
    setSort(prev => ({
      field,
      order: prev.field === field && prev.order === 'asc' ? 'desc' : 'asc',
    }));
  };

  const resetFilters = () => {
    setSearchQuery('');
    setDifficultyFilter('all');
    setAdvancedFilters(INITIAL_FILTERS);
  };

  return {
    searchQuery,
    setSearchQuery,
    difficultyFilter,
    setDifficultyFilter,
    sort,
    handleSortChange,
    advancedFilters,
    setAdvancedFilters,
    resetFilters,
    filteredAndSortedFlashcards,
  };
}



================================================================================
File: frontend\src\hooks\useSound.ts
================================================================================

import { useEffect, useRef, useCallback } from 'react';

// Sound files are in public/sounds
const battleSoundURL = '/sounds/battle-sound.wav';
const vsScreenSoundURL = '/sounds/vs-screen-sound.wav';
const resultScreenSoundURL = '/sounds/result-screen-sound.wav';

/**
 * This hook manages playing/stopping background and one-shot sounds.
 */
export const useSound = () => {
  // We'll keep one "looped" audio ref for the BATTLE step
  const battleAudioRef = useRef<HTMLAudioElement | null>(null);

  // Initialize the battle-sound Audio object once
  useEffect(() => {
    const audio = new Audio(battleSoundURL);
    audio.loop = true;
    audio.volume = 0.3; // 30% volume
    battleAudioRef.current = audio;

    // Cleanup: stop if unmounted
    return () => {
      audio.pause();
      audio.src = '';
    };
  }, []);

  /**
   * Start the battle-sound loop (if not already playing).
   */
  const playBattleSound = useCallback(() => {
    if (battleAudioRef.current) {
      battleAudioRef.current.currentTime = 0; // optional, restart from beginning
      battleAudioRef.current.play().catch((err) => {
        console.error('Failed to play battle-sound:', err);
      });
    }
  }, []);

  /**
   * Stop the battle-sound loop.
   */
  const stopBattleSound = useCallback(() => {
    if (battleAudioRef.current) {
      battleAudioRef.current.pause();
      battleAudioRef.current.currentTime = 0;
    }
  }, []);

  /**
   * Play the "vs" screen sound once (80% volume).
   */
  const playVsSound = useCallback(() => {
    const audio = new Audio(vsScreenSoundURL);
    audio.volume = 0.8;
    audio.play().catch((err) => {
      console.error('Failed to play vs-screen-sound:', err);
    });
  }, []);

  /**
   * Play the final "result" screen sound once (70% volume).
   */
  const playResultSound = useCallback(() => {
    const audio = new Audio(resultScreenSoundURL);
    audio.volume = 0.35;
    audio.play().catch((err) => {
      console.error('Failed to play result-screen-sound:', err);
    });
  }, []);

  /**
   * Keep the existing playSound function for backward compatibility
   */
  const playSound = useCallback((effect: string) => {
    // No-op for now, can be expanded later if needed
  }, []);

  return {
    playBattleSound,
    stopBattleSound,
    playVsSound,
    playResultSound,
    playSound, // Keep existing usage safe
  };
};



================================================================================
File: frontend\src\pages\ArenaPage.tsx
================================================================================

import React, { useEffect, useState } from 'react';
import { Box, Center, Card, Title, Stack, LoadingOverlay } from '@mantine/core';
import { motion, AnimatePresence } from 'framer-motion';

import { useStudentStore } from '../stores';
import { useFlashcardStore } from '../stores/flashcardStore';
import { usePackStore } from '../stores/packStore';
import { ErrorAlert } from '../components/shared/ErrorAlert';
import { ArenaSetup } from '../components/arena/ArenaSetup';
import { ArenaBattle } from '../components/arena/ArenaBattle';
import { useArenaBattle } from '../hooks/useArenaBattle';
import { ArenaStep } from '../types/arena';

export function ArenaPage() {
  const { students, fetchStudents, error: studentsError } = useStudentStore();
  const { getByPack, error: flashcardsError } = useFlashcardStore();
  const { fetchPacks, error: packsError } = usePackStore();
  const [retryCount, setRetryCount] = useState(0);
  const [isLoading, setIsLoading] = useState(false);

  const {
    currentFlashcard,
    arenaStep,
    isLoading: battleLoading,
    currentArenaSession,
    currentArenaMatch,
    startBattle,
    handleVersusReady,
    handleSelectWinner,
    resetBattle
  } = useArenaBattle();

  // Load initial data
  useEffect(() => {
    const loadInitialData = async () => {
      setIsLoading(true);
      try {
        await Promise.all([fetchStudents(), fetchPacks()]);
      } catch (error) {
        console.error('Failed to load initial data:', error);
      } finally {
        setIsLoading(false);
      }
    };
    loadInitialData();
  }, [fetchStudents, fetchPacks, retryCount]);

  const handleStartArena = async (packId: string, playerIds: string[], rounds: number) => {
    setIsLoading(true);
    try {
      await getByPack(packId);
      await startBattle(playerIds, rounds);
    } catch (error) {
      console.error('Failed to start arena:', error);
    } finally {
      setIsLoading(false);
    }
  };

  const handleRetry = () => {
    setRetryCount(prev => prev + 1);
  };

  // Error handling
  const error = studentsError || flashcardsError || packsError;
  if (error) {
    return (
      <Center style={{ minHeight: '50vh' }}>
        <ErrorAlert 
          error={error} 
          onRetry={handleRetry}
        />
      </Center>
    );
  }

  const renderContent = () => {
    if (arenaStep === ArenaStep.SETUP) {
      return (
        <ArenaSetup 
          onStart={handleStartArena}
          isLoading={isLoading || battleLoading}
        />
      );
    }

    return (
      <ArenaBattle
        step={arenaStep}
        currentFlashcard={currentFlashcard}
        currentMatch={currentArenaMatch}
        arenaSession={currentArenaSession}
        students={students}
        onVersusReady={handleVersusReady}
        onSelectWinner={handleSelectWinner}
        onReset={resetBattle}
        isLoading={battleLoading}
      />
    );
  };

  return (
    <Box pos="relative" style={{ minHeight: '70vh' }}>
      <LoadingOverlay 
        visible={isLoading} 
        zIndex={1000}
        overlayProps={{ blur: 2 }}
      />
      <Center py="xl">
        <Card w="90%" maw={1200}>
          <Stack>
            <Title order={2} ta="center" mt="sm">
              Flashcard Arena
            </Title>
            <AnimatePresence mode="wait">
              <motion.div
                key={arenaStep}
                initial={{ opacity: 0, y: 20 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -20 }}
                transition={{ type: "spring", stiffness: 100, damping: 15 }}
              >
                {renderContent()}
              </motion.div>
            </AnimatePresence>
          </Stack>
        </Card>
      </Center>
    </Box>
  );
}



================================================================================
File: frontend\src\pages\FlashcardsPage.tsx
================================================================================

import React, { useState, useCallback, useMemo } from 'react';
import { Title, Alert, Stack, Tabs, Card, Center, Box } from '@mantine/core';
import { IconAlertCircle } from '@tabler/icons-react';
import { useFlashcardStore } from '../stores/flashcardStore';
import { usePackStore } from '../stores/packStore';
import { FlashcardPacks } from '../components/flashcards/FlashcardPacks';
import { FlashcardList } from '../components/flashcards/FlashcardList';

export const FlashcardsPage = React.memo(function FlashcardsPage() {
  const { error: flashcardError } = useFlashcardStore();
  const { error: packError } = usePackStore();
  const error = flashcardError || packError;
  const [activeTab, setActiveTab] = useState<string | null>('packs');

  const handleTabChange = useCallback((value: string | null) => {
    setActiveTab(value);
  }, []);

  const errorAlert = useMemo(() => {
    if (!error) return null;
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="Error" color="red">
        {error}
      </Alert>
    );
  }, [error]);

  const tabPanels = useMemo(() => ({
    packs: <FlashcardPacks />,
    cards: <FlashcardList />
  }), []);

  if (error) {
    return errorAlert;
  }

  return (
    <Box>
      <Center py="xl">
        <Card w="90%" maw={1200}>
          <Stack gap="lg">
            <Title order={2}>Flashcards</Title>
            <Card>
              <Tabs value={activeTab} onChange={handleTabChange} color="teal">
                <Tabs.List>
                  <Tabs.Tab value="packs">Packs</Tabs.Tab>
                  <Tabs.Tab value="cards">All Cards</Tabs.Tab>
                </Tabs.List>

                <Tabs.Panel value="packs" pt="md">
                  {tabPanels.packs}
                </Tabs.Panel>

                <Tabs.Panel value="cards" pt="md">
                  {tabPanels.cards}
                </Tabs.Panel>
              </Tabs>
            </Card>
          </Stack>
        </Card>
      </Center>
    </Box>
  );
});



================================================================================
File: frontend\src\pages\StudentsPage.tsx
================================================================================

import React, { useEffect, useState, useCallback, useMemo } from 'react';
import { StudentList } from '../components/students/StudentList';
import { StudentForm } from '../components/students/StudentForm';
import { Title, Alert, Button, Modal, Group, Text, Stack, Card, Center, Box } from '@mantine/core';
import { useStudentStore } from '../stores';
import { IconAlertCircle, IconPlus } from '@tabler/icons-react';
import { Student } from '../types';

export function StudentsPage() {
  const { students, loading, error, fetchStudents, addStudent, updateStudent, deleteStudent, resetStudentStats } = useStudentStore();
  const [formModalOpen, setFormModalOpen] = useState(false);
  const [selectedStudent, setSelectedStudent] = useState<Student | null>(null);
  const [deleteModalOpen, setDeleteModalOpen] = useState(false);
  const [studentToDelete, setStudentToDelete] = useState<Student | null>(null);

  useEffect(() => {
    fetchStudents();
  }, [fetchStudents]);

  const handleSubmit = useCallback(async (values: { name: string; avatar_url?: string }) => {
    if (selectedStudent) {
      await updateStudent(selectedStudent.id, { 
        name: values.name,
        avatar_url: values.avatar_url
      });
    } else {
      await addStudent({ 
        name: values.name,
        avatar_url: values.avatar_url
      });
    }
    setFormModalOpen(false);
    setSelectedStudent(null);
  }, [selectedStudent, updateStudent, addStudent]);

  const handleEdit = useCallback((student: Student) => {
    setSelectedStudent(student);
    setFormModalOpen(true);
  }, []);

  const handleModalClose = useCallback(() => {
    setFormModalOpen(false);
    setSelectedStudent(null);
  }, []);

  const handleDeleteClick = useCallback((student: Student) => {
    setStudentToDelete(student);
    setDeleteModalOpen(true);
  }, []);

  const handleDeleteConfirm = useCallback(async () => {
    if (studentToDelete) {
      await deleteStudent(studentToDelete.id);
      setDeleteModalOpen(false);
      setStudentToDelete(null);
    }
  }, [deleteStudent, studentToDelete]);

  const handleDeleteCancel = useCallback(() => {
    setDeleteModalOpen(false);
    setStudentToDelete(null);
  }, []);

  const handleReset = useCallback(async (student: Student) => {
    await resetStudentStats(student.id);
  }, [resetStudentStats]);

  const handleAddClick = useCallback(() => {
    setSelectedStudent(null);
    setFormModalOpen(true);
  }, []);

  const modalTitle = useMemo(() => 
    selectedStudent ? 'Edit Student' : 'Add New Student',
    [selectedStudent]
  );

  const errorAlert = useMemo(() => {
    if (!error) return null;
    return (
      <Alert icon={<IconAlertCircle size={16} />} title="Error" color="red">
        {error}
      </Alert>
    );
  }, [error]);

  if (error) {
    return errorAlert;
  }

  return (
    <Box>
      <Center py="xl">
        <Card w="90%" maw={1200}>
          <Stack gap="lg">
            <Group justify="space-between">
              <Title order={2}>Students</Title>
              <Button
                leftSection={<IconPlus size={16} />}
                onClick={handleAddClick}
                color="teal"
              >
                Add Student
              </Button>
            </Group>

            <Card>
              <StudentList 
                students={students} 
                onEdit={handleEdit}
                onDelete={handleDeleteClick}
                onReset={handleReset}
                loading={loading}
                error={error}
              />
            </Card>
          </Stack>
        </Card>
      </Center>

      <Modal
        opened={formModalOpen}
        onClose={handleModalClose}
        title={modalTitle}
      >
        <StudentForm
          student={selectedStudent}
          onSubmit={handleSubmit}
          onCancel={handleModalClose}
        />
      </Modal>

      <Modal
        opened={deleteModalOpen}
        onClose={handleDeleteCancel}
        title="Delete Student"
      >
        <Stack>
          <Text>Are you sure you want to delete {studentToDelete?.name}? This action cannot be undone.</Text>
          <Group justify="flex-end">
            <Button variant="light" color="teal" onClick={handleDeleteCancel}>Cancel</Button>
            <Button color="red" variant="filled" onClick={handleDeleteConfirm}>Delete</Button>
          </Group>
        </Stack>
      </Modal>
    </Box>
  );
}



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.a11y.test.tsx
================================================================================

import React from 'react';
import { render, screen } from '@testing-library/react';
import { axe, toHaveNoViolations } from 'jest-axe';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';
import { 
  Student, 
  Flashcard, 
  ArenaMatch, 
  ArenaSession,
  DifficultyLevel,
  MatchStatus,
  ArenaSessionStatus
} from '../../types';

expect.extend(toHaveNoViolations);

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/flashcardStore', () => ({
  useFlashcardStore: jest.fn()
}));

jest.mock('../../stores/packStore', () => ({
  usePackStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Accessibility', () => {
  const mockStudents: Student[] = [
    {
      id: '1',
      name: 'Student 1',
      elo_rating: 1000,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    },
    {
      id: '2',
      name: 'Student 2',
      elo_rating: 1200,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    }
  ];

  const mockFlashcard: Flashcard = {
    id: '1',
    pack_id: '1',
    question: 'Test Question',
    answer: 'Test Answer',
    difficulty: DifficultyLevel.MEDIUM,
    times_used: 0,
    times_correct: 0,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    success_rate: 0
  };

  const mockMatch: ArenaMatch = {
    id: '1',
    arena_id: '1',
    status: MatchStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    player1_id: '1',
    player2_id: '2',
    player1_elo_before: 1000,
    player2_elo_before: 1200,
    winner_ids: [],
    created_at: '2024-01-01',
    updated_at: '2024-01-01'
  };

  const mockSession: ArenaSession = {
    id: '1',
    status: ArenaSessionStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    participants: [
      { student_id: '1', name: 'Student 1', elo_rating: 1000, elo_change: 0, wins: 0, losses: 0, fights_played: 1 },
      { student_id: '2', name: 'Student 2', elo_rating: 1200, elo_change: 0, wins: 0, losses: 0, fights_played: 1 }
    ]
  };

  beforeEach(() => {
    mockHook(useStudentStore, {
      students: mockStudents,
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(useFlashcardStore, {
      flashcards: [mockFlashcard],
      error: null
    });

    mockHook(usePackStore, {
      packs: [
        { id: '1', name: 'Pack 1', description: 'Test Pack 1' }
      ],
      fetchPacks: jest.fn(),
      error: null
    });
  });

  it('setup step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('versus step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.VERSUS,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('battle step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: false,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('final results step has no accessibility violations', async () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    const { container } = render(<ArenaPage />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('has proper heading structure', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    const headings = screen.getAllByRole('heading');
    expect(headings.length).toBeGreaterThan(0);
    expect(headings[0]).toHaveAttribute('aria-level', '1');
  });

  it('form controls have associated labels', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    const inputs = screen.getAllByRole('spinbutton');
    inputs.forEach(input => {
      expect(input).toHaveAccessibleName();
    });
  });

  it('buttons have descriptive text', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    const buttons = screen.getAllByRole('button');
    buttons.forEach(button => {
      expect(button).toHaveAccessibleName();
    });
  });

  it('loading states are announced to screen readers', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: true
    });

    render(<ArenaPage />);
    expect(screen.getByRole('alert')).toHaveTextContent(/loading/i);
  });

  it('error messages are announced to screen readers', () => {
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: jest.fn(),
      error: 'Test error message'
    });

    render(<ArenaPage />);
    expect(screen.getByRole('alert')).toHaveTextContent('Test error message');
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.battle.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';
import { 
  Student, 
  Flashcard, 
  ArenaMatch, 
  ArenaSession,
  DifficultyLevel,
  MatchStatus,
  ArenaSessionStatus
} from '../../types';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/flashcardStore', () => ({
  useFlashcardStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Battle Step', () => {
  const mockStudents: Student[] = [
    {
      id: '1',
      name: 'Student 1',
      elo_rating: 1000,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    },
    {
      id: '2',
      name: 'Student 2',
      elo_rating: 1200,
      wins: 0,
      losses: 0,
      total_matches: 0,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0
    }
  ];

  const mockFlashcard: Flashcard = {
    id: '1',
    pack_id: '1',
    question: 'Test Question',
    answer: 'Test Answer',
    difficulty: DifficultyLevel.MEDIUM,
    times_used: 0,
    times_correct: 0,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    success_rate: 0
  };

  const mockMatch: ArenaMatch = {
    id: '1',
    arena_id: '1',
    status: MatchStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    player1_id: '1',
    player2_id: '2',
    player1_elo_before: 1000,
    player2_elo_before: 1200,
    winner_ids: [],
    created_at: '2024-01-01',
    updated_at: '2024-01-01'
  };

  const mockSession: ArenaSession = {
    id: '1',
    status: ArenaSessionStatus.IN_PROGRESS,
    num_rounds: 3,
    rounds_completed: 1,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    participants: [
      { student_id: '1', name: 'Student 1', elo_rating: 1000, elo_change: 0, wins: 0, losses: 0, fights_played: 1 },
      { student_id: '2', name: 'Student 2', elo_rating: 1200, elo_change: 0, wins: 0, losses: 0, fights_played: 1 }
    ]
  };

  beforeEach(() => {
    mockHook(useStudentStore, {
      students: mockStudents,
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(useFlashcardStore, {
      flashcards: [mockFlashcard],
      error: null
    });

    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: false,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      handleSelectWinner: jest.fn(),
      handleVersusReady: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('displays current flashcard during battle', () => {
    render(<ArenaPage />);
    expect(screen.getByText(mockFlashcard.question)).toBeInTheDocument();
    expect(screen.getByText(mockFlashcard.answer)).toBeInTheDocument();
  });

  it('displays current match participants', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/Student 1/)).toBeInTheDocument();
    expect(screen.getByText(/Student 2/)).toBeInTheDocument();
  });

  it('shows ELO ratings for participants', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/1000/)).toBeInTheDocument();
    expect(screen.getByText(/1200/)).toBeInTheDocument();
  });

  it('allows selecting a winner', async () => {
    const mockHandleSelectWinner = jest.fn();
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: false,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      handleSelectWinner: mockHandleSelectWinner
    });

    render(<ArenaPage />);
    
    const winnerButton = screen.getByTestId('select-winner-1');
    fireEvent.click(winnerButton);

    await waitFor(() => {
      expect(mockHandleSelectWinner).toHaveBeenCalledWith(['1']);
    });
  });

  it('shows loading state when selecting winner', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.BATTLE,
      isLoading: true,
      currentFlashcard: mockFlashcard,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('loading-overlay')).toBeInTheDocument();
  });

  it('displays battle progress', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/Round 2 of 3/)).toBeInTheDocument();
  });

  it('shows versus screen between matches', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.VERSUS,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('versus-screen')).toBeInTheDocument();
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.scores.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';
import { 
  Student, 
  ArenaMatch, 
  ArenaSession,
  MatchStatus,
  ArenaSessionStatus
} from '../../types';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Final Results', () => {
  const mockStudents: Student[] = [
    {
      id: '1',
      name: 'Student 1',
      elo_rating: 1050,
      wins: 2,
      losses: 1,
      total_matches: 3,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0.67
    },
    {
      id: '2',
      name: 'Student 2',
      elo_rating: 1150,
      wins: 1,
      losses: 2,
      total_matches: 3,
      created_at: '2024-01-01',
      updated_at: '2024-01-01',
      win_rate: 0.33
    }
  ];

  const mockMatch: ArenaMatch = {
    id: '1',
    arena_id: '1',
    status: MatchStatus.COMPLETED,
    num_rounds: 3,
    rounds_completed: 3,
    player1_id: '1',
    player2_id: '2',
    player1_elo_before: 1000,
    player2_elo_before: 1200,
    player1_elo_after: 1050,
    player2_elo_after: 1150,
    winner_ids: ['1'],
    created_at: '2024-01-01',
    updated_at: '2024-01-01'
  };

  const mockSession: ArenaSession = {
    id: '1',
    status: ArenaSessionStatus.COMPLETED,
    num_rounds: 3,
    rounds_completed: 3,
    created_at: '2024-01-01',
    updated_at: '2024-01-01',
    participants: [
      { 
        student_id: '1', 
        name: 'Student 1', 
        elo_rating: 1050, 
        elo_change: 50, 
        wins: 2, 
        losses: 1, 
        fights_played: 3,
        elo_before: 1000,
        elo_after: 1050
      },
      { 
        student_id: '2', 
        name: 'Student 2', 
        elo_rating: 1150, 
        elo_change: -50, 
        wins: 1, 
        losses: 2, 
        fights_played: 3,
        elo_before: 1200,
        elo_after: 1150
      }
    ]
  };

  beforeEach(() => {
    mockHook(useStudentStore, {
      students: mockStudents,
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      resetBattle: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('displays final results header', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/Final Results/i)).toBeInTheDocument();
  });

  it('shows all participants in final scoreboard', () => {
    render(<ArenaPage />);
    mockSession.participants?.forEach(participant => {
      expect(screen.getByText(participant.name!)).toBeInTheDocument();
    });
  });

  it('displays ELO changes for each participant', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/\+50/)).toBeInTheDocument(); // Student 1 gained 50
    expect(screen.getByText(/-50/)).toBeInTheDocument(); // Student 2 lost 50
  });

  it('shows win/loss record for each participant', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/2 wins/i)).toBeInTheDocument();
    expect(screen.getByText(/1 loss/i)).toBeInTheDocument();
    expect(screen.getByText(/1 win/i)).toBeInTheDocument();
    expect(screen.getByText(/2 losses/i)).toBeInTheDocument();
  });

  it('displays final ELO ratings', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/1050/)).toBeInTheDocument();
    expect(screen.getByText(/1150/)).toBeInTheDocument();
  });

  it('allows starting a new arena', () => {
    const mockResetBattle = jest.fn();
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: false,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession,
      resetBattle: mockResetBattle
    });

    render(<ArenaPage />);
    
    const newArenaButton = screen.getByText(/Start New Arena/i);
    fireEvent.click(newArenaButton);

    expect(mockResetBattle).toHaveBeenCalled();
  });

  it('shows loading state when starting new arena', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.FINAL_RESULT,
      isLoading: true,
      currentArenaMatch: mockMatch,
      currentArenaSession: mockSession
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('loading-overlay')).toBeInTheDocument();
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.setup.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { usePackStore } from '../../stores/packStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/packStore', () => ({
  usePackStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage Setup Step', () => {
  beforeEach(() => {
    mockHook(useStudentStore, {
      students: [
        { id: '1', name: 'Student 1', elo_rating: 1000 },
        { id: '2', name: 'Student 2', elo_rating: 1200 }
      ],
      fetchStudents: jest.fn(),
      error: null
    });

    mockHook(usePackStore, {
      packs: [
        { id: '1', name: 'Pack 1', description: 'Test Pack 1' },
        { id: '2', name: 'Pack 2', description: 'Test Pack 2' }
      ],
      fetchPacks: jest.fn(),
      error: null
    });

    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false,
      startBattle: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('displays student selection in setup', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/select players/i)).toBeInTheDocument();
  });

  it('displays pack selection in setup', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/select pack/i)).toBeInTheDocument();
  });

  it('displays rounds input in setup', () => {
    render(<ArenaPage />);
    expect(screen.getByText(/number of rounds/i)).toBeInTheDocument();
  });

  it('validates minimum number of players', () => {
    render(<ArenaPage />);
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);
    expect(screen.getByText(/select at least 2 players/i)).toBeInTheDocument();
  });

  it('validates pack selection', () => {
    render(<ArenaPage />);
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);
    expect(screen.getByText(/select a pack/i)).toBeInTheDocument();
  });

  it('validates rounds input', () => {
    render(<ArenaPage />);
    const roundsInput = screen.getByLabelText(/number of rounds/i);
    fireEvent.change(roundsInput, { target: { value: '0' } });
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);
    expect(screen.getByText(/minimum 1 round required/i)).toBeInTheDocument();
  });
});



================================================================================
File: frontend\src\pages\__tests__\ArenaPage.test.tsx
================================================================================

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import { ArenaPage } from '../ArenaPage';
import { useStudentStore } from '../../stores';
import { useFlashcardStore } from '../../stores/flashcardStore';
import { usePackStore } from '../../stores/packStore';
import { useArenaBattle } from '../../hooks/useArenaBattle';
import { ArenaStep } from '../../types/arena';

// Helper to type-safely mock a hook
const mockHook = <T extends object>(hook: unknown, defaultValue: T) => {
  return (hook as jest.Mock<T>).mockReturnValue(defaultValue);
};

// Mock the stores and hooks
jest.mock('../../stores', () => ({
  useStudentStore: jest.fn()
}));

jest.mock('../../stores/flashcardStore', () => ({
  useFlashcardStore: jest.fn()
}));

jest.mock('../../stores/packStore', () => ({
  usePackStore: jest.fn()
}));

jest.mock('../../hooks/useArenaBattle', () => ({
  useArenaBattle: jest.fn()
}));

describe('ArenaPage', () => {
  // Setup default mock implementations
  beforeEach(() => {
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: jest.fn(),
      error: null
    });
    
    mockHook(useFlashcardStore, {
      getByPack: jest.fn(),
      error: null
    });
    
    mockHook(usePackStore, {
      fetchPacks: jest.fn(),
      error: null
    });
    
    mockHook(useArenaBattle, {
      currentFlashcard: null,
      arenaStep: ArenaStep.SETUP,
      isLoading: false,
      currentArenaSession: null,
      currentArenaMatch: null,
      startBattle: jest.fn(),
      handleVersusReady: jest.fn(),
      handleSelectWinner: jest.fn(),
      resetBattle: jest.fn()
    });
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('loads initial data on mount', () => {
    const mockFetchStudents = jest.fn();
    const mockFetchPacks = jest.fn();
    
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: mockFetchStudents,
      error: null
    });
    
    mockHook(usePackStore, {
      fetchPacks: mockFetchPacks,
      error: null
    });

    render(<ArenaPage />);

    expect(mockFetchStudents).toHaveBeenCalled();
    expect(mockFetchPacks).toHaveBeenCalled();
  });

  it('shows error alert when there is an error', () => {
    const testError = 'Test error message';
    mockHook(useStudentStore, {
      students: [],
      fetchStudents: jest.fn(),
      error: testError
    });

    render(<ArenaPage />);
    expect(screen.getByText(testError)).toBeInTheDocument();
  });

  it('shows ArenaSetup component in setup step', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      isLoading: false
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('arena-setup')).toBeInTheDocument();
  });

  it('shows ArenaBattle component after setup', () => {
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.VERSUS,
      isLoading: false,
      currentArenaMatch: { id: '1' },
      currentArenaSession: { id: '1' }
    });

    render(<ArenaPage />);
    expect(screen.getByTestId('arena-battle')).toBeInTheDocument();
  });

  it('handles start arena action', async () => {
    const mockGetByPack = jest.fn();
    const mockStartBattle = jest.fn();
    
    mockHook(useFlashcardStore, {
      getByPack: mockGetByPack,
      error: null
    });
    
    mockHook(useArenaBattle, {
      arenaStep: ArenaStep.SETUP,
      startBattle: mockStartBattle,
      isLoading: false
    });

    render(<ArenaPage />);

    // Simulate starting an arena
    const startButton = screen.getByTestId('start-arena-button');
    fireEvent.click(startButton);

    await waitFor(() => {
      expect(mockGetByPack).toHaveBeenCalled();
      expect(mockStartBattle).toHaveBeenCalled();
    });
  });
});



================================================================================
File: frontend\src\services\api.ts
================================================================================

import axios from 'axios';
import type {
  ApiResponse,
  Student,
  Flashcard,
  FlashcardPack,
  CreateStudentRequest,
  CreateFlashcardRequest,
  CreateFlashcardPackRequest,
  BulkImportResult,
  FlashcardStats,
  FlashcardUsageStats,
  FlashcardArenaStats,
} from '../types';

const BASE_URL = 'http://localhost:8000/api';

// Create axios instances
const axiosInstance = axios.create({
  baseURL: BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Match API
export const matchApi = {
  createMultiplayer: (data: { player_ids: string[], num_rounds: number }) =>
    axiosInstance.post('/matches/multiplayer', data),
  
  autoMatch: (data: { num_players: number, num_rounds: number, student_id: string }) =>
    axiosInstance.post('/matches/auto-match', data),
  
  getById: (matchId: string) =>
    axiosInstance.get(`/matches/${matchId}`),
  
  updateStatus: (matchId: string, status: string) =>
    axiosInstance.patch(`/matches/${matchId}/status`, { status }),
};

// Round API
export const roundApi = {
  create: (data: { match_id: string, flashcard_id: string }) =>
    axiosInstance.post('/matches/rounds', data),
  
  submitAnswer: (roundId: string, playerId: string, answer: string) =>
    axiosInstance.post(`/matches/rounds/${roundId}/answer`, { 
      player_id: playerId,
      answer 
    }),
  
  setWinners: (roundId: string, data: { winner_ids: string[] }) =>
    axiosInstance.post(`/matches/rounds/${roundId}/winner`, data),
};

// Arena API
export const arenaApi = {
  createSession: (data: { student_ids: string[], num_rounds: number }) =>
    axiosInstance.post('/arena', data),
  
  getNextMatch: (arenaId: string) =>
    axiosInstance.get(`/arena/${arenaId}/next-match`),
  
  setMatchWinner: (matchId: string, winnerIds: string[]) =>
    axiosInstance.patch(`/arena/matches/${matchId}/winner`, { winner_ids: winnerIds }),
  
  getResults: (arenaId: string) =>
    axiosInstance.get(`/arena/${arenaId}/results`),
};

// Student API
export const studentApi = {
  getAll: () => axiosInstance.get<ApiResponse<Student[]>>('/students'),
  getById: (id: string) => axiosInstance.get<ApiResponse<Student>>(`/students/${id}`),
  create: (data: CreateStudentRequest) => axiosInstance.post<ApiResponse<Student>>('/students', data),
  update: (id: string, data: CreateStudentRequest) => axiosInstance.put<ApiResponse<Student>>(`/students/${id}`, data),
  delete: (id: string) => axiosInstance.delete(`/students/${id}`),
  getStats: (id: string) => axiosInstance.get<ApiResponse<Student>>(`/students/${id}/stats`),
  getHistory: (id: string) => axiosInstance.get<ApiResponse<any[]>>(`/students/${id}/history`),
  resetStats: (id: string) => axiosInstance.post<ApiResponse<Student>>(`/students/${id}/reset`),
};

// Flashcard API
export const flashcardApi = {
  getAll: () => axiosInstance.get<ApiResponse<Flashcard[]>>('/flashcards/all'),
  getById: (id: string) => axiosInstance.get<ApiResponse<Flashcard>>(`/flashcards/${id}`),
  create: (data: CreateFlashcardRequest) => axiosInstance.post<ApiResponse<Flashcard>>('/flashcards', data),
  update: (id: string, data: CreateFlashcardRequest) => axiosInstance.put<ApiResponse<Flashcard>>(`/flashcards/${id}`, data),
  delete: (id: string) => axiosInstance.delete(`/flashcards/${id}`),
  getByPack: (packId: string) => axiosInstance.get<ApiResponse<Flashcard[]>>(`/flashcards/pack/${packId}`),
  
  // Statistics endpoints
  getStats: (id: string) => axiosInstance.get<ApiResponse<FlashcardStats>>(`/stats/flashcards/${id}/stats`),
  getMostUsed: (limit?: number) => axiosInstance.get<ApiResponse<FlashcardUsageStats[]>>('/stats/flashcards/most-used', {
    params: { limit }
  }),
  getArenaStats: (arenaId: string) => axiosInstance.get<ApiResponse<FlashcardArenaStats[]>>(`/stats/arena/${arenaId}/flashcard-stats`),

  // Bulk ops
  getImportTemplate: () => axiosInstance.post<Blob>('/flashcards/template', null, { responseType: 'blob' }),
  bulkImport: (file: File) => {
    const formData = new FormData();
    formData.append('file', file);
    return axiosInstance.post<ApiResponse<BulkImportResult>>('/flashcards/bulk-import', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    });
  },
  exportPack: (packId: string) => axiosInstance.get<Blob>(`/flashcards/export/${packId}`, { responseType: 'blob' }),
};

// Flashcard Pack API
export const flashcardPackApi = {
  getAll: () => axiosInstance.get<ApiResponse<FlashcardPack[]>>('/flashcards/packs'),
  getById: (id: string) => axiosInstance.get<ApiResponse<FlashcardPack>>(`/flashcards/packs/${id}`),
  create: (data: CreateFlashcardPackRequest) => axiosInstance.post<ApiResponse<FlashcardPack>>('/flashcards/packs', data),
  update: (id: string, data: CreateFlashcardPackRequest) => axiosInstance.put<ApiResponse<FlashcardPack>>(`/flashcards/packs/${id}`, data),
  delete: (id: string) => axiosInstance.delete(`/flashcards/packs/${id}`),
};



================================================================================
File: frontend\src\services\flashcardEntityApi.ts
================================================================================

import type { Flashcard } from '../types';
import { flashcardApi } from './api';
import { EntityApi } from '../stores/createEntityStore';

export const flashcardEntityApi: EntityApi<Flashcard> = {
  getAll: async () => {
    const response = await flashcardApi.getAll();
    return response.data.data;
  },
  getById: async (id: string) => {
    const response = await flashcardApi.getById(id);
    return response.data.data;
  },
  create: async (data: Partial<Flashcard>) => {
    const response = await flashcardApi.create({
      question: data.question as string,
      answer: data.answer as string,
      pack_id: data.pack_id as string,
      difficulty: data.difficulty,
    });
    return response.data.data;
  },
  update: async (id: string, data: Partial<Flashcard>) => {
    const response = await flashcardApi.update(id, {
      question: data.question as string,
      answer: data.answer as string,
      pack_id: data.pack_id as string,
      difficulty: data.difficulty,
    });
    return response.data.data;
  },
  delete: async (id: string) => {
    await flashcardApi.delete(id);
  },
};

// Additional flashcard-specific operations that don't fit the EntityApi interface
export const flashcardExtraApi = {
  getByPack: flashcardApi.getByPack,
  getImportTemplate: flashcardApi.getImportTemplate,
  bulkImport: flashcardApi.bulkImport,
  exportPack: flashcardApi.exportPack,
};



================================================================================
File: frontend\src\services\flashcardPackEntityApi.ts
================================================================================

import type { FlashcardPack, CreateFlashcardPackRequest } from '../types';
import { flashcardPackApi } from './api';
import { EntityApi } from '../stores/createEntityStore';

export const flashcardPackEntityApi: EntityApi<FlashcardPack> = {
  getAll: async () => {
    const response = await flashcardPackApi.getAll();
    return response.data.data;
  },
  getById: async (id: string) => {
    const response = await flashcardPackApi.getById(id);
    return response.data.data;
  },
  create: async (data: Partial<FlashcardPack>) => {
    const response = await flashcardPackApi.create({
      name: data.name as string,
      description: data.description,
    });
    return response.data.data;
  },
  update: async (id: string, data: Partial<FlashcardPack>) => {
    const response = await flashcardPackApi.update(id, {
      name: data.name as string,
      description: data.description,
    });
    return response.data.data;
  },
  delete: async (id: string) => {
    await flashcardPackApi.delete(id);
  },
};



================================================================================
File: frontend\src\services\studentEntityApi.ts
================================================================================

import type { Student, CreateStudentRequest } from '../types';
import { studentApi } from './api';
import { EntityApi } from '../stores/createEntityStore';

export const studentEntityApi: EntityApi<Student> = {
  getAll: async () => {
    const response = await studentApi.getAll();
    return response.data.data;
  },
  getById: async (id: string) => {
    const response = await studentApi.getById(id);
    return response.data.data;
  },
  create: async (data: Partial<Student>) => {
    const response = await studentApi.create({
      name: data.name as string,
      avatar_url: data.avatar_url as string,
    });
    return response.data.data;
  },
  update: async (id: string, data: Partial<Student>) => {
    const response = await studentApi.update(id, {
      name: data.name as string,
      avatar_url: data.avatar_url as string,
    });
    return response.data.data;
  },
  delete: async (id: string) => {
    await studentApi.delete(id);
  },
};



================================================================================
File: frontend\src\stores\battleStore.ts
================================================================================

import { create } from 'zustand';
import { arenaApi, matchApi } from '../services/api';
import { MatchStatus, ArenaSessionStatus } from '../types';
import type { Match } from '../types';

interface ArenaSession {
  id: string;
  status: ArenaSessionStatus;
  num_rounds: number;
  rounds_completed: number;
  participants: Array<{
    student_id: string;
    name: string;
    elo_rating: number;
    wins: number;
    losses: number;
    fights_played: number;
    elo_change: number;
  }>;
}

interface ArenaMatch {
  id: string;
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  player1_id: string;
  player2_id: string;
  winner_ids: string[];
  player1_elo_before: number;
  player2_elo_before: number;
  player1_elo_after: number | null;
  player2_elo_after: number | null;
}

interface BattleStoreState {
  currentArenaSession: ArenaSession | null;
  currentArenaMatch: ArenaMatch | null;
  loading: boolean;
  error: string | null;

  // Match Actions
  autoCreateMatch: (numPlayers: number, numRounds: number, studentId: string) => Promise<void>;

  // Arena Actions
  createArenaSession: (playerIds: string[], numRounds: number) => Promise<void>;
  getNextArenaMatch: () => Promise<void>;
  setArenaMatchWinner: (winnerIds: string[]) => Promise<{
    match: Match;
    arena_session: ArenaSession;
  }>;
  getArenaResults: () => Promise<void>;
  resetArena: () => void;
}

export const useBattleStore = create<BattleStoreState>((set, get) => ({
  currentArenaSession: null,
  currentArenaMatch: null,
  loading: false,
  error: null,

  autoCreateMatch: async (numPlayers: number, numRounds: number, studentId: string) => {
    set({ loading: true, error: null });
    try {
      const response = await matchApi.autoMatch({ 
        num_players: numPlayers,
        num_rounds: numRounds,
        student_id: studentId
      });
      set({ loading: false });
      return response.data;
    } catch (err) {
      console.error('Failed to auto-create match:', err);
      set({ 
        error: 'Failed to auto-create match',
        loading: false 
      });
    }
  },

  createArenaSession: async (playerIds: string[], numRounds: number) => {
    set({ loading: true, error: null });
    try {
      const response = await arenaApi.createSession({ 
        student_ids: playerIds,
        num_rounds: numRounds 
      });
      set({ 
        currentArenaSession: response.data.data,
        loading: false 
      });
    } catch (err) {
      console.error('Failed to create arena session:', err);
      set({ 
        error: 'Failed to create arena session',
        loading: false 
      });
    }
  },

  getNextArenaMatch: async () => {
    set({ loading: true, error: null });
    try {
      const arenaSession = get().currentArenaSession;
      if (!arenaSession) throw new Error('No active arena session');

      const response = await arenaApi.getNextMatch(arenaSession.id);
      const match = response.data.data;
      
      // Transform match data to expected frontend format
      if (match.participants && match.participants.length === 2) {
        const transformedMatch = {
          ...match,
          player1_id: match.participants[0].student_id,
          player2_id: match.participants[1].student_id,
          player1_elo_before: match.participants[0].elo_before,
          player2_elo_before: match.participants[1].elo_before,
          player1_elo_after: match.participants[0].elo_after,
          player2_elo_after: match.participants[1].elo_after,
          winner_ids: []
        };
        set({ 
          currentArenaMatch: transformedMatch,
          loading: false 
        });
      } else {
        throw new Error('Invalid match data: Expected exactly 2 participants');
      }
    } catch (err) {
      console.error('Failed to get next match:', err);
      set({ 
        error: err instanceof Error ? err.message : 'Failed to get next match',
        loading: false 
      });
    }
  },

  setArenaMatchWinner: async (winnerIds: string[]) => {
    set({ loading: true, error: null });
    try {
      const match = get().currentArenaMatch;
      if (!match) throw new Error('No active match');

      const response = await arenaApi.setMatchWinner(match.id, winnerIds);
      if (!response?.data?.data) {
        throw new Error('Invalid response from setMatchWinner');
      }

      const { match: updatedMatch, arena_session: updatedArenaSession } = response.data.data;

      // Transform updated match data
      const transformedMatch = {
        ...updatedMatch,
        player1_id: updatedMatch.participants[0].student_id,
        player2_id: updatedMatch.participants[1].student_id,
        player1_elo_before: updatedMatch.participants[0].elo_before,
        player2_elo_before: updatedMatch.participants[1].elo_before,
        player1_elo_after: updatedMatch.participants[0].elo_after,
        player2_elo_after: updatedMatch.participants[1].elo_after,
        winner_ids: winnerIds
      };

      // Update arena session with the correct data from backend
      set({
        currentArenaSession: updatedArenaSession,
        currentArenaMatch: transformedMatch,
        loading: false
      });

      // Return the response data for the hook to use
      return response.data.data;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to set match winner';
      console.error('Failed to set match winner:', err);
      set({ 
        error: errorMessage,
        loading: false 
      });
      throw err; // Re-throw to let hook handle error
    }
  },

  getArenaResults: async () => {
    set({ loading: true, error: null });
    try {
      const arenaSession = get().currentArenaSession;
      if (!arenaSession) {
        console.warn('No arena session to fetch results for');
        set({ loading: false });
        return;
      }

      const response = await arenaApi.getResults(arenaSession.id);
      const finalParticipants = response.data.data;

      // Merge final results into current session
      set((state) => ({
        currentArenaSession: state.currentArenaSession
          ? {
              ...state.currentArenaSession,
              participants: finalParticipants,
              status: ArenaSessionStatus.COMPLETED,
            }
          : null,
        currentArenaMatch: null, // no active match anymore
        loading: false,
        error: null,
      }));
    } catch (err) {
      console.error('Failed to get arena results:', err);
      set({ 
        error: 'Failed to get arena results',
        loading: false 
      });
    }
  },

  resetArena: () => {
    set({
      currentArenaSession: null,
      currentArenaMatch: null,
      error: null,
      loading: false
    });
  }
}));



================================================================================
File: frontend\src\stores\createEntityStore.ts
================================================================================

import { StateCreator } from 'zustand';

/** 
 * Define a minimal interface for your API. 
 * You might have slightly different naming or additional methods, 
 * but the idea is that createEntityStore just needs to know how 
 * to do the 5 major CRUD ops plus maybe a custom "getStats".
 */
export interface EntityApi<T> {
  getAll: () => Promise<T[]>;
  getById?: (id: string) => Promise<T>; 
  create?: (data: Partial<T>) => Promise<T>;
  update?: (id: string, data: Partial<T>) => Promise<T>;
  delete?: (id: string) => Promise<void>;
  /** If you have custom endpoints like getStats, put them here. */
}

export interface EntityState<T> {
  items: T[];
  loading: boolean;
  error: string | null;
  fetchAll: () => Promise<void>;
  fetchOne?: (id: string) => Promise<void>;
  createItem?: (data: Partial<T>) => Promise<void>;
  updateItem?: (id: string, data: Partial<T>) => Promise<void>;
  deleteItem?: (id: string) => Promise<void>;
}

/**
 * This is the actual factory function that creates a slice of Zustand state 
 * for a given entity type `T`. 
 *
 * It receives an `entityName` (for better error messages) and an `api` 
 * object that knows how to perform the CRUD calls on that entity.
 */
export function createEntityStore<T>(
  entityName: string,
  api: EntityApi<T>
): StateCreator<
  EntityState<T>, // the slice we are creating
  [],
  [],
  EntityState<T>
> {
  return (set, get) => ({
    items: [],
    loading: false,
    error: null,

    // Fetch all
    fetchAll: async () => {
      set({ loading: true, error: null });
      try {
        const data = await api.getAll();
        set({
          items: data,
          loading: false,
          error: null,
        });
      } catch (err) {
        console.error(`Failed to fetchAll ${entityName}:`, err);
        set({
          error: `Failed to fetch ${entityName}`,
          loading: false,
        });
      }
    },

    // Optional: Fetch one
    fetchOne: api.getById
      ? async (id: string) => {
          set({ loading: true, error: null });
          try {
            const item = await api.getById!(id);
            // if you want to store this single item in items[], 
            // you can push or replace an existing item.
            const existingItems = get().items;
            const index = existingItems.findIndex((x: any) => (x.id || x._id) === id);
            if (index !== -1) {
              existingItems[index] = item;
            } else {
              existingItems.push(item);
            }
            set({
              items: [...existingItems],
              loading: false,
              error: null,
            });
          } catch (err) {
            console.error(`Failed to fetchOne ${entityName}:`, err);
            set({
              error: `Failed to fetch one ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,

    // Optional: Create
    createItem: api.create
      ? async (data: Partial<T>) => {
          set({ loading: true, error: null });
          try {
            const newItem = await api.create!(data);
            set({
              items: [...get().items, newItem],
              loading: false,
              error: null,
            });
          } catch (err) {
            console.error(`Failed to create ${entityName}:`, err);
            set({
              error: `Failed to create ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,

    // Optional: Update
    updateItem: api.update
      ? async (id: string, data: Partial<T>) => {
          set({ loading: true, error: null });
          try {
            const updatedItem = await api.update!(id, data);
            set((state) => ({
              items: state.items.map((i: any) => {
                if ((i.id || i._id) === id) {
                  return updatedItem;
                }
                return i;
              }),
              loading: false,
              error: null,
            }));
          } catch (err) {
            console.error(`Failed to update ${entityName}:`, err);
            set({
              error: `Failed to update ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,

    // Optional: Delete
    deleteItem: api.delete
      ? async (id: string) => {
          set({ loading: true, error: null });
          try {
            await api.delete!(id);
            set((state) => ({
              items: state.items.filter((i: any) => (i.id || i._id) !== id),
              loading: false,
              error: null,
            }));
          } catch (err) {
            console.error(`Failed to delete ${entityName}:`, err);
            set({
              error: `Failed to delete ${entityName}`,
              loading: false,
            });
          }
        }
      : undefined,
  });
}



================================================================================
File: frontend\src\stores\flashcardStore.ts
================================================================================

import { create } from 'zustand';
import { createEntityStore, EntityState } from './createEntityStore';
import { flashcardEntityApi, flashcardExtraApi } from '../services/flashcardEntityApi';
import type { Flashcard } from '../types';

interface FlashcardStoreState {
  flashcards: Flashcard[];
  loading: boolean;
  error: string | null;
  fetchFlashcards: () => Promise<void>;
  addFlashcard: (data: Partial<Flashcard>) => Promise<void>;
  updateFlashcard: (id: string, data: Partial<Flashcard>) => Promise<void>;
  deleteFlashcard: (id: string) => Promise<void>;
  getByPack: (packId: string) => Promise<void>;
}

type SetState = (
  partial: Partial<FlashcardStoreState> | 
  ((state: FlashcardStoreState) => Partial<FlashcardStoreState>),
  replace?: boolean
) => void;

const createCustomSet = (baseSet: SetState): SetState => (partial) => {
  baseSet((state) => {
    const newState = typeof partial === 'function' ? partial(state) : partial;
    return {
      ...state,
      ...newState
    };
  });
};

const createStore = (baseSet: any, get: any, _store: any): FlashcardStoreState => {
  const set = createCustomSet(baseSet as SetState);
  
  type EntityStateWrapper = <T>(
    entityStore: (
      set: any,
      get: () => EntityState<T>,
      store: any
    ) => EntityState<T>
  ) => (set: any, get: any, store: any) => EntityState<T>;

  const createEntityStateWrapper: EntityStateWrapper = <T>(
    entityStore: (
      set: any,
      get: () => EntityState<T>,
      store: any
    ) => EntityState<T>
  ) => (set, get, store) => {
    const wrappedGet = () => ({
      items: [],
      loading: false,
      error: null,
      fetchAll: async () => {},
      ...get()
    }) as EntityState<T>;
    
    return entityStore(set, wrappedGet, store);
  };

  const flashcardStore = createEntityStateWrapper<Flashcard>(
    createEntityStore<Flashcard>('flashcards', flashcardEntityApi)
  )(
    (partial: EntityState<Flashcard> | Partial<EntityState<Flashcard>>) => 
      set((state) => ({
        ...state,
        loading: 'loading' in partial ? partial.loading : state.loading,
        error: 'error' in partial ? partial.error : state.error,
        flashcards: 'items' in partial ? partial.items : state.flashcards
      })),
    get,
    _store
  );

  return {
    // Initialize state
    flashcards: [],
    loading: false,
    error: null,

    // Flashcard operations
    fetchFlashcards: flashcardStore.fetchAll,
    addFlashcard: flashcardStore.createItem!,
    updateFlashcard: flashcardStore.updateItem!,
    deleteFlashcard: flashcardStore.deleteItem!,

    // Pack-related operation
    getByPack: async (packId: string) => {
      set({ loading: true, error: null });
      try {
        const response = await flashcardExtraApi.getByPack(packId);
        set((state) => ({
          ...state,
          flashcards: response.data.data,
          loading: false
        }));
      } catch (err) {
        console.error('Failed to get flashcards by pack:', err);
        set((state) => ({
          ...state,
          error: 'Failed to get flashcards by pack',
          loading: false
        }));
      }
    }
  };
};

export const useFlashcardStore = create<FlashcardStoreState>(createStore);



================================================================================
File: frontend\src\stores\importExportStore.ts
================================================================================

import { create } from 'zustand';
import { flashcardExtraApi } from '../services/flashcardEntityApi';
import { useFlashcardStore } from './flashcardStore';

interface ImportExportStoreState {
  loading: boolean;
  error: string | null;
  bulkImport: (file: File) => Promise<void>;
  getImportTemplate: () => Promise<void>;
  exportPack: (packId: string) => Promise<void>;
}

const createStore = (set: any, get: any): ImportExportStoreState => ({
  loading: false,
  error: null,

  bulkImport: async (file: File) => {
    set({ loading: true, error: null });
    try {
      await flashcardExtraApi.bulkImport(file);
      // Refresh the flashcards list after bulk import
      await useFlashcardStore.getState().fetchFlashcards();
      set({ loading: false });
    } catch (err) {
      console.error('Failed to bulk import flashcards:', err);
      set({
        error: 'Failed to bulk import flashcards',
        loading: false
      });
    }
  },

  getImportTemplate: async () => {
    try {
      await flashcardExtraApi.getImportTemplate();
    } catch (err) {
      console.error('Failed to get import template:', err);
      set({ error: 'Failed to get import template' });
    }
  },

  exportPack: async (packId: string) => {
    try {
      await flashcardExtraApi.exportPack(packId);
    } catch (err) {
      console.error('Failed to export pack:', err);
      set({ error: 'Failed to export pack' });
    }
  }
});

export const useImportExportStore = create<ImportExportStoreState>(createStore);



================================================================================
File: frontend\src\stores\index.ts
================================================================================

export { useStudentStore } from './studentStore';
export { useFlashcardStore } from './flashcardStore';
export { usePackStore } from './packStore';
export { useImportExportStore } from './importExportStore';
export { useBattleStore } from './battleStore';

// Re-export types that might be needed by components
export type { EntityState } from './createEntityStore';



================================================================================
File: frontend\src\stores\packStore.ts
================================================================================

import { create } from 'zustand';
import { createEntityStore, EntityState } from './createEntityStore';
import { flashcardPackEntityApi } from '../services/flashcardPackEntityApi';
import type { FlashcardPack } from '../types';

interface PackStoreState {
  packs: FlashcardPack[];
  loading: boolean;
  error: string | null;
  fetchPacks: () => Promise<void>;
  addPack: (data: Partial<FlashcardPack>) => Promise<void>;
  updatePack: (id: string, data: Partial<FlashcardPack>) => Promise<void>;
  deletePack: (id: string) => Promise<void>;
}

type SetState = (
  partial: Partial<PackStoreState> | 
  ((state: PackStoreState) => Partial<PackStoreState>),
  replace?: boolean
) => void;

const createCustomSet = (baseSet: SetState): SetState => (partial) => {
  baseSet((state) => {
    const newState = typeof partial === 'function' ? partial(state) : partial;
    return {
      ...state,
      ...newState
    };
  });
};

const createStore = (baseSet: any, get: any, _store: any): PackStoreState => {
  const set = createCustomSet(baseSet as SetState);
  
  type EntityStateWrapper = <T>(
    entityStore: (
      set: any,
      get: () => EntityState<T>,
      store: any
    ) => EntityState<T>
  ) => (set: any, get: any, store: any) => EntityState<T>;

  const createEntityStateWrapper: EntityStateWrapper = <T>(
    entityStore: (
      set: any,
      get: () => EntityState<T>,
      store: any
    ) => EntityState<T>
  ) => (set, get, store) => {
    const wrappedGet = () => ({
      items: [],
      loading: false,
      error: null,
      fetchAll: async () => {},
      ...get()
    }) as EntityState<T>;
    
    return entityStore(set, wrappedGet, store);
  };

  const packStore = createEntityStateWrapper<FlashcardPack>(
    createEntityStore<FlashcardPack>('packs', flashcardPackEntityApi)
  )(
    (partial: EntityState<FlashcardPack> | Partial<EntityState<FlashcardPack>>) => 
      set((state) => ({
        ...state,
        loading: 'loading' in partial ? partial.loading : state.loading,
        error: 'error' in partial ? partial.error : state.error,
        packs: 'items' in partial ? partial.items : state.packs
      })),
    get,
    _store
  );

  return {
    // Initialize state
    packs: [],
    loading: false,
    error: null,

    // Pack operations
    fetchPacks: packStore.fetchAll,
    addPack: packStore.createItem!,
    updatePack: packStore.updateItem!,
    deletePack: packStore.deleteItem!
  };
};

export const usePackStore = create<PackStoreState>(createStore);



================================================================================
File: frontend\src\stores\studentStore.ts
================================================================================

import { create } from 'zustand';
import { createEntityStore, EntityState } from './createEntityStore';
import { studentEntityApi } from '../services/studentEntityApi';
import { studentApi } from '../services/api';
import type { Student, MatchHistoryItem } from '../types';
import { useBattleStore } from './battleStore';

interface StudentStoreState {
  // Base state
  students: Student[];
  loading: boolean;
  error: string | null;
  studentHistory: Record<string, MatchHistoryItem[]>;
  // Operations
  fetchStudents: () => Promise<void>;
  addStudent: (data: Partial<Student>) => Promise<void>;
  updateStudent: (id: string, data: Partial<Student>) => Promise<void>;
  deleteStudent: (id: string) => Promise<void>;
  // Custom functionality
  updateStudentStats: (studentId: string) => Promise<void>;
  fetchStudentHistory: (studentId: string) => Promise<void>;
  resetStudentStats: (studentId: string) => Promise<void>;
}

type SetState = (
  partial: Partial<StudentStoreState> | 
  ((state: StudentStoreState) => Partial<StudentStoreState>),
  replace?: boolean
) => void;

// Custom set function to handle state updates
const createCustomSet = (baseSet: SetState): SetState => (partial) => {
  baseSet((state) => {
    const newState = typeof partial === 'function' ? partial(state) : partial;
    return {
      ...state,
      ...newState
    };
  });
};

// Store implementation
const createStore = (baseSet: any, get: any, _store: any): StudentStoreState => {
  const set = createCustomSet(baseSet as SetState);

  // Create entity store directly
  const studentStore = createEntityStore<Student>(
    'students',
    studentEntityApi
  )(
    (partial) => set((state) => ({
      ...state,
      loading: 'loading' in partial ? partial.loading : state.loading,
      error: 'error' in partial ? partial.error : state.error,
      students: 'items' in partial ? partial.items : state.students
    })),
    () => {
      const state = get();
      return {
        items: state.students,
        loading: state.loading,
        error: state.error,
        fetchAll: state.fetchStudents,
        createItem: state.addStudent,
        updateItem: state.updateStudent,
        deleteItem: state.deleteStudent
      };
    },
    _store
  );

  return {
    // Initialize state
    students: [],
    loading: false,
    error: null,
    studentHistory: {},

    // Map operations
    fetchStudents: studentStore.fetchAll,
    addStudent: studentStore.createItem!,
    updateStudent: studentStore.updateItem!,
    deleteStudent: studentStore.deleteItem!,
    
    // Custom functionality
    updateStudentStats: async (studentId: string) => {
      try {
        const response = await studentApi.getStats(studentId);
        set((state) => ({
          ...state,
          students: state.students.map((student: Student) =>
            student.id === studentId ? response.data.data : student
          ),
          error: null
        }));
      } catch (err) {
        console.error('Failed to update student stats:', err);
        set((state) => ({
          ...state,
          error: 'Failed to update student stats'
        }));
      }
    },

    fetchStudentHistory: async (studentId: string) => {
      // Skip if we already have the history
      const currentState = get();
      if (studentId in currentState.studentHistory) {
        return;
      }
      
      set({ loading: true, error: null });
      try {
        const response = await studentApi.getHistory(studentId);
        const { data } = response.data;
        set(state => ({
          ...state,
          studentHistory: {
            ...state.studentHistory,
            [studentId]: data,
          },
          loading: false,
          error: null
        }));
      } catch (err) {
        console.error('Failed to fetch student history:', err);
        set({ loading: false, error: 'Failed to fetch student history' });
      }
    },

    resetStudentStats: async (studentId: string) => {
      set({ loading: true, error: null });
      try {
        const response = await studentApi.resetStats(studentId);
        
        // Update student in store
        set((state) => ({
          ...state,
          students: state.students.map((student) =>
            student.id === studentId ? response.data.data : student
          ),
          loading: false,
          error: null
        }));

        // Reset arena state if the student is in the current session
        const battleStore = useBattleStore.getState();
        const currentSession = battleStore.currentArenaSession;
        if (currentSession?.participants.some(p => p.student_id === studentId)) {
          battleStore.resetArena();
        }
      } catch (err) {
        console.error('Failed to reset student stats:', err);
        set({
          loading: false,
          error: 'Failed to reset student stats'
        });
      }
    }
  };
};

// Create and export the store
export const useStudentStore = create<StudentStoreState>(createStore);



================================================================================
File: frontend\src\theme\index.ts
================================================================================

import { createTheme, MantineTheme } from '@mantine/core';

export const theme = createTheme({
  primaryColor: 'teal',

  colors: {
    teal: [
      '#E6FCF5',
      '#C3FAE8',
      '#96F2D7',
      '#63E6BE',
      '#38D9A9',
      '#20C997', // primary teal
      '#12B886',
      '#0CA678',
      '#099268',
      '#087F5B',
    ],
  },

  fontFamily: 'Inter, sans-serif',
  headings: {
    fontFamily: 'Inter, sans-serif',
    sizes: {
      h1: { fontSize: '2.25rem', fontWeight: '800' },
      h2: { fontSize: '1.75rem', fontWeight: '700' },
      h3: { fontSize: '1.5rem', fontWeight: '600' },
    },
  },

  defaultRadius: 'md',

  components: {
    Button: {
      defaultProps: {
        size: 'md',
        radius: 'md',
      },
      styles: (theme: MantineTheme) => ({
        root: {
          fontWeight: 600,
        },
      }),
    },
    Card: {
      defaultProps: {
        p: 'lg',
        shadow: 'sm',
        radius: 'md',
      },
    },
  },
  // Custom theme properties for the battle arena
  other: {
    battleArena: {
      cardElevation: 3,
      animationDuration: 300,
      spacing: {
        xs: '0.5rem',
        sm: '1rem',
        md: '1.5rem',
        lg: '2rem',
        xl: '3rem',
      },
    },
  },
});

// Type for custom theme to be used with useTheme hook
declare module '@mantine/core' {
  export interface MantineThemeOther {
    battleArena: {
      cardElevation: number;
      animationDuration: number;
      spacing: {
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
      };
    };
  }
}



================================================================================
File: frontend\src\types\arena.ts
================================================================================

import type { Student, Flashcard } from './index';

export enum ArenaStep {
  SETUP = 'setup',      // choose pack, players, rounds
  VERSUS = 'versus',    // show "VS" screen
  BATTLE = 'battle',    // show random flashcard
  ROUND_RESULT = 'round_result',
  FINAL_RESULT = 'final_result'
}

export interface ParticipantScore {
  student: Student;
  eloBefore: number;
  eloCurrent: number;
  wins: number;
  losses: number;
  fightsPlayed: number;
  totalEloChange: number;
}

export interface ValidationError {
  pack?: string;
  players?: string;
  rounds?: string;
}

export interface ArenaSetupData {
  selectedPackId: string;
  numRounds: number;
  selectedPlayerIds: string[];
}



================================================================================
File: frontend\src\types\index.ts
================================================================================

export enum DifficultyLevel {
  EASY = "easy",
  MEDIUM = "medium",
  HARD = "hard"
}

export enum MatchStatus {
  PENDING = "pending",
  IN_PROGRESS = "in_progress",
  COMPLETED = "completed",
  CANCELLED = "cancelled"
}

export enum ArenaSessionStatus {
  PENDING = "pending",
  IN_PROGRESS = "in_progress",
  COMPLETED = "completed"
}

export interface Student {
  id: string;
  name: string;
  elo_rating: number;
  wins: number;
  losses: number;
  total_matches: number;
  created_at: string;
  updated_at: string;
  win_rate: number;
  avatar_url?: string;
}

export interface Flashcard {
  id: string;
  question: string;
  answer: string;
  pack_id: string;
  difficulty: DifficultyLevel;
  times_used: number;
  times_correct: number;
  created_at: string;
  updated_at: string;
  success_rate: number;
}

export interface FlashcardPack {
  id: string;
  name: string;
  description?: string;
  created_at: string;
  updated_at: string;
}

export interface MatchParticipant {
  student_id: string;
  elo_before?: number;
  elo_after?: number;
  student?: Student;
}

export interface RoundParticipant {
  student_id: string;
  elo_before?: number;
  elo_change?: number;
  answer?: string;
  student?: Student;
}

export interface Match {
  id: string;
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  winner_ids?: string[];
  created_at: string;
  updated_at: string;
  participants: MatchParticipant[];
  winners?: Student[];
  rounds?: Round[];
}

export interface Round {
  id: string;
  match_id: string;
  flashcard_id: string;
  winner_ids?: string[];
  created_at: string;
  match?: Match;
  flashcard?: Flashcard;
  winners?: Student[];
  participants: RoundParticipant[];
}

// Arena Types
export interface ArenaSession {
  id: string;
  status: ArenaSessionStatus;
  num_rounds: number;
  rounds_completed: number;
  created_at: string;
  updated_at: string;
  participants?: Array<ArenaStudentStats>;
}

export interface ArenaMatch {
  id: string;
  arena_id: string;
  status: MatchStatus;
  num_rounds: number;
  rounds_completed: number;
  player1_id: string;
  player2_id: string;
  winner_ids?: string[];
  player1_elo_before: number;
  player2_elo_before: number;
  player1_elo_after?: number;
  player2_elo_after?: number;
  created_at: string;
  updated_at: string;
}

export interface ArenaStudentStats {
  student_id: string;
  name?: string;
  elo_rating?: number;
  wins?: number;
  losses?: number;
  fights_played?: number;
  elo_change?: number;
  elo_before?: number;
  elo_after?: number;
  student?: Student;
}

// API Request/Response Types
export interface CreateArenaRequest {
  student_ids: string[];
  num_rounds: number;
}

export interface SetMatchWinnerRequest {
  winner_ids: string[];
}

export interface CreateStudentRequest {
  name: string;
  avatar_url?: string; // EXACT field to match the new backend
}

export interface CreateFlashcardRequest {
  question: string;
  answer: string;
  pack_id: string;
  difficulty?: DifficultyLevel;
}

export interface CreateFlashcardPackRequest {
  name: string;
  description?: string;
}

export interface CreateMultiplayerMatchRequest {
  player_ids: string[];
  num_rounds: number;
}

export interface AutoMatchRequest {
  num_players: number;
  num_rounds: number;
  student_id: string;
}

export interface CreateRoundRequest {
  match_id: string;
  flashcard_id: string;
}

export interface RoundWinnerRequest {
  round_id: string;
  winner_ids: string[];
}

// Bulk Operations Types
export interface BulkImportResult {
  total: number;
  successful: number;
  failed: number;
  errors: string[];
}

// Flashcard Statistics Types
export interface FlashcardStats {
  total_uses: number;
  success_rate: number;
  average_winners: number;
  used_in_arenas: number;
}

export interface FlashcardUsageStats {
  id: string;
  question: string;
  usage_count: number;
  success_rate: number;
  used_in_arenas: number;
}

export interface FlashcardArenaStats {
  id: string;
  question: string;
  times_used: number;
  success_rate: number;
}

export interface MatchHistoryItem {
  match_id: string;
  date: string;
  opponent_name: string;
  old_elo: number;
  new_elo: number;
  elo_change: number;
  result: 'win' | 'loss' | 'unknown';
}

// Test Helper Types
export type ArenaParticipantTestData = Pick<ArenaStudentStats, 'student_id' | 'student' | 'elo_before' | 'elo_after' | 'wins' | 'losses'>;

// API Response Types
export interface ApiResponse<T> {
  data: T;
  message?: string;
  error?: string;
}


